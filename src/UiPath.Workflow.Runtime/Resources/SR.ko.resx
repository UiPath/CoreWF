<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AbortingDueToDynamicUpdateFailure" xml:space="preserve">
    <value>인스턴스 업데이트 시도가 실패하였기 때문에 WorkflowApplication이 중단되었습니다.</value>
  </data>
  <data name="AbortingDueToInstanceTimeout" xml:space="preserve">
    <value>워크플로 인스턴스 실행 시간이 초과되어 워크플로 인스턴스가 중단되었습니다.</value>
  </data>
  <data name="AbortingDueToLoadFailure" xml:space="preserve">
    <value>Load 또는 LoadRunnableInstance 작업에 예외가 발생하여 WorkflowApplication이 중단되었습니다. 새 WorkflowApplication 개체를 만들어 다른 워크플로 인스턴스를 로드해 보십시오.</value>
  </data>
  <data name="AbortingDueToVersionMismatch" xml:space="preserve">
    <value>Load 또는 LoadRunnableInstance 작업에서 VersionMismatchException이 발생했기 때문에 WorkflowApplication이 중단되었습니다.</value>
  </data>
  <data name="AbortInstanceOnTransactionFailureDoesNotMatch" xml:space="preserve">
    <value>TransactedReceiveScope 작업 '{1}'에 중첩된 TransactionScope 작업 '{0}'의 AbortInstanceOnTransactionFailure 속성 값은 false로 설정되면 안 됩니다.</value>
  </data>
  <data name="ActionItemCallbackInvoked" xml:space="preserve">
    <value>IO 스레드 스케줄러 콜백이 호출되었습니다.</value>
  </data>
  <data name="ActionItemIsAlreadyScheduled" xml:space="preserve">
    <value>아직 완료되지 않은 실행에 대해 ActionItem이 이미 예약되어 있습니다.</value>
  </data>
  <data name="ActionItemScheduled" xml:space="preserve">
    <value>IO 스레드 스케줄러 콜백이 호출되었습니다.</value>
  </data>
  <data name="ActivityBlockingUpdate" xml:space="preserve">
    <value>작업 '{0}': {1}</value>
  </data>
  <data name="ActivityCannotBeReferenced" xml:space="preserve">
    <value>워크플로의 다른 곳에서 이미 '{0}' 작업을 참조했으며 '{1}' 작업에는 그 참조가 보이지 않기 때문에 '{1}' 작업은 '{0}' 작업을 참조할 수 없습니다. '{1}' 작업에서 '{0}' 작업이 보이게 하려면 '{2}' 작업의 자식이거나 가져온 자식(구현 자식 제외)이어야 합니다. '{0}' 작업은 원래 '{3}' 작업에 의해 참조되고 '{1}' 작업은 '{2}' 작업의 구현에 속합니다.</value>
  </data>
  <data name="ActivityCannotBeReferencedWithoutTarget" xml:space="preserve">
    <value>'{1}' 작업이 다른 작업의 구현에 있지 않기 때문에 이 작업에서 '{0}' 작업을 참조할 수 없습니다. 작업에 대한 참조는 해당 작업을 자식 또는 가져오기로 지정하는 작업의 구현에서만 가능합니다. '{0}' 작업은 '{2}' 작업에 의해 선언되었습니다.</value>
  </data>
  <data name="ActivityCannotReferenceItself" xml:space="preserve">
    <value>표시 이름이 '{0}'인 작업이 자신을 참조하려고 합니다. 작업은 자신의 부모가 될 수 없습니다.</value>
  </data>
  <data name="ActivityCompleted" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'이(가) '{3}' 상태로 완료되었습니다.</value>
  </data>
  <data name="ActivityDefinitionCannotBeShared" xml:space="preserve">
    <value>'{0}'의 작업 정의 개체가 워크플로에서 여러 노드 간에 공유되는 것으로 나타납니다. 작업 정의 개체는 워크플로 내에서 다시 사용할 수 없습니다.</value>
  </data>
  <data name="ActivityDelegateAlreadyOpened" xml:space="preserve">
    <value>ActivityDelegate '{0}'은(는) 작업 '{1}'에서 이미 부모로 지정되었으므로 작업 '{2}'에서 부모로 지정될 수 없습니다. 대리자는 자식으로 한 번만 반환될 수 있습니다.</value>
  </data>
  <data name="ActivityDelegateCannotBeReferenced" xml:space="preserve">
    <value>'{1}' 작업이 '{2}' 작업의 구현에 있지 않기 때문에 이 작업에서 처리기가 '{0}'인 작업 대리자를 참조할 수 없습니다. 작업 대리자에 대한 참조는 해당 작업 대리자를 자식 또는 가져오기로 지정하는 작업의 구현에서만 가능합니다. 처리기가 '{0}'인 작업 대리자는 '{3}' 작업에 의해 선언되었습니다.</value>
  </data>
  <data name="ActivityDelegateCannotBeReferencedNoHandler" xml:space="preserve">
    <value>'{0}' 작업이 '{1}' 작업의 구현에 있지 않기 때문에 이 작업에서 처리기가 없는 작업 대리자를 참조할 수 없습니다. 작업 대리자에 대한 참조는 해당 작업 대리자를 자식 또는 가져오기로 지정하는 작업의 구현에서만 가능합니다. 처리기가 없는 작업 대리자는 '{2}' 작업에 의해 선언되었습니다.</value>
  </data>
  <data name="ActivityDelegateCannotBeReferencedWithoutTarget" xml:space="preserve">
    <value>'{1}' 작업이 다른 작업의 구현에 있지 않기 때문에 이 작업에서 처리기가 '{0}'인 작업 대리자를 참조할 수 없습니다. 작업 대리자에 대한 참조는 해당 작업 대리자를 자식 또는 가져오기로 지정하는 작업의 구현에서만 가능합니다. 처리기가 '{0}'인 작업 대리자는 '{2}' 작업에 의해 선언되었습니다.</value>
  </data>
  <data name="ActivityDelegateCannotBeReferencedWithoutTargetNoHandler" xml:space="preserve">
    <value>'{0}' 작업이 다른 작업의 구현에 있지 않기 때문에 이 작업에서 처리기가 없는 작업 대리자를 참조할 수 없습니다. 작업 대리자에 대한 참조는 해당 작업 대리자를 자식 또는 가져오기로 지정하는 작업의 구현에서만 가능합니다. 처리기가 없는 작업 대리자는 '{1}' 작업에 의해 선언되었습니다.</value>
  </data>
  <data name="ActivityDelegateHandlersMustBeDeclarations" xml:space="preserve">
    <value>ActivityDelegate, ActivityAction 또는 ActivityFunc에 대한 처리기는 트리에 이미 있는 작업에 대한 참조가 아니어야 합니다. '{1}'에서 부모로 지정한 대리자의 처리기 작업 '{0}'은(는) 이미 '{2}'에 의해 참조되었습니다.</value>
  </data>
  <data name="ActivityDelegateNotOpened" xml:space="preserve">
    <value>ActivityDelegate '{0}'이(가) 열린 상태가 아닙니다.</value>
  </data>
  <data name="ActivityDelegateOwnerEnvironmentMissing" xml:space="preserve">
    <value>작업 대리자 '{1}'을(를) 선언하는 작업 '{0}'에 대한 위치 환경을 찾을 수 없습니다.</value>
  </data>
  <data name="ActivityDelegateOwnerMissing" xml:space="preserve">
    <value>ActivityDelegate '{0}'에는 지정된 소유자 워크플로 요소가 있어야 합니다.</value>
  </data>
  <data name="ActivityDelegateOwnerNotInParentScope" xml:space="preserve">
    <value>ActivityDelegate '{0}'을(를) 선언하는 작업이 현재 실행 중인 '{1}' 작업의 부모 계층 구조에 없습니다.</value>
  </data>
  <data name="ActivityFailedToOpenBefore" xml:space="preserve">
    <value>이 작업은 이전에 열지 못했으므로 열 수 없습니다.</value>
  </data>
  <data name="ActivityHasNoImplementation" xml:space="preserve">
    <value>작업 '{0}'에 구현 맵이 있지만 구현이 없습니다.</value>
  </data>
  <data name="ActivityInstanceFixupFailed" xml:space="preserve">
    <value>워크플로를 로드하지 못했습니다. 지정된 작업 트리가 이 인스턴스와 호환되지 않습니다.</value>
  </data>
  <data name="ActivityIsNotRoot" xml:space="preserve">
    <value>이 인수는 워크플로 정의의 루트여야 합니다.</value>
  </data>
  <data name="ActivityIsUncached" xml:space="preserve">
    <value>이 메서드는 워크플로 정의에서 CacheMetadata가 호출된 후에만 호출할 수 있습니다.</value>
  </data>
  <data name="ActivityMapIsCorrupt" xml:space="preserve">
    <value>작업 프로그램과 인스턴스 간의 매핑이 지속성 인스턴스 내에서 손상되었습니다.</value>
  </data>
  <data name="ActivityNotFound" xml:space="preserve">
    <value>작업 '{0}'을(를) 찾을 수 없습니다.</value>
  </data>
  <data name="ActivityNotICompiledExpressionRoot" xml:space="preserve">
    <value>식 ID를 확인하려면 작업이 ICompiledExpressionRoot여야 합니다. 현재 정의가 컴파일되었는지 확인하십시오.</value>
  </data>
  <data name="ActivityNotPartOfThisTree" xml:space="preserve">
    <value>제공된 작업은 해당 메타데이터를 처리할 때 이 워크플로 정의에 속하지 않았습니다. 문제가 된 이 '{0}' 작업은 '{1}' 작업에 의해 제공되었습니다.</value>
  </data>
  <data name="ActivityPropertyMustBeSet" xml:space="preserve">
    <value>'{0}'은(는) '{1}' 작업의 필수 속성입니다.</value>
  </data>
  <data name="ActivityPropertyNotSet" xml:space="preserve">
    <value>작업 '{1}'의 '{0}' 속성이 null이므로 아무 것도 수행하지 않습니다.</value>
  </data>
  <data name="ActivityPropertyRequiresName" xml:space="preserve">
    <value>'Name'은 DynamicActivity '{0}'에서 각 ActivityProperty의 필수 속성입니다.</value>
  </data>
  <data name="ActivityPropertyRequiresType" xml:space="preserve">
    <value>'Type'은 DynamicActivity '{0}'에서 각 ActivityProperty의 필수 속성입니다.</value>
  </data>
  <data name="ActivityScheduled" xml:space="preserve">
    <value>부모 작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에서 자식 작업 '{3}', DisplayName: '{4}', InstanceId: '{5}'을(를) 예약했습니다.</value>
  </data>
  <data name="ActivityTypeMismatch" xml:space="preserve">
    <value>'{0}'은(는) '{1}' 형식이 아닙니다. 이 인스턴스를 로드하는 경우 이름이 '{0}'인 작업에서 '{1}'을(를) 구현해야 합니다.</value>
  </data>
  <data name="ActivityXamlServiceLineString" xml:space="preserve">
    <value>선</value>
  </data>
  <data name="ActivityXamlServicesCompilationFailed" xml:space="preserve">
    <value>컴파일 오류 발생: {0}전체 결과는 이 예외의 Data 속성에 포함되어 있습니다. 원본의 오류를 수정하고 Load를 다시 시도하십시오.</value>
  </data>
  <data name="ActivityXamlServicesRequiresActivity" xml:space="preserve">
    <value>ActivityXamlServices.Load는 작업 기반 형식만 지원합니다. 잘못된 형식({0})이 제공되었습니다.</value>
  </data>
  <data name="AddedIdleArgumentBlockDU" xml:space="preserve">
    <value>새로 추가된 인수 '{0}의 식에 실행 중 유휴 상태가 될 수 있는 작업 '{1}'이(가) 포함됩니다. 이 작업 내에서 동적 업데이트를 사용하도록 설정하려면 유휴 상태가 되지 않도록 보장되는 인수 식을 사용하십시오.</value>
  </data>
  <data name="AddedIdleExpressionBlockDU" xml:space="preserve">
    <value>실행 중 유휴 상태가 될 수 있는 새로운 변수 기본값 또는 인수 식이 추가되었습니다.</value>
  </data>
  <data name="AddedIdleVariableDefaultBlockDU" xml:space="preserve">
    <value>새로 추가된 변수 '{0}의 기본 식에 실행 중 유휴 상태가 될 수 있는 작업 '{1}'이(가) 포함됩니다. 이 작업 내에서 동적 업데이트를 사용하도록 설정하려면 유휴 상태가 되지 않도록 보장되는 변수 기본값 식을 사용하십시오.</value>
  </data>
  <data name="AddMatchActivityNewAndOldParentMismatch" xml:space="preserve">
    <value>해당 선언자가 일치하지 않기 때문에 새 작업 '{0}'과(와) 이전 작업 '{1}'이(가) 일치하지 않습니다. 새 작업은 '{2}'(으)로 선언되고 이전 작업은 '{3}'(으)로 선언되었습니다.</value>
  </data>
  <data name="AddMatchActivityNewParentMismatch" xml:space="preserve">
    <value>해당 작업의 선언자가 아니기 때문에 작업 '{0}'이(가) 작업 '{1}'에 대한 일치 항목을 추가할 수 없습니다. 일치하는 작업은 '{2}'(으)로 선언됩니다.</value>
  </data>
  <data name="AddMatchActivityPrivateChild" xml:space="preserve">
    <value>전용 자식이기 때문에 작업 '{0}'에 대한 일치 항목을 추가할 수 없습니다. 공용 자식의 경우에만 일치 항목을 추가할 수 있습니다.</value>
  </data>
  <data name="AddMatchVariableNewAndOldParentMismatch" xml:space="preserve">
    <value>해당 소유자가 일치하지 않기 때문에 새 변수 '{0}'과(와) 이전 변수 '{1}'이(가) 일치하지 않습니다. 새 변수는 '{2}'에 의해 소유되고 이전 변수는 '{3}'에 의해 소유됩니다.</value>
  </data>
  <data name="AddMatchVariableNewParentMismatch" xml:space="preserve">
    <value>해당 작업의 소유자가 아니기 때문에 작업 '{0}'이(가) 변수 '{1}'에 대한 일치 항목을 추가할 수 없습니다. 일치하는 변수는 '{2}'에 의해 소유됩니다.</value>
  </data>
  <data name="AddMatchVariablePrivateChild" xml:space="preserve">
    <value>전용 변수이기 때문에 변수 '{0}'에 대한 일치 항목을 추가할 수 없습니다. 공용 변수의 경우에만 일치 항목을 추가할 수 있습니다.</value>
  </data>
  <data name="AddMatchVariableSignatureMismatch" xml:space="preserve">
    <value>두 변수의 서명이 일치하지 않기 때문에 작업 '{0}'이(가) 변수 일치 항목을 추가할 수 없습니다. 이름, 형식 및 한정자를 포함하는 서명이 일치해야 합니다. 새 변수의 이름, 형식 및 한정자는 각각 {1}, {2} 및 {3}입니다. 이전 변수의 이름, 형식 및 한정자는 각각 {4}, {5} 및 {6}입니다.  </value>
  </data>
  <data name="AddValidationErrorMustBeCalledFromConstraint" xml:space="preserve">
    <value>AddValidationError는 {0} 작업의 하위 트리에서만 호출할 수 있습니다.</value>
  </data>
  <data name="AECDisposed" xml:space="preserve">
    <value>ActivityContext는 ActivityContext가 전달된 함수 범위 내에서만 액세스할 수 있습니다.</value>
  </data>
  <data name="AECForPropertiesHasBeenDisposed" xml:space="preserve">
    <value>이 ExecutionProperties 개체를 만든 ActivityContext가 이미 삭제되었습니다. 속성은 작업의 작업 항목 중에만 액세스할 수 있습니다.</value>
  </data>
  <data name="AlreadyBoundToInstance" xml:space="preserve">
    <value>인스턴스 지속성 시스템에서 잘못된 InstancePersistenceCommand를 처리할 수 없습니다. 명령을 수행하려면 바인딩되지 않은 핸들이 필요하지만 InstanceHandle이 이미 인스턴스에 바인딩되어 있습니다.</value>
  </data>
  <data name="AlreadyBoundToOwner" xml:space="preserve">
    <value>인스턴스 지속성 시스템에서 잘못된 InstancePersistenceCommand를 처리할 수 없습니다. 명령을 수행하려면 바인딩되지 않은 핸들이 필요하지만 InstanceHandle이 이미 인스턴스 소유자에 바인딩되어 있습니다.</value>
  </data>
  <data name="AlreadySetupNoPersist" xml:space="preserve">
    <value>이 워크플로 요소에서 비지속성 블록을 이미 설정했습니다. 워크플로 요소에서는 비지속성 블록을 하나만 설정할 수 있습니다.</value>
  </data>
  <data name="AmbiguousVBVariableReference" xml:space="preserve">
    <value>'{0}'은(는) 모호한 변수 참조입니다. VisualBasic 식별자는 대/소문자를 구분하지 않습니다.</value>
  </data>
  <data name="AppDomainUnload" xml:space="preserve">
    <value>AppDomain을 언로드합니다. AppDomain.FriendlyName {0}, ProcessName {1}, ProcessId {2}.</value>
  </data>
  <data name="ArgumentAlreadyInitialized" xml:space="preserve">
    <value>작업 '{1}'에 대한 인수 '{0}'이(가) 동적 업데이트로 추가되어야 하지만 이미 초기화되었습니다.</value>
  </data>
  <data name="ArgumentAlreadyInUse" xml:space="preserve">
    <value>'{0}' 인수는 작업 '{1}'에서 사용 중이므로 작업 '{2}'에서는 사용할 수 없습니다.</value>
  </data>
  <data name="ArgumentCannotHaveNullOrVoidType" xml:space="preserve">
    <value>DisplayName='{0}'인 작업에 null 또는 void 형식인 이름이 '{1}'인 인수가 있습니다.</value>
  </data>
  <data name="ArgumentDirectionMismatch" xml:space="preserve">
    <value>RuntimeArgument '{0}'에 제공된 Argument는 방향이 일치하지 않아 바인딩할 수 없습니다. RuntimeArgument는 방향을 {1}(으)로 선언하고 Argument의 방향은 {2}입니다.</value>
  </data>
  <data name="ArgumentDoesNotExist" xml:space="preserve">
    <value>이름이 '{0}'인 인수가 이 컬렉션에 없습니다.</value>
  </data>
  <data name="ArgumentDoesNotExistInEnvironment" xml:space="preserve">
    <value>'{0}' 인수가 현재 환경 범위에 없습니다.</value>
  </data>
  <data name="ArgumentIsAddedMoreThanOnce" xml:space="preserve">
    <value>'{0}' 인수가 작업 '{1}'에 두 번 이상 추가되었습니다.</value>
  </data>
  <data name="ArgumentLocationExpressionTypeMismatch" xml:space="preserve">
    <value>형식이 '{0}'인 식이 필요한데 '{1}' 형식이 제공되었습니다.</value>
  </data>
  <data name="ArgumentMustbePropertyofWorkflowElement" xml:space="preserve">
    <value>인수는 WorkflowElement의 속성 중 하나여야 합니다.</value>
  </data>
  <data name="ArgumentNameRequired" xml:space="preserve">
    <value>ArgumentReference 또는 ArgumentValue의 인수 이름을 설정해야 합니다.</value>
  </data>
  <data name="ArgumentNotFound" xml:space="preserve">
    <value>이러한 전용 자식을 소유하는 작업에서 이름이 '{0}'인 인수를 찾을 수 없습니다. ArgumentReference 및 ArgumentValue는 작업 정의 본문에서만 사용해야 합니다.</value>
  </data>
  <data name="ArgumentNotInTree" xml:space="preserve">
    <value>인수 형식 '{0}'은(는) 사용할 수 없습니다. 작업에 선언되었는지 확인하십시오.</value>
  </data>
  <data name="ArgumentNullOrEmpty" xml:space="preserve">
    <value>인수 '{0}'이(가) null이거나 비어 있습니다.</value>
  </data>
  <data name="ArgumentNumberRequiresTheSameAsParameterNumber" xml:space="preserve">
    <value>'{0}' 형식의 인수 개수와 매개 변수 개수는 같아야 합니다.</value>
  </data>
  <data name="ArgumentRequired" xml:space="preserve">
    <value>'{1}'의 '{0}' 컬렉션에 인수 내용이 필요합니다.</value>
  </data>
  <data name="ArgumentTypeCannotBeNull" xml:space="preserve">
    <value>인수 형식은 null일 수 없습니다.</value>
  </data>
  <data name="ArgumentTypeMismatch" xml:space="preserve">
    <value>RuntimeArgument '{0}'에 제공된 Argument는 형식이 일치하지 않아 바인딩할 수 없습니다. RuntimeArgument는 형식을 {1}(으)로 선언하고 Argument의 형식은 {2}입니다. 두 형식이 동일해야 합니다.</value>
  </data>
  <data name="ArgumentTypeMustBeCompatible" xml:space="preserve">
    <value>인수 형식은 이 ArgumentReference 또는 ArgumentValue의 형식과 호환되어야 합니다. 인수 '{0}'의 형식은 {1}이고 필요한 형식은 {2}입니다.</value>
  </data>
  <data name="ArgumentValueExpressionTypeMismatch" xml:space="preserve">
    <value>인수의 ResultType은 '{0}'이어야 하는데 결과 형식이 '{1}'인 작업이 제공되었습니다.</value>
  </data>
  <data name="ArgumentViolationsFound" xml:space="preserve">
    <value>'{0}' 작업에 위반 사항이 있습니다. 다음과 같이 하나 이상의 위반 사항이 발견되었습니다.    {1}</value>
  </data>
  <data name="AssemblyReferenceIsImmutable" xml:space="preserve">
    <value>기본 제공되는 기본 AssemblyReferences는 변경할 수 없습니다.</value>
  </data>
  <data name="AsyncCallbackThrewException" xml:space="preserve">
    <value>비동기 콜백에서 예외가 발생했습니다.</value>
  </data>
  <data name="AsyncEventArgsCompletedTwice" xml:space="preserve">
    <value>AsyncEventArgs 구현 '{0}'에서 단일 작업을 여러 번 완료하려고 했습니다. 이 문제는 잘못된 응용 프로그램 AsyncEventArgs 구현 또는 AsyncCallback을 여러 번 호출하는 다른 확장성 코드로 인해 발생할 수 있습니다.</value>
  </data>
  <data name="AsyncEventArgsCompletionPending" xml:space="preserve">
    <value>AsyncEventArgs 구현 '{0}'에서 보류 중인 작업을 완료하지 않고 상태를 보류 중으로 여러 번 설정하려고 했습니다. 이 문제는 잘못된 응용 프로그램 AsyncEventArgs 구현 또는 Set()을 여러 번 호출하는 다른 확장성 코드로 인해 발생할 수 있습니다.</value>
  </data>
  <data name="AsyncMethodsMustAllBeStaticOrInstance" xml:space="preserve">
    <value>비동기 메서드는 모두 정적 메서드이거나 모두 인스턴스 메서드여야 합니다.</value>
  </data>
  <data name="AsyncMethodsMustFromSameType" xml:space="preserve">
    <value>비동기 메서드는 같은 형식에 속해 있어야 합니다.</value>
  </data>
  <data name="AsyncResultAlreadyEnded" xml:space="preserve">
    <value>AsyncResult에서 End를 두 번 호출할 수 없습니다.</value>
  </data>
  <data name="AsyncResultCompletedTwice" xml:space="preserve">
    <value>IAsyncResult 구현 '{0}'에서 단일 작업을 여러 번 완료하려고 했습니다. 이 문제는 잘못된 응용 프로그램 IAsyncResult 구현 또는 CompletedSynchronously 값을 반환하거나 AsyncCallback을 여러 번 호출하는 IAsyncResult와 같은 다른 확장성 코드로 인해 발생할 수 있습니다.</value>
  </data>
  <data name="AsyncTransactionException" xml:space="preserve">
    <value>트랜잭션 흐름을 비동기 작업으로 진행하는 데 사용되는 TransactionScope에서 예외가 발생했습니다.</value>
  </data>
  <data name="BadCopyToArray" xml:space="preserve">
    <value>지정된 배열에 사전 항목을 복사할 수 없습니다. 이 문제는 세 가지 오류 중 하나 이상으로 인해 발생했습니다. 배열에 차원이 너무 많거나, 인덱스가 배열 끝을 지났거나, 배열에 공간이 부족할 수 있습니다.</value>
  </data>
  <data name="BadWorkflowIdentityFormat" xml:space="preserve">
    <value>잘못된 WorkflowIdentity 형식입니다. WorkflowIdentity는 'name; Version=version; Package=package' 형식을 따라야 합니다. Version 및 Package 부분은 선택 사항입니다.</value>
  </data>
  <data name="BeforeInitializeComponentXBTExtensionResourceNotFound" xml:space="preserve">
    <value>BeforeInitializeComponent XAML 빌드 작업 확장으로 생성되어야 하는 리소스를 찾을 수 없습니다. 프로젝트를 다시 빌드해보십시오.</value>
  </data>
  <data name="BeginExecuteMustNotReturnANullAsyncResult" xml:space="preserve">
    <value>AsyncCodeActivity.BeginExecute에서 null IAsyncResult가 반환되어서는 안 됩니다.</value>
  </data>
  <data name="BeginExecuteMustUseProvidedStateAsAsyncResultState" xml:space="preserve">
    <value>AsyncCodeActivity.BeginExecute는 IAsyncResult.AsyncState가 런타임으로 제공된 상태 개체인 IAsyncResult를 반환해야 합니다.</value>
  </data>
  <data name="BinaryExpressionActivityRequiresArgument" xml:space="preserve">
    <value>{1} 작업 '{2}'을(를) 사용하려면 먼저 {0}을(를) 설정해야 합니다.</value>
  </data>
  <data name="BindLockRequiresCommandFlag" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 명칭은 BindAcquiredLock, BindReclaimedLock, BeginBindReclaimedLock 또는 잘못된 시점의 CreateBindReclaimedLockException 등입니다. 이러한 메서드는 인스턴스 잠금을 얻을 수 있는 명령을 처리할 때만 호출할 수 있습니다. 올바른 지속성 공급자로 전환하거나, AutomaticallyAcquiringLock에서 true를 반환하도록 InstancePersistenceCommand 구현을 다시 정의하십시오.</value>
  </data>
  <data name="BindReclaimedLockException" xml:space="preserve">
    <value>이 예외는 오류를 의미하지 않으며 catch되어서도 안 됩니다. InstanceStore.TryCommand, BeginTryCommand 또는 EndTryCommand의 지속성 공급자 구현에서 이 예외가 발생할 수 있으며 InstancePersistenceContext.CreateBindReclaimedLockException 호출에 지정된 버전에서 잠금을 다시 확보하려고 해야 함을 나타냅니다.</value>
  </data>
  <data name="BindReclaimSucceeded" xml:space="preserve">
    <value>InstanceStore의 지속성 공급자 구현에서 명령을 취소했습니다. InstancePersistenceContext.CreateBindReclaimedLockException을 통해 연결이 끊어진 잠금을 다시 확보하고 명령을 취소했습니다.</value>
  </data>
  <data name="BlockedUpdateInsideActivityUpdateByUserError" xml:space="preserve">
    <value>업데이트 작성자가 이 실행 중인 작업 내에서 업데이트를 허용하지 않았습니다.</value>
  </data>
  <data name="BlockedUpdateInsideActivityUpdateError" xml:space="preserve">
    <value>이 작업에는 동적 업데이트가 차단되어 있습니다.</value>
  </data>
  <data name="BodyCannotBeNull" xml:space="preserve">
    <value>메시지 설명의 본문은 null일 수 없습니다. OperationDescription.MessageDescription.Body를 올바른 값으로 설정하십시오.</value>
  </data>
  <data name="BookmarkAlreadyExists" xml:space="preserve">
    <value>이름이 '{0}'인 책갈피가 이미 있습니다.</value>
  </data>
  <data name="BookmarkNotFoundGeneric" xml:space="preserve">
    <value>요청된 책갈피를 찾을 수 없습니다.</value>
  </data>
  <data name="BookmarkNotRegistered" xml:space="preserve">
    <value>{0} 책갈피가 Compensation Extension에 현재 등록되어 있지 않습니다.</value>
  </data>
  <data name="BookmarkScopeAlreadyInitialized" xml:space="preserve">
    <value>책갈피 범위가 이미 초기화되었으므로 다시 초기화할 수 없습니다.</value>
  </data>
  <data name="BookmarkScopeHasBookmarks" xml:space="preserve">
    <value>지정된 책갈피 범위에 처리되지 않은 책갈피가 있으므로 등록 취소할 수 없습니다.</value>
  </data>
  <data name="BookmarkScopeInitialized" xml:space="preserve">
    <value>TemporaryId: '{0}'인 BookmarkScope가 ID: '{1}'(으)로 초기화되었습니다.</value>
  </data>
  <data name="BookmarkScopeNotFound" xml:space="preserve">
    <value>ID가 '{0}'인 책갈피 범위를 찾을 수 없습니다.</value>
  </data>
  <data name="BookmarkScopeNotRegisteredForInitialize" xml:space="preserve">
    <value>지정된 책갈피 범위가 현재 등록되지 않았으므로 이를 초기화할 수 없습니다.</value>
  </data>
  <data name="BookmarkScopeNotRegisteredForUnregister" xml:space="preserve">
    <value>지정된 책갈피 범위가 현재 등록되지 않았으므로 이를 등록 취소할 수 없습니다.  </value>
  </data>
  <data name="BookmarkScopesRequireKeys" xml:space="preserve">
    <value>책갈피 범위를 지정하려면 키 관리를 지원하는 호스트가 필요합니다. 사용 중인 호스트는 키 관리를 지원하지 않습니다. WorkflowApplication 또는 WorkflowInvoker를 사용 중인 경우 대신 WorkflowServiceHost를 사용해 보십시오.</value>
  </data>
  <data name="BookmarkScopeWithIdAlreadyExists" xml:space="preserve">
    <value>'{0}' 식별자를 사용하는 다른 책갈피 범위가 이미 존재하므로 지정된 책갈피 범위를 이 식별자로 초기화할 수 없습니다.</value>
  </data>
  <data name="BookmarksOnlyResumableWhileIdle" xml:space="preserve">
    <value>TryScheduleBookmarkResumption은 런타임이 유휴 상태인 동안에만 호출할 수 있습니다.</value>
  </data>
  <data name="BufferAllocationFailed" xml:space="preserve">
    <value>{0} 바이트의 관리되는 메모리 버퍼를 할당하지 못했습니다. 사용 가능한 메모리 양이 낮을 수 있습니다.</value>
  </data>
  <data name="BufferedOutputStreamQuotaExceeded" xml:space="preserve">
    <value>이 스트림의 크기 할당량({0})이 초과되었습니다.</value>
  </data>
  <data name="BufferedReceiveBehaviorMultipleUse" xml:space="preserve">
    <value>BufferedReceiveServiceBehavior 인스턴스는 이미 다른 WorkflowServiceHost 인스턴스에 추가되었으므로 WorkflowServiceHost에 추가할 수 없습니다. 각 추가 WorkflowServiceHost에 대해 새로운 BufferedReceiveServiceBehavior 인스턴스를 만드십시오.</value>
  </data>
  <data name="BufferedReceiveBehaviorUsedWithoutProperty" xml:space="preserve">
    <value>BufferedReceive 처리를 지원하는 워크플로 정의에는 BufferedReceiveServiceBehavior를 사용해야 합니다. BufferedReceive 처리를 설정하려면 WorkflowService.AllowBufferedReceive를 사용하십시오.</value>
  </data>
  <data name="BufferedReceiveRequiresReceiveContext" xml:space="preserve">
    <value>이름이 '{0}'인 작업은 BufferedReceiveServiceBehavior가 사용될 경우 ReceiveContext ManualAcknowledgement 모드를 사용하도록 설정해야 합니다.</value>
  </data>
  <data name="BufferIsNotRightSizeForBufferManager" xml:space="preserve">
    <value>이 버퍼는 크기가 잘못되었기 때문에 버퍼 관리자에 반환할 수 없습니다.</value>
  </data>
  <data name="BufferOutOfOrderMessageNoBookmark" xml:space="preserve">
    <value>현재는 서비스 인스턴스 '{0}'에서 '{1}' 작업을 수행할 수 없습니다. 서비스 인스턴스에서 이 특정 작업을 처리할 준비가 되면 다시 작업이 시도됩니다.</value>
  </data>
  <data name="BufferOutOfOrderMessageNoInstance" xml:space="preserve">
    <value>현재는 '{0}' 작업을 수행할 수 없습니다. 서비스 인스턴스에서 이 특정 작업을 처리할 준비가 되면 다시 작업이 시도됩니다.</value>
  </data>
  <data name="BufferPoolAllocation" xml:space="preserve">
    <value>풀에서 {0}바이트를 할당하는 중입니다.</value>
  </data>
  <data name="BufferPoolChangeQuota" xml:space="preserve">
    <value>크기가 {0}인 BufferPool의 할당량을 {1}(으)로 변경하는 중입니다.</value>
  </data>
  <data name="BusyCountTraceFormatString" xml:space="preserve">
    <value>워크플로 인스턴스 ID {0}</value>
  </data>
  <data name="CacheRootMetadataStart" xml:space="preserve">
    <value>CacheRootMetadata가 작업 '{0}'에서 시작되었습니다.</value>
  </data>
  <data name="CacheRootMetadataStop" xml:space="preserve">
    <value>CacheRootMetadata가 작업 '{0}'에서 중지되었습니다.</value>
  </data>
  <data name="CacheSettingsLocked" xml:space="preserve">
    <value>워크플로 인스턴스 또는 호스트 확장 컬렉션에 확장이 이미 추가되었으므로 캐시 설정은 변경할 수 없습니다.</value>
  </data>
  <data name="CallbackExceptionFromHostAbort" xml:space="preserve">
    <value>WorkflowInstance '{0}'의 OnRequestAbort에 대한 호출로 예외가 발생했습니다. 치명적인 예외로 생각됩니다. 자세한 내용은 내부 예외를 참조하십시오.</value>
  </data>
  <data name="CallbackExceptionFromHostGetExtension" xml:space="preserve">
    <value>WorkflowInstance '{0}'의 OnGetExtension에 대한 호출로 예외가 발생했습니다. 치명적인 예외로 생각됩니다. 자세한 내용은 내부 예외를 참조하십시오.</value>
  </data>
  <data name="CancellationHandlerFatalException" xml:space="preserve">
    <value>'{0}'의 Cancellation 처리기에서 처리되지 않은 예외가 발생했습니다. Cancellation이 일관적이지 않은 상태일 수 있으며, 워크플로가 중단되었습니다.</value>
  </data>
  <data name="CanInduceIdleActivityInArgumentExpression" xml:space="preserve">
    <value>'{1}' 작업의 '{0}' 인수가 '{2}' 작업을 포함하는 식에 바인딩되었습니다. '{2}'을(를) 사용하면 평가 중 식이 유휴 상태가 될 수 있습니다. '{1}' 작업의 인수 식이 공유 상태를 수정하는 경우 식 평가 중 유휴 상태가 되면 인수에 대해 예기치 않은 값이 발생할 수 있습니다.</value>
  </data>
  <data name="CanInduceIdleNotSpecified" xml:space="preserve">
    <value>작업 '{0}'이(가) 잘못되었습니다. System.Activities.NativeActivityContext에 정의된 CreateBookmark 오버로드 중 하나를 호출하여 비동기 작업을 수행하는 NativeActivity 파생 작업은 CanInduceIdle 속성을 재정의하고 true를 반환해야 합니다.</value>
  </data>
  <data name="CannotAcquireLockDefault" xml:space="preserve">
    <value>다른 인스턴스 소유자가 인스턴스를 잠가서 InstancePersistenceCommand 실행이 중단되었습니다. 이 오류는 대개 해당 인스턴스를 다른 호스트에서 로드할 때 발생합니다.</value>
  </data>
  <data name="CannotAcquireLockSpecific" xml:space="preserve">
    <value>다른 인스턴스 소유자가 '{0}' 인스턴스를 잠가서 InstancePersistenceCommand 실행이 중단되었습니다. 이 오류는 대개 해당 인스턴스를 다른 호스트에서 로드할 때 발생합니다.</value>
  </data>
  <data name="CannotAcquireLockSpecificWithOwner" xml:space="preserve">
    <value>다른 인스턴스 소유자가 '{0}' 인스턴스를 잠가서 InstancePersistenceCommand 실행이 중단되었습니다. 이 오류는 대개 해당 인스턴스를 다른 호스트에서 로드할 때 발생합니다. 인스턴스에 대한 잠금이 있는 소유자 또는 호스트의 인스턴스 소유자 ID는 '{1}'입니다.</value>
  </data>
  <data name="CannotAddHandlesUpdateError" xml:space="preserve">
    <value>이 동작으로 핸들에서 파생되는 형식의 새 변수가 추가되었습니다.</value>
  </data>
  <data name="CannotAddOrRemoveWithChildren" xml:space="preserve">
    <value>작업에 실행 중인 자식이 있는 경우 작업에서 워크플로 실행 속성을 추가하거나 제거할 수 없습니다.</value>
  </data>
  <data name="CannotCallAbortInstanceFromWorkflowThread" xml:space="preserve">
    <value>AbortInstance가 일관성이 없는 상태가 될 수 있으므로 워크플로 스레드에서 AbortInstance를 호출할 수 없습니다.</value>
  </data>
  <data name="CannotChangeAbortInstanceFlagAfterPropertyRegistration" xml:space="preserve">
    <value>AbortInstanceOnTransactionFailure 플래그 값은 해당 RuntimeTransactionHandle의 IPropertyRegistrationCallback.Register가 실행된 후 수정할 수 없습니다.</value>
  </data>
  <data name="CannotChangeMatchesInImplementation" xml:space="preserve">
    <value>업데이트 맵을 작성 중인 워크플로의 전용 구현 내에서는 새 일치 항목을 추가할 수 없습니다.</value>
  </data>
  <data name="CannotCompleteRuntimeOwnedTransaction" xml:space="preserve">
    <value>현재 트랜잭션은 런타임에 구성되었으므로 런타임에만 완료될 수 있습니다. 앰비언트 트랜잭션이 존재해도 WorkflowInvoker에서 호출 API를 호출하면 일반적으로 런타임 구성 트랜잭션이 생성됩니다.</value>
  </data>
  <data name="CannotCompleteWithKeys" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 활성 키가 연결된 인스턴스의 완료를 보고했습니다. 인스턴스를 완료하려면 먼저 인스턴스에 연결된 모든 키를 완료해야 합니다.</value>
  </data>
  <data name="CannotConvertObject" xml:space="preserve">
    <value>개체 '{1}'을(를) 형식 '{0}'(으)로 변환할 수 없습니다.</value>
  </data>
  <data name="CannotCreateContextWithNullId" xml:space="preserve">
    <value>InstanceStore.CreateInstanceHandle에 대한 instanceId 인수는 Guid.Empty처럼 모두가 0인 ID를 지정할 수 없습니다.</value>
  </data>
  <data name="CannotCreateMessageFault" xml:space="preserve">
    <value>MessageFault를 만들 수 없습니다.</value>
  </data>
  <data name="CannotCreateOwnerWithoutIdentity" xml:space="preserve">
    <value>WorkflowIdentity 없이 기본 인스턴스 소유자를 만들 수 없습니다. 소유자를 만들려면 정의 ID를 지정하거나 WorkflowIdentityFilter.Any를 선택하십시오.</value>
  </data>
  <data name="CanNotDefineNullForAPromotion" xml:space="preserve">
    <value>승격 이름 {1}의 {0} 승격 컬렉션에 null 값이 있습니다.</value>
  </data>
  <data name="CannotDereferenceNull" xml:space="preserve">
    <value>대상 개체가 null이므로 속성이 '{0}'인 제공된 식에서 L-value를 만들 수 없습니다.</value>
  </data>
  <data name="CannotEnlistMultipleTransactions" xml:space="preserve">
    <value>워크플로에 트랜잭션이 이미 등록되어 있습니다. 한 번에 하나의 트랜잭션만 등록할 수 있습니다.</value>
  </data>
  <data name="CanNotFindSymbolResolverInWorkflowInstanceExtensions" xml:space="preserve">
    <value>워크플로 인스턴스 Extensions 컬렉션에서 기호 확인자를 찾을 수 없습니다.</value>
  </data>
  <data name="CannotGenerateSchemaForXmlSerializable" xml:space="preserve">
    <value>'{0}'은(는) 내부 런타임 데이터이며 스키마 생성을 지원하지 않습니다.</value>
  </data>
  <data name="CannotGetValueOfOutArgument" xml:space="preserve">
    <value>out-only 인수 값을 가져올 수 없습니다.</value>
  </data>
  <data name="CannotInvokeBindingFromNonBinding" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 잠금과 무관한 명령을 처리하는 동시에 잠금을 얻어올 수 있는 명령을 실행하려고 했습니다. InstancePersistenceCommand.AutomaticallyAcquiringLock에서 true를 반환하는 명령으로 InstancePersistenceContext.Execute 또는 InstancePersistenceContext.BeginExecute를 호출하면서 false를 반환하는 명령을 처리할 때 이 예외가 발생할 수 있습니다. 그렇게 되지 않는 지속성 공급자를 사용하거나, 명령 중 하나에서 AutomaticallyAcquiringLock을 다시 정의하여 올바른 값이 반환되도록 하십시오.</value>
  </data>
  <data name="CannotInvokeOpenedActivity" xml:space="preserve">
    <value>이 작업은 개체와 문자열의 IDictionary를 사용하는 Invoke 오버로드로 열지 않았으므로 호출할 수 없습니다.</value>
  </data>
  <data name="CannotInvokeTransactionalFromNonTransactional" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 트랜잭션과 무관한 명령을 처리하는 동시에 트랜잭션 명령을 실행하려고 했습니다. InstancePersistenceCommand.IsTransactionEnlistmentOptional에서 false를 반환하는 명령으로 InstancePersistenceContext.Execute 또는 InstancePersistenceContext.BeginExecute를 호출하면서 true를 반환하는 명령을 처리할 때 이 예외가 발생할 수 있습니다. 그렇게 되지 않는 지속성 공급자를 사용하거나, 명령 중 하나에서 IsTransactionEnlistmentOptional을 다시 정의하여 올바른 값이 반환되도록 하십시오.</value>
  </data>
  <data name="CannotModifyCatchAfterOpen" xml:space="preserve">
    <value>이 Catch는 이미 열려 있으므로 수정할 수 없습니다. Catch는 디자인 타임에만 수정할 수 있습니다.</value>
  </data>
  <data name="CannotMoveChildAcrossDifferentFlowNodeTypes" xml:space="preserve">
    <value>자식 작업이 하나의 FlowNode 형식에서 다른 FlowNode 형식으로 이동될 때는 순서도에서 동적 업데이트가 지원되지 않습니다.</value>
  </data>
  <data name="CannotNestTransactedReceiveScopeWhenAmbientHandleIsSuppressed" xml:space="preserve">
    <value>런타임 트랜잭션은 현재 표시되지 않습니다. 런타임 트랜잭션이 표시되지 않는 동안에는 TransactedReceiveScope 작업 '{0}'을(를) 실행할 수 없습니다.</value>
  </data>
  <data name="CannotNestTransactionScopeWhenAmbientHandleIsSuppressed" xml:space="preserve">
    <value>런타임 트랜잭션은 현재 표시되지 않습니다. 런타임 트랜잭션이 표시되지 않는 동안에는 TransactedScope 작업 '{0}'을(를) 실행할 수 없습니다.</value>
  </data>
  <data name="CannotPerformOperationFromHandlerThread" xml:space="preserve">
    <value>이벤트 처리기 내에서 WorkflowApplication 작업을 수행할 수 없습니다.</value>
  </data>
  <data name="CannotPerformOperationOnHandle" xml:space="preserve">
    <value>이 작업은 Handle 하위 형식의 변수에서 수행할 수 없습니다.</value>
  </data>
  <data name="CannotPersistInsideIsolation" xml:space="preserve">
    <value>지속성 작업은 격리 블록 내에 포함할 수 없습니다.</value>
  </data>
  <data name="CannotPersistInsideNoPersist" xml:space="preserve">
    <value>지속성 작업은 비지속성 블록 내에 포함할 수 없습니다.</value>
  </data>
  <data name="CannotPersistWhileDetached" xml:space="preserve">
    <value>인스턴스에 잠금이 없으므로 인스턴스가 지속될 수 없습니다. 잠금 해제 값이 true인 Persist에 대한 이전 호출에서 잠금을 해제했습니다.</value>
  </data>
  <data name="CannotPromoteAsSqlVariant" xml:space="preserve">
    <value>승격된 속성 '{1}'의 데이터 형식 '{0}'은(는) SQL에서 사용할 수 없습니다. 데이터 형식을 지원되는 형식으로 변경하거나 속성을 이진 값으로 승격하십시오.</value>
  </data>
  <data name="CannotPromoteXNameTwiceInPromotion" xml:space="preserve">
    <value>승격 '{1}'에서 XName '{0}'이 여러 번 승격되었습니다. 동일한 승격 내에서 중복된 XName이 허용되지 않습니다.</value>
  </data>
  <data name="CannotPropagateExceptionWhileCanceling" xml:space="preserve">
    <value>취소하는 동안 ID가 {1}인 작업 '{0}'에서 예외가 발생하거나 전파되었습니다.</value>
  </data>
  <data name="CannotRemoveExecutingActivityUpdateError" xml:space="preserve">
    <value>현재 실행 중이기 때문에 동작 '{0}: {1}'을(를) 제거할 수 없습니다.</value>
  </data>
  <data name="CannotReplaceTransaction" xml:space="preserve">
    <value>앰비언트 트랜잭션(System.Transactions.Transaction.Current)이 이 실행 에피소드에 사용되는 트랜잭션과 일치하지 않습니다. 전체 실행 에피소드에서 하나의 트랜잭션만 사용할 수 있습니다.</value>
  </data>
  <data name="CannotResetPropertyInDataContext" xml:space="preserve">
    <value>WorkflowDataContext의 속성을 다시 설정할 수 없습니다.</value>
  </data>
  <data name="CannotSaveOriginalValueForActivity" xml:space="preserve">
    <value>작업에서는 공용 또는 가져온 자식 또는 위임 처리기에 대한 원래 값만 저장할 수 있습니다.</value>
  </data>
  <data name="CannotSaveOriginalValueForNewActivity" xml:space="preserve">
    <value>원본 워크플로 정의에 존재하지 않기 때문에 작업 '{0}'에 대한 원래 값을 저장할 수 없습니다.</value>
  </data>
  <data name="CannotSaveOriginalValuesForReferencedChildren" xml:space="preserve">
    <value>이 작업에서는 작업 구현 내부에 있는 경우 업데이트가 올바르게 처리되지 않습니다. 가져온 자식에 대한 참조의 원래 값을 저장하려고 시도했습니다.</value>
  </data>
  <data name="CannotScheduleChildrenWhileEnteringIsolation" xml:space="preserve">
    <value>격리 블록을 설정하는 동안에는 자식 작업을 예약할 수 없습니다. 자식을 예약하기 전에 OnEntered BookmarkCallback이 호출될 때까지 기다리십시오.</value>
  </data>
  <data name="CannotSerializeExpression" xml:space="preserve">
    <value>"{0}" 형식의 식을 직렬화할 수 없습니다.</value>
  </data>
  <data name="CannotSerializeVariableExpression" xml:space="preserve">
    <value>변수 액세스 하위 식의 형식이 잘못되었거나 해당 식을 인식할 수 없으므로 식을 직렬화할 수 없습니다.</value>
  </data>
  <data name="CannotSetRuntimeTransactionInNoPersist" xml:space="preserve">
    <value>비지속성 범위 내에 포함된 작업을 통해 런타임을 트랜잭션으로 구성할 수 없습니다. 상위 작업에서는 지속성을 허용하지 않습니다.</value>
  </data>
  <data name="CannotSetupIsolationInsideIsolation" xml:space="preserve">
    <value>격리 블록은 다른 격리 블록 내에 포함되므로 격리 블록을 설정할 수 없습니다. 격리 블록은 중첩될 수 없습니다.</value>
  </data>
  <data name="CannotSetupIsolationInsideNoPersist" xml:space="preserve">
    <value>격리 블록은 비지속성 블록 내에 포함되므로 격리 블록을 설정할 수 없습니다.</value>
  </data>
  <data name="CannotSetupIsolationWithChildren" xml:space="preserve">
    <value>실행 중인 자식이 있을 경우 격리 블록을 설정할 수 없습니다.</value>
  </data>
  <data name="CannotSetValueOfInArgument" xml:space="preserve">
    <value>In Argument에 값을 할당할 수 없습니다.</value>
  </data>
  <data name="CannotSetValueToLocation" xml:space="preserve">
    <value>'{0}' 형식의 값은 이름이 '{1}'인 위치에 설정할 수 없습니다. 이 위치는 '{2}' 형식의 위치이기 때문입니다.</value>
  </data>
  <data name="CannotSpecifyBothConnectionStringAndName" xml:space="preserve">
    <value>connectionString 및 connectionStringName 속성을 함께 지정할 수 없습니다.</value>
  </data>
  <data name="CannotSuppressAlreadyRegisteredHandle" xml:space="preserve">
    <value>이미 등록된 RuntimeTransactionHandle에서 SuppressTransaction 속성의 값을 변경할 수 없습니다.</value>
  </data>
  <data name="CannotUnregisterDefaultBookmarkScope" xml:space="preserve">
    <value>책갈피 범위가 인스턴스의 기본 책갈피 범위이므로 삭제할 수 없습니다.</value>
  </data>
  <data name="CannotUnregisterNullBookmarkScope" xml:space="preserve">
    <value>null 책갈피 범위는 등록 취소할 수 없습니다.</value>
  </data>
  <data name="CannotUpdateEnvironmentInTheMiddleOfResolvingArguments" xml:space="preserve">
    <value>인스턴스에서 인수를 확인하는 중에는 인수 또는 변수를 추가, 제거 또는 다시 정렬할 수 없습니다.</value>
  </data>
  <data name="CannotUpdateEnvironmentInTheMiddleOfResolvingVariables" xml:space="preserve">
    <value>인스턴스에서 변수를 확인하는 중에는 인수 또는 변수를 추가, 제거 또는 다시 정렬할 수 없습니다.</value>
  </data>
  <data name="CannotUpdateLoadedInstance" xml:space="preserve">
    <value>이미 로드되었으므로 WorkflowInstance '{0}'을(를) 업데이트할 수 없습니다. 업데이트하기 전에 인스턴스를 일시 중단해보십시오.</value>
  </data>
  <data name="CannotUseAddServiceEndpointOverloadForWorkflowServices" xml:space="preserve">
    <value>WorkflowServiceHost에서는 AddServiceEndpoint(ServiceEndpoint endpoint) 오버로드를 사용하여 응용 프로그램 끝점을 추가할 수 없습니다. WorkflowServiceHost에 응용 프로그램 끝점을 추가하려면 'XName serviceContractName' 또는 'string implementedContract' 오버로드 중 하나를 사용하십시오.</value>
  </data>
  <data name="CannotUseInputsWithLoad" xml:space="preserve">
    <value>워크플로 입력은 새 인스턴스에만 제공되므로 Load 또는 LoadRunnableInstance와 함께 사용할 수 없습니다.</value>
  </data>
  <data name="CannotValidateNullObject" xml:space="preserve">
    <value>이름이 '{1}'인 {0}의 ToValidate 인수가 null로 확인되었습니다. 유효성을 검사하려면 null이 아닌 개체를 제공해야 합니다.</value>
  </data>
  <data name="CannotWaitForIdleSynchronously" xml:space="preserve">
    <value>워크플로가 유휴 상태가 아닌데 처리기에서 작업을 호출하였으므로 작업이 실패했습니다. 작업을 완료하려면 워크플로가 유휴 상태여야 하며 이벤트 처리기에서는 워크플로를 실행할 수 없습니다.</value>
  </data>
  <data name="CanOnlyAbortDirectChildren" xml:space="preserve">
    <value>작업은 직계 자식만 중단할 수 있습니다.</value>
  </data>
  <data name="CanOnlyCancelDirectChildren" xml:space="preserve">
    <value>작업은 직계 자식만 취소할 수 있습니다.</value>
  </data>
  <data name="CanOnlyGetOwnedArguments" xml:space="preserve">
    <value>활동은 자신이 소유한 인수의 위치만 가져올 수 있습니다. '{0}' 활동에서 활동 '{2}'이(가) 소유한 '{1}' 인수의 위치를 가져오려고 합니다.</value>
  </data>
  <data name="CanOnlyScheduleDirectChildren" xml:space="preserve">
    <value>작업은 직계 자식만 예약할 수 있습니다. 작업 '{0}'이(가) 작업 '{2}'의 자식인 '{1}'을(를) 예약하려고 합니다.</value>
  </data>
  <data name="CantFindTimerExtension" xml:space="preserve">
    <value>Extensions 컬렉션에 TimerExtension을 추가해야 합니다.</value>
  </data>
  <data name="CatchOrFinallyExpected" xml:space="preserve">
    <value>TryCatch 작업 '{0}'에 Catch 또는 Finally가 필요합니다.</value>
  </data>
  <data name="ChangeConditionalTransitionToUnconditionalBlockDU" xml:space="preserve">
    <value>업데이트 후 조건부 전환이 비조건부 전환이 되는 경우 StateMachine은 동적 업데이트를 지원하지 않습니다.</value>
  </data>
  <data name="ChangeTransitionTypeDuringTransitioningBlockDU" xml:space="preserve">
    <value>상태가 전환 중이고 현재 전환이 조건부 전환이 되는 경우 StateMachine은 동적 업데이트를 지원하지 않습니다.</value>
  </data>
  <data name="ChangingTriggerOrUseOriginalConditionActionBlockDU" xml:space="preserve">
    <value>기존 전환의 Trigger가 수정되거나 Condition 또는 Action 작업이 새 전환에 다시 할당되는 경우 StateMachine은 동적 업데이트를 지원하지 않습니다.</value>
  </data>
  <data name="CleanupInProgress" xml:space="preserve">
    <value>현재 저장소를 정리하는 중이므로 SqlWorkflowInstanceStore에서 명령을 처리할 수 없습니다. 정리를 마칠 때까지 잠시 기다린 후 다시 시도하십시오.</value>
  </data>
  <data name="CollectionActivityRequiresCollection" xml:space="preserve">
    <value>'{0}'의 'Collection' 속성이 초기화되지 않았습니다.</value>
  </data>
  <data name="ColumnNumberTooLarge" xml:space="preserve">
    <value>{0} 작업에 대해 지정한 열 번호가 너무 커서 부분 신뢰에서 지원되지 않습니다.</value>
  </data>
  <data name="CommandExecutionCannotOverlap" xml:space="preserve">
    <value>InstanceHandle 하나에 대해 한 번에 한 명령만 실행할 수 있습니다. 이 InstanceHandle에 대해 실행 중인 명령이 완료되면 Execute 또는 BeginExecute 메서드를 호출하십시오.</value>
  </data>
  <data name="CompensableActivityAlreadyConfirmedOrCompensated" xml:space="preserve">
    <value>'Target' CompensationToken에 지정된 CompensableActivity가 이미 확인되었거나 보상되었습니다.</value>
  </data>
  <data name="CompensableActivityInsideTransactedReceiveScope" xml:space="preserve">
    <value>CompensableActivity는 TransactedReceiveScope 내부에 중첩될 수 없습니다.</value>
  </data>
  <data name="CompensableActivityInsideTransactionScopeActivity" xml:space="preserve">
    <value>CompensableActivity는 TransactionScope 작업 내부에 중첩될 수 없습니다.</value>
  </data>
  <data name="CompensateWithNoTargetConstraint" xml:space="preserve">
    <value>Compensation, Confirmation 또는 Cancellation 처리기에서 사용할 경우에만 Target을 지정하지 않고 Compensate를 사용할 수 있습니다.</value>
  </data>
  <data name="CompensateWithoutCompensableActivity" xml:space="preserve">
    <value>Compensate 작업 '{0}'은(는) 워크플로 내의 CompensableActivity가 이미 실행된 경우에만 사용할 수 없습니다.</value>
  </data>
  <data name="CompensationHandlerFatalException" xml:space="preserve">
    <value>'{0}'의 Compensation 처리기에서 처리되지 않은 예외가 발생했습니다. Compensation이 일관적이지 않은 상태일 수 있으며, 워크플로가 중단되었습니다.</value>
  </data>
  <data name="CompensationState" xml:space="preserve">
    <value>CompensableActivity '{0}'은(는) '{1}' 상태입니다.</value>
  </data>
  <data name="CompiledExpressionIdNotFound" xml:space="preserve">
    <value>'{0}'의 식 ID를 찾을 수 없습니다. 현재 정의가 컴파일되었는지 확인하십시오.</value>
  </data>
  <data name="CompiledExpressionsActivityException" xml:space="preserve">
    <value>TextExpressionCompiler: 작업 '{1}'을(를) 처리하는 동안 '{0}' 형식의 예외가 발생했습니다. '{2}'.</value>
  </data>
  <data name="CompiledExpressionsCacheMetadataException" xml:space="preserve">
    <value>작업 '{0}'에 대한 CacheMetadata에서 '{1}'이(가) 발생했습니다.</value>
  </data>
  <data name="CompiledExpressionsDuplicateName" xml:space="preserve">
    <value>'{0}'은(는) 모호한 변수 참조입니다. 식별자 이름을 바꾸십시오.</value>
  </data>
  <data name="CompiledExpressionsIgnoringInvalidIdentifierVariable" xml:space="preserve">
    <value>TextExpressionCompiler: 변수 '{0}'을(를) 무시하는 중입니다. 식별자가 현재 언어에 대해 올바르지 않습니다.</value>
  </data>
  <data name="CompiledExpressionsIgnoringUnnamedVariable" xml:space="preserve">
    <value>TextExpressionCompiler: 이름이 지정되지 않은 변수를 무시하는 중입니다.</value>
  </data>
  <data name="CompiledExpressionsNoCompiledRoot" xml:space="preserve">
    <value>작업 '{0}'에 해당하는 작업 인스턴스를 찾을 수 없습니다. 워크플로를 다시 컴파일하십시오.</value>
  </data>
  <data name="CompiledLocationNoDefaultConstructor" xml:space="preserve">
    <value>컴파일된 식에서는 해당 로컬 루트에 기본 생성자가 있어야 합니다. '{0}' 형식에 대한 기본 생성자를 추가하십시오.</value>
  </data>
  <data name="CompiledLocationReferenceGetLocation" xml:space="preserve">
    <value>CompiledLocationReference를 위치에 액세스하는 데 사용해서는 안됩니다.</value>
  </data>
  <data name="CompilerError" xml:space="preserve">
    <value>컴파일러 오류가 발생했습니다.</value>
  </data>
  <data name="CompilerErrorSpecificExpression" xml:space="preserve">
    <value>"{0}" 식을 처리하는 동안 컴파일러 오류가 발생했습니다.{1}</value>
  </data>
  <data name="CompileVbExpressionStart" xml:space="preserve">
    <value>VB 식 '{0}' 컴파일 중</value>
  </data>
  <data name="CompileVbExpressionStop" xml:space="preserve">
    <value>VB 식 컴파일이 완료되었습니다.</value>
  </data>
  <data name="CompleteBookmarkWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 BookmarkWorkItem이 완료되었습니다. BookmarkName: {3}, BookmarkScope: {4}.</value>
  </data>
  <data name="CompleteCancelActivityWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 CancelActivityWorkItem이 완료되었습니다.</value>
  </data>
  <data name="CompleteCompletionWorkItem" xml:space="preserve">
    <value>부모 작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 CompletionWorkItem이 완료되었습니다. 작업 '{3}', DisplayName: '{4}', InstanceId: '{5}'이(가) 완료되었습니다.</value>
  </data>
  <data name="CompletedMustNotHaveAssociatedKeys" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 완료되지 않은 키가 연결된 InstanceState.Completed 인스턴스를 로드한다고 보고했습니다.</value>
  </data>
  <data name="CompleteExecuteActivityWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 ExecuteActivityWorkItem이 완료되었습니다.</value>
  </data>
  <data name="CompleteFaultWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 FaultWorkItem이 완료되었습니다. 작업 '{3}', DisplayName: '{4}', InstanceId: '{5}'에서 예외가 전파되었습니다.</value>
  </data>
  <data name="CompleteRuntimeWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 런타임 작업 항목이 완료되었습니다.</value>
  </data>
  <data name="CompleteTransactionContextWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 TransactionContextWorkItem이 완료되었습니다.</value>
  </data>
  <data name="CompletionConditionSetButNoBody" xml:space="preserve">
    <value>ParallelForEach에서 CompletionCondition 속성은 null이 아닌데 Body 속성은 null일 수 없습니다. ParallelForEach '{0}'의 Body 속성을 빈 Sequence 작업으로 설정하십시오.</value>
  </data>
  <data name="ConfirmationHandlerFatalException" xml:space="preserve">
    <value>'{0}'의 Confirmation 처리기에서 처리되지 않은 예외가 발생했습니다. Confirmation이 일관적이지 않은 상태일 수 있으며, 워크플로가 중단되었습니다.</value>
  </data>
  <data name="ConfirmWithNoTargetConstraint" xml:space="preserve">
    <value>Compensation, Confirmation 또는 Cancellation 처리기에서 사용할 경우에만 Target을 지정하지 않고 Confirm을 사용할 수 있습니다.</value>
  </data>
  <data name="ConfirmWithoutCompensableActivity" xml:space="preserve">
    <value>Confirm 작업 '{0}'은(는) 워크플로 내의 CompensableActivity가 이미 실행된 경우에만 사용할 수 없습니다.</value>
  </data>
  <data name="ConflictingValueName" xml:space="preserve">
    <value>DurableInstanceManager.AddInstanceOwnerValues에 대해 제공된 값의 속성 이름 '{0}'(XName)이(가) 이미 추가된 값의 이름과 충돌합니다. AddInstanceOwnerValues에 전달된 모든 값의 이름이 고유한지 확인하십시오. 이 오류는 구성된 서비스 동작이 충돌할 경우 발생할 수 있습니다.</value>
  </data>
  <data name="ConnectionStringNameWrong" xml:space="preserve">
    <value>연결 이름 '{0}'에 대한 연결 문자열을 찾을 수 없습니다.</value>
  </data>
  <data name="ConstructorInfoNotFound" xml:space="preserve">
    <value>'{0}' 형식의 해당 생성자 정보가 없습니다.</value>
  </data>
  <data name="ConstVariableCannotBeSet" xml:space="preserve">
    <value>이 위치는 const로 표시되어 있으므로 해당 값을 수정할 수 없습니다.</value>
  </data>
  <data name="ContextAlreadyBoundToInstance" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 BindInstance를 호출하여 이미 인스턴스에 바인딩되어 있는 InstanceHandle의 인스턴스 ID를 설정했습니다. InstanceHandle은 수명 주기 동안 한 인스턴스에만 바인딩될 수 있습니다.</value>
  </data>
  <data name="ContextAlreadyBoundToLock" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 BindAcquiredLock을 호출하여 이미 잠금에 바인딩되어 있는 InstanceHandle의 잠긴 인스턴스 버전을 설정했습니다. InstanceHandle은 수명 주기 동안 한 잠금에만 바인딩될 수 있습니다.</value>
  </data>
  <data name="ContextAlreadyBoundToOwner" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 BindOwner를 호출하여 이미 소유자에 바인딩되어 있는 InstanceHandle의 소유자를 설정했습니다. InstanceHandle은 수명 주기 동안 한 소유자에만 바인딩될 수 있습니다.</value>
  </data>
  <data name="ContextMismatchInContextAndCallBackContext" xml:space="preserve">
    <value>CorrelationCallbackContext 및 CorrelationContext가 모두 설정되어 있지만 컨텍스트가 일치하지 않습니다.</value>
  </data>
  <data name="ContextMustBeBoundToInstance" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. InstanceHandle을 인스턴스 잠금 버전에 바인딩하기 위해 BindAcquiredLock, BindReclaimedLock, BeginBindReclaimedLock 또는 CreateBindReclaimedLockException을 호출했지만 InstanceHandle은 인스턴스에 바인딩되어 있지 않습니다. InstanceHandle을 잠금에 바인딩하려면 먼저 인스턴스에 바인딩해야 합니다.</value>
  </data>
  <data name="ContextMustBeBoundToOwner" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. InstanceHandle을 인스턴스 잠금 버전에 바인딩하기 위해 BindAcquiredLock, BindReclaimedLock, BeginBindReclaimedLock, or CreateBindReclaimedLockException을 호출했지만 InstanceHandle은 소유자에 바인딩되어 있지 않습니다. InstanceHandle을 잠금에 바인딩하려면 먼저 소유자에 바인딩해야 합니다.</value>
  </data>
  <data name="ContextNotFromThisStore" xml:space="preserve">
    <value>InstanceStore.Execute 또는 InstanceStore.BeginExecute에 대한 핸들 인수는 동일한 InstanceStore 인스턴스의 CreateInstanceHandle 호출에서 생성되어야 합니다.</value>
  </data>
  <data name="ContractInferenceValidationForTransactionFlowBehavior" xml:space="preserve">
    <value>작업의 TransactionFlow 동작을 Allowed로 설정해야 합니다.</value>
  </data>
  <data name="ContractNotFoundInAddServiceEndpoint" xml:space="preserve">
    <value>Name='{0}'이고 Namespace='{1}'인 ContractDescription을 찾을 수 없으므로 끝점을 추가할 수 없습니다.</value>
  </data>
  <data name="ControllerInvalidBeforeInitialize" xml:space="preserve">
    <value>WorkflowInstance.Controller는 Initialize가 호출된 후에만 유효합니다 .</value>
  </data>
  <data name="ConvertVariableToValueExpressionFailed" xml:space="preserve">
    <value>'{0}' 형식의 Variable을 '{1}' 형식의 Activity로 변환할 수 없습니다.</value>
  </data>
  <data name="CopyToIndexOutOfRange" xml:space="preserve">
    <value>배열 인덱스는 0보다 커야 합니다.</value>
  </data>
  <data name="CopyToNotEnoughSpaceInArray" xml:space="preserve">
    <value>제공된 배열은 값을 보유할 수 있는 공간이 없습니다.</value>
  </data>
  <data name="CopyToRankMustBeOne" xml:space="preserve">
    <value>제공된 배열은 다중 차원을 포함합니다. 배열은 CopyTo에서 사용되는 1차수여야 합니다.</value>
  </data>
  <data name="CorrelatedContextRequiredForAnonymousSend" xml:space="preserve">
    <value>보내기 작업은 Endpoint로 구성되거나 CorrelatesWith를 사용하여 이전에 설정된 컨텍스트로 상관 관계를 지정해야 합니다.</value>
  </data>
  <data name="CorrelationHandleInUse" xml:space="preserve">
    <value>CorrelationHandle이 BookmarkScope '{0}'에 이미 사용되고 있으므로 BookmarkScope '{1}'에 사용할 수 없습니다.</value>
  </data>
  <data name="CorrelationResponseContextShouldNotBeNull" xml:space="preserve">
    <value>CorrelationResponse 컨텍스트는 null일 수 없습니다. 이는 상관 관계 핸들이 올바르게 설정되지 않았기 때문일 수 있습니다.</value>
  </data>
  <data name="CouldNotResolveNamespacePrefix" xml:space="preserve">
    <value>네임스페이스 접두사 '{0}'을(를) 확인할 수 없습니다.</value>
  </data>
  <data name="CreateBookmark" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 책갈피가 생성되었습니다. BookmarkName: {3}, BookmarkScope: {4}.</value>
  </data>
  <data name="CreateBookmarkScope" xml:space="preserve">
    <value>BookmarkScope {0}이(가) 만들어졌습니다.</value>
  </data>
  <data name="CreateBookmarkScopeFailed" xml:space="preserve">
    <value>이 BookmarkScopeHandle은 이미 BookmarkScope와 연관되어 있습니다.</value>
  </data>
  <data name="CreateWorkflowServiceHostStart" xml:space="preserve">
    <value>CreateWorkflowServiceHost 시작</value>
  </data>
  <data name="CreateWorkflowServiceHostStop" xml:space="preserve">
    <value>CreateWorkflowServiceHost 중지</value>
  </data>
  <data name="CSharpExpressionsMustBeCompiled" xml:space="preserve">
    <value>CSharp 식을 컴파일해야 합니다.</value>
  </data>
  <data name="CurrentOperationCannotCreateInstance" xml:space="preserve">
    <value>서비스의 들어오는 메시지에 연결된 컨텍스트가 없고 현재 작업이 "CanCreateInstance = true"로 표시되어 있지 않습니다. 이 서비스와 통신하려면 들어오는 바인딩에서 컨텍스트 프로토콜을 지원하는지와 올바른 컨텍스트가 초기화되었는지를 확인하십시오.</value>
  </data>
  <data name="DanglingReceive" xml:space="preserve">
    <value>워크플로에 SendReply와 쌍을 이루는 Receive가 없습니다. 각 SendReply 작업이 워크플로에 있는 Receive 작업과 쌍을 이루는지 확인하십시오.</value>
  </data>
  <data name="DatabaseUpgradeRequiredForCommand" xml:space="preserve">
    <value>SqlWorkflowInstanceStore의 데이터베이스 버전이 '{0}'입니다. InstancePersistenceCommand '{1}'을(를) 이 데이터베이스 버전에 대해 실행할 수 없습니다. 데이터베이스를 '{2}'(으)로 업그레이드하십시오.</value>
  </data>
  <data name="DebugInfoCannotEvaluateExpression" xml:space="preserve">
    <value>현재 컨텍스트에서 '{0}'을(를) 평가할 수 없습니다.</value>
  </data>
  <data name="DebugInfoExceptionCaught" xml:space="preserve">
    <value>{0}을(를) 평가하는 동안 예외가 발생했습니다. {1}.</value>
  </data>
  <data name="DebugInfoNotSkipArgumentResolution" xml:space="preserve">
    <value>*** 값이 SkipArgumentResolution이 아님 ***</value>
  </data>
  <data name="DebugInfoTryGetValueFailed" xml:space="preserve">
    <value>*** TryGetValue 실패 ***</value>
  </data>
  <data name="DebugInstrumentationFailed" xml:space="preserve">
    <value>디버거를 계측하지 못했습니다. 이유: {0}.</value>
  </data>
  <data name="DebugSymbolChecksumValueInvalid" xml:space="preserve">
    <value>디버그 기호에 대해 지정한 체크섬이 부분 신뢰에서 유효하지 않습니다.</value>
  </data>
  <data name="DefaultAbortReason" xml:space="preserve">
    <value>워크플로가 중단되었습니다.</value>
  </data>
  <data name="DefaultCancelationRequiresCancelHasBeenRequested" xml:space="preserve">
    <value>기본 취소 논리를 수행하려면 HasCancelBeenRequested가 true여야 합니다. NativeActivity의 Cancel 메서드는 런타임에만 호출해야 합니다.</value>
  </data>
  <data name="DefaultCreateOnlyReason" xml:space="preserve">
    <value>WorkflowCreationContext.CreateOnly를 true로 설정하고 만든 워크플로입니다.</value>
  </data>
  <data name="DefaultInvalidWorkflowExceptionMessage" xml:space="preserve">
    <value>워크플로 정의의 구조가 잘못되었습니다. 모든 위반 사항을 보려면 ActivityValidationServices를 사용하십시오.</value>
  </data>
  <data name="DefaultSuspendReason" xml:space="preserve">
    <value>제어 끝점을 통해 워크플로가 일시 중단되었습니다.</value>
  </data>
  <data name="DefaultTerminationReason" xml:space="preserve">
    <value>워크플로를 종료하도록 요청했습니다.</value>
  </data>
  <data name="DefaultWorkflowApplicationExceptionMessage" xml:space="preserve">
    <value>WorkflowApplication의 현재 상태에서는 허용되지 않으므로 작업을 수행할 수 없습니다.</value>
  </data>
  <data name="DelegateArgumentAlreadyInUseOnActivity" xml:space="preserve">
    <value>DelegateArgument '{0}'은(는) '{2}' 작업에서 이미 사용 중이므로 '{1}' 작업에서 사용할 수 없습니다.</value>
  </data>
  <data name="DelegateArgumentChangeBlockDU" xml:space="preserve">
    <value>이 작업은 인수가 변경된 ActivityDelegate의 처리기입니다.</value>
  </data>
  <data name="DelegateArgumentDoesNotExist" xml:space="preserve">
    <value>DelegateArgument '{0}'은(는) 이 환경에 존재하지 않습니다.</value>
  </data>
  <data name="DelegateArgumentMustBeReferenced" xml:space="preserve">
    <value>DelegateArgument '{0}'을(를) 사용하려면 먼저 특정 작업의 ActivityDelegate에 포함되어야 합니다.</value>
  </data>
  <data name="DelegateArgumentMustBeSet" xml:space="preserve">
    <value>CacheMetadata를 호출하기 전에 DelegateArgument를 설정해야 합니다.</value>
  </data>
  <data name="DelegateArgumentNotVisible" xml:space="preserve">
    <value>참조된 DelegateArgument 개체('{0}')가 이 범위에서 표시되지 않습니다.</value>
  </data>
  <data name="DelegateArgumentTypeInvalid" xml:space="preserve">
    <value>호환되지 않는 '{2}' 형식이므로 DelegateArgument '{0}'은(는) '{1}' 형식의 식에서 사용할 수 없습니다.</value>
  </data>
  <data name="DelegateHandlersCannotBeScheduledDirectly" xml:space="preserve">
    <value>작업 '{0}'에서 ActivityDelegate 처리기 작업 '{1}'을(를) 직접 예약하려고 했습니다. ActivityDelegate 처리기는 직접 예약할 수 없습니다. 대신 ActivityDelegate 자체를 예약하여 실행해야 합니다.</value>
  </data>
  <data name="DelegateInArgumentTypeMismatch" xml:space="preserve">
    <value>이름이 '{0}'인 대리자 입력에 대해 제공된 인수의 형식이 잘못되었습니다. 대리자 입력의 형식은 '{1}'이고 인수 형식은 '{2}'입니다. 인수의 형식을 대리자 입력 형식으로 강제 변환할 수 있어야 합니다.</value>
  </data>
  <data name="DelegateOutArgumentTypeMismatch" xml:space="preserve">
    <value>이름이 '{0}'인 대리자 출력에 대해 제공된 인수의 형식이 잘못되었습니다. 대리자 출력의 형식은 '{1}'이고 인수 형식은 '{2}'입니다. 대리자 출력의 형식을 인수 형식으로 강제 변환할 수 있어야 합니다.</value>
  </data>
  <data name="DelegateParameterCannotBeModifiedAfterOpen" xml:space="preserve">
    <value>ActivityDelegateParameter '{0}'은(는) 수정할 수 없습니다. 해당 ActivityDelegateParameter를 사용하는 ActivityDelegate가 잠겨 있습니다. ActivityDelegate는 소유하고 있는 WorkflowElement에서 Invoke가 호출되거나 WorkflowElement에서 WorkflowInstance가 생성될 때 잠깁니다.</value>
  </data>
  <data name="DelegateParameterDirectionalityMismatch" xml:space="preserve">
    <value>DelegateParameters 사전에서 작업 대리자 매개 변수 '{0}'의 방향이 '{1}'입니다. 필요한 방향은 '{2}'입니다.</value>
  </data>
  <data name="DictionaryIsReadOnly" xml:space="preserve">
    <value>이 사전은 읽기 전용이고 수정할 수 없습니다.</value>
  </data>
  <data name="DifferentContractsSameConfigName" xml:space="preserve">
    <value>서로 다른 두 연락처에 같은 ConfigurationName이 있습니다.</value>
  </data>
  <data name="DifferentWorkflowServiceNameNotSupported" xml:space="preserve">
    <value>추가 버전의 WorkflowService 이름 {0}이(가) 기본 WorkflowService의 이름 {1}과(와) 일치하지 않습니다.</value>
  </data>
  <data name="DirectLambdaParameterReference" xml:space="preserve">
    <value>직접 람다 매개 변수 참조를 사용하는 식은 직렬화할 수 없습니다. 변수 참조 형식이 잘못된 것 같습니다.</value>
  </data>
  <data name="DirectoryAborted" xml:space="preserve">
    <value>로드된 인스턴스의 디렉터리가 삭제되었습니다. 서비스를 비상 종료하고 있습니다.</value>
  </data>
  <data name="DispatchOperationInInvalidState" xml:space="preserve">
    <value>DispatchOperation 인스턴스가 잘못된 상태에 있으므로 WorkflowOperationBehavior는 디스패치 동작을 적용할 수 없습니다.</value>
  </data>
  <data name="DoNotCompleteTryCommandWithPendingReclaim" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 잠금을 다시 얻기 위해 노력하는 동안 TryCommand 요청 처리를 완료했습니다. TryCommand에서 값을 반환하거나 예외를 발생시키지 않는 지속성 공급자를 사용하거나, BeginBindReclaimedLock에서 반환된 IAsyncResult가 완료되기 전에 BeginTryCommand에서 반환된 IAsyncResult를 완료하거나, CreateBindReclaimedLockException에서 반환된 예외가 발생하기 전에 완료하십시오.</value>
  </data>
  <data name="DoNotSupportArrayIndexerOnNonArrayType" xml:space="preserve">
    <value>{0} 형식의 ArrayIndexer는 배열 형식이 아니므로 지원되지 않습니다.</value>
  </data>
  <data name="DoNotSupportArrayIndexerReferenceWithDifferentArrayTypeAndResultType" xml:space="preserve">
    <value>배열 형식이 {0}이고 결과 형식이 {1}인 LValue는 두 형식이 같지 않으므로 ArrayIndexer에 대해 사용할 수 없습니다.</value>
  </data>
  <data name="DoNotSupportArrayIndexerValueWithIncompatibleArrayTypeAndResultType" xml:space="preserve">
    <value>{0}은(는) {1}과(와) 호환되지 않으므로 배열 항목 형식이 {0}이고 결과 형식이 {1}인 오른쪽 값은 ArrayIndexer에 대해 사용할 수 없습니다.</value>
  </data>
  <data name="DoNotSupportArrayIndexerWithDifferentArrayTypeAndResultType" xml:space="preserve">
    <value>배열 형식이 {0}이고 결과 형식이 {1}인 ArrayIndexer가 다르므로 지원되지 않습니다.</value>
  </data>
  <data name="DoNotSupportArrayIndexerWithNonIntIndex" xml:space="preserve">
    <value>인덱스 형식이 {0}인 ArrayIndexer는 int가 아니므로 지원되지 않습니다.</value>
  </data>
  <data name="DoWhileRequiresCondition" xml:space="preserve">
    <value>DoWhile 작업 '{0}'을(를) 사용하려면 먼저 조건을 설정해야 합니다.</value>
  </data>
  <data name="DUActivityTypeMismatch" xml:space="preserve">
    <value>이 작업에서 업데이트된 정의는 '{0}' 형식이지만, 원래 정의에서는 '{1}' 형식입니다.</value>
  </data>
  <data name="DUActivityTypeMismatchRuntime" xml:space="preserve">
    <value>이 작업의 형식이 업데이트 중 변경되었습니다.</value>
  </data>
  <data name="DUDisallowIfCannotFindingMatchingCondition" xml:space="preserve">
    <value>조건부 전환의 Trigger가 제거되거나 업데이트된 정의의 Condition 작업이 다른 속성에서 다시 할당되는 경우 StateMachine은 동적 업데이트를 지원하지 않습니다.</value>
  </data>
  <data name="DuplexContractsNotSupported" xml:space="preserve">
    <value>워크플로에서 이중 계약이 지원되지 않습니다. ServiceContractAttribute에서 CallbackContract 속성을 제거하십시오. </value>
  </data>
  <data name="DuplicateAnnotationName" xml:space="preserve">
    <value>이름이 '{0}'인 주석을 추가할 수 없습니다. 환경 변수 또는 주석 내 중복 이름에 대해 추적 프로필 쿼리를 확인하십시오. </value>
  </data>
  <data name="DuplicateCatchClause" xml:space="preserve">
    <value>{0} 형식에 대한 catch 절이 이미 있습니다. 고유한 각 CLR 예외 형식에 대해 하나의 catch 절만 추가할 수 있습니다.</value>
  </data>
  <data name="DuplicateCorrelationQuery" xml:space="preserve">
    <value>Where='{0}'인 중복 CorrelationQuery가 있습니다. 이 중복 쿼리는 상관 관계를 계산할 때 사용되지 않습니다.</value>
  </data>
  <data name="DuplicatedContract" xml:space="preserve">
    <value>여러 구현된 계약 형식에 계약 '{0}' 및 작업 '{1}'이(가) 포함됩니다.</value>
  </data>
  <data name="DuplicateDefinitionIdentity" xml:space="preserve">
    <value>({0}) DefinitionIdentity가 포함된 WorkflowService가 이미 있습니다.</value>
  </data>
  <data name="DuplicateEvaluationOrderValues" xml:space="preserve">
    <value>'{0}' 작업은 평가 순서가 '{1}'(으)로 설정된 여러 런타임 인수를 포함합니다. 런타임 인수 평가 순서 값은 고유해야 합니다.</value>
  </data>
  <data name="DuplicateImportAttribute" xml:space="preserve">
    <value>DynamicActivity '{1}'의 속성 '{0}'에 두 개 이상의 ImportAttribute가 포함됩니다. 속성당 ImportAttribute가 하나만 허용됩니다.</value>
  </data>
  <data name="DuplicateInstanceKeyExists" xml:space="preserve">
    <value>값이 '{0}'인 인스턴스 키가 이미 있습니다. 동일한 CorrelationKey로 평가되는 MessageQuerySet가 여러 개 정의되어 있기 때문일 수 있습니다.</value>
  </data>
  <data name="DuplicateInstrumentation" xml:space="preserve">
    <value>{0}에 대한 중복 계측입니다. 디버거가 잘못된 위치에서 중단될 수 있습니다.</value>
  </data>
  <data name="DuplicateMethodFound" xml:space="preserve">
    <value>모호한 일치가 있습니다. '{0}'에 InvokeMethod '{3}'에 제공된 매개 변수 형식, 일반 형식 인수 및 일반 형식 제약 조건과 일치하는 이름이 '{2}'인 public {1} 메서드가 여러 개 있습니다.</value>
  </data>
  <data name="DuplicateOriginActivityActivity" xml:space="preserve">
    <value>동일한 원본 개체 '{0}'이(가) 작업 '{1}' 및 '{2}'에서 사용됩니다.</value>
  </data>
  <data name="DuplicateOriginActivityVariable" xml:space="preserve">
    <value>동일한 원본 개체 '{0}'이(가) 작업 '{1}' 및 변수 '{2}'에서 사용됩니다.</value>
  </data>
  <data name="DuplicateOriginVariableVariable" xml:space="preserve">
    <value>동일한 원본 개체 '{0}'이(가) 변수 '{1}' 및 '{2}'에서 사용됩니다.</value>
  </data>
  <data name="DurationIsNegative" xml:space="preserve">
    <value>Delay 작업 '{0}'에 있는 Duration 인수의 값이 음수입니다.</value>
  </data>
  <data name="DUTriggerOrConditionChangedDuringTransitioning" xml:space="preserve">
    <value>상태가 전환 중이고 현재 전환이 수정된 경우 StateMachine은 동적 업데이트를 지원하지 않습니다.</value>
  </data>
  <data name="DynamicActivityDuplicatePropertyDetected" xml:space="preserve">
    <value>'{0}' 속성이 이미 DynamicActivity.Properties 컬렉션에 있습니다.</value>
  </data>
  <data name="DynamicActivityMultipleExpressionLanguages" xml:space="preserve">
    <value>지정된 작업 정의에 컴파일이 필요한 식 작업의 여러 언어가 포함됩니다(검색된 언어: '{0}'). 정의당 컴파일이 필요한 언어가 하나만 허용됩니다. 컴파일이 필요한 모든 식 작업을 단일 언어로 변환하십시오.</value>
  </data>
  <data name="EmptyCorrelationQueryResults" xml:space="preserve">
    <value>상관 관계 쿼리에서 빈 결과 집합이 생성되었습니다. 끝점에 대해 상관 관계 쿼리가 올바르게 구성되었는지 확인하십시오.</value>
  </data>
  <data name="EmptyGuidOnDeserializedInstance" xml:space="preserve">
    <value>역직렬화된 인스턴스의 인스턴스 ID가 모두 0입니다(Guid.Empty). 직렬화된 인스턴스의 인스턴스 ID는 0 이외의 값이어야 합니다.</value>
  </data>
  <data name="EmptyIdReturnedFromHost" xml:space="preserve">
    <value>워크플로 호스트 형식 '{0}'에 대한 'Id' 속성 구현에서 모두 0인 인스턴스 ID가 반환되었습니다. WorkflowInstance의 구현에서는 Guid.Empty 이외의 인스턴스 ID를 반환해야 합니다.</value>
  </data>
  <data name="EndpointAddressNotSetInEndpoint" xml:space="preserve">
    <value>끝점, 구성 파일 또는 콜백 컨텍스트에서 EndpointAddress를 검색하지 못했습니다. OperationName='{0}'인 활동에 대해 끝점과 끝점 구성이 모두 설정되지 않았기 때문일 수 있습니다.</value>
  </data>
  <data name="EndpointIncorrectlySet" xml:space="preserve">
    <value>Endpoint 및 EndpointConfigurationName 속성이 모두 OperationName='{1}'인 '{0}' 작업에 설정되었습니다. 하지만 한 번에 하나만 설정할 수 있습니다.</value>
  </data>
  <data name="EndpointNotSet" xml:space="preserve">
    <value>OperationName='{1}'인 작업 '{0}'은 Endpoint 또는 EndpointConfigurationName 속성을 지정해야 합니다.</value>
  </data>
  <data name="EndSqlCommandExecute" xml:space="preserve">
    <value>SQL 명령 실행 종료: {0}</value>
  </data>
  <data name="EnlistedTransactionPropertiesRequireIsolationBlocks" xml:space="preserve">
    <value>enlistWorkflowState가 true로 설정된 TransactionProperty는 격리 블록 내에 추가해야 합니다.</value>
  </data>
  <data name="EnterNoPersistBlock" xml:space="preserve">
    <value>비지속성 블록으로 들어갑니다.</value>
  </data>
  <data name="EnumeratorNotStarted" xml:space="preserve">
    <value>열거가 시작되지 않았습니다. MoveNext를 호출하십시오.</value>
  </data>
  <data name="EnvironmentDisposed" xml:space="preserve">
    <value>LocationEnvironment는 전달된 조건 범위 내에서만 액세스할 수 있습니다.</value>
  </data>
  <data name="ErrorExtractingValuesForLambdaRewrite" xml:space="preserve">
    <value>메서드 호출 식 '{1}'에서 '{0}' 형식의 대상 개체를 추출하려는 동안 오류가 발생했습니다. '{0}' 형식의 개체를 판별하는 식이 런타임 컨텍스트를 요구해서는 안 됩니다. 오류: {2}</value>
  </data>
  <data name="ErrorsEncounteredWhileProcessingTree" xml:space="preserve">
    <value>워크플로 트리를 처리하는 중 다음 오류가 발생했습니다.</value>
  </data>
  <data name="ErrorTimeToPersistLessThanZero" xml:space="preserve">
    <value>TimeToPersist 값은 TimeSpan.Zero보다 크거나 같아야 합니다. 사용하지 않도록 설정하려면 TimeSpan.MaxValue와 같은 값을 지정하십시오.</value>
  </data>
  <data name="ErrorTimeToUnloadLessThanZero" xml:space="preserve">
    <value>TimeToUnload 값은 TimeSpan.Zero보다 크거나 같아야 합니다. 사용하지 않도록 설정하려면 TimeSpan.MaxValue와 같은 값을 지정하십시오.</value>
  </data>
  <data name="EtwAPIMaxStringCountExceeded" xml:space="preserve">
    <value>Etw WriteEvent에 전달된 문자열 인수 수가 최대 허용되는 한도인 {0}을(를) 초과했습니다.</value>
  </data>
  <data name="EtwMaxNumberArgumentsExceeded" xml:space="preserve">
    <value>Etw WriteEvent에 전달된 인수 수가 최대 허용되는 한도인 {0}을(를) 초과했습니다.</value>
  </data>
  <data name="EtwRegistrationFailed" xml:space="preserve">
    <value>Etw 등록이 오류 코드 {0}(으)로 인해 실패했습니다.</value>
  </data>
  <data name="EtwUnhandledException" xml:space="preserve">
    <value>처리되지 않은 예외가 발생했습니다. 예외 정보: {0}</value>
  </data>
  <data name="ExclusiveHandleRegisterBookmarkScopeFailed" xml:space="preserve">
    <value>RegisterBookmarkScope는 해당 ExclusiveHandle의 범위에 기존 책갈피가 없는 경우에만 호출할 수 있습니다.</value>
  </data>
  <data name="ExclusiveHandleReinitializeFailed" xml:space="preserve">
    <value>Reinitialize는 이 ExclusiveHandle에 등록된 기존 책갈피가 없는 경우에만 호출할 수 있습니다.</value>
  </data>
  <data name="ExecuteMustBeNested" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 중첩된 명령을 동시에 여러 개 실행하려고 했습니다. InstanceStore.TryCommand(또는 BeginTryCommand) 호출 각각에 대해 InstancePersistenceContext.Execute(또는 BeginExecute)를 한 번에 하나만 호출할 수 있습니다. 이 오류는 지속성 공급자 구현이 잘못되었음을 나타냅니다.</value>
  </data>
  <data name="ExecuteWorkItemStart" xml:space="preserve">
    <value>작업 항목 실행 시작</value>
  </data>
  <data name="ExecuteWorkItemStop" xml:space="preserve">
    <value>작업 항목 실행 중지</value>
  </data>
  <data name="ExecutionPropertyAlreadyDefined" xml:space="preserve">
    <value>이름이 '{0}'인 속성이 이 범위에서 이미 정의되었습니다. 현재 속성을 바꾸려면 먼저 해당 속성을 제거한 후 새 속성을 추가하십시오.</value>
  </data>
  <data name="ExitNoPersistBlock" xml:space="preserve">
    <value>비지속성 블록에서 나옵니다.</value>
  </data>
  <data name="ExpressionRequiredForConversion" xml:space="preserve">
    <value>변환하려면 식이 필요합니다.</value>
  </data>
  <data name="ExtensionsCannotBeModified" xml:space="preserve">
    <value>WorkflowInstance와 연결된 후에는 WorkflowInstanceExtensionsManager를 수정할 수 없습니다.</value>
  </data>
  <data name="ExtensionsCannotBeSetByIndex" xml:space="preserve">
    <value>확장 컬렉션은 인덱스별 확장 설정을 지원하지 않습니다. Add 또는 Remove 메서드를 사용하십시오.</value>
  </data>
  <data name="ExtensionTypeNotSupported" xml:space="preserve">
    <value>WorkflowServiceHost에서는 '{0}' 형식의 확장을 추가할 수 없습니다.</value>
  </data>
  <data name="ExternalLocationsGetOnly" xml:space="preserve">
    <value>설정하려는 위치는 SymbolResolver에서 가져온 것입니다. SymbolResolver 위치는 읽기 전용입니다.</value>
  </data>
  <data name="ExtraOverloadGroupPropertiesConfigured" xml:space="preserve">
    <value>오버로드 그룹 '{0}'이(가) 이미 구성되었습니다. 오버로드 그룹 '{2}'의 '{1}' 속성도 구성하는 경우 오류가 발생합니다.</value>
  </data>
  <data name="ExtraParameter" xml:space="preserve">
    <value>매개 변수 '{0}'이(가) 계약 '{2}'의 작업 '{1}'에 선언되지 않았습니다.</value>
  </data>
  <data name="ExtraReturnValue" xml:space="preserve">
    <value>계약에 반환 값이 없지만 작업에 반환 메시지가 포함되어 있습니다.</value>
  </data>
  <data name="FailedToCreateSecurityToken" xml:space="preserve">
    <value>보안 토큰 '{0}'을(를) 만들지 못했습니다.</value>
  </data>
  <data name="FailedToGetInstanceIdForControlOperation" xml:space="preserve">
    <value>이 제어 작업에 대한 메시지에서 인스턴스 ID를 가져오지 못했습니다. 계약 불일치 때문일 수 있습니다. 클라이언트 계약이 서비스 끝점 계약과 일치하는지 확인하십시오.</value>
  </data>
  <data name="FailedToGetWorkflowIdentityForControlOperation" xml:space="preserve">
    <value>이 제어 작업에 대한 메시지에서 WorkflowIdentity를 가져오지 못했습니다. 이 문제는 계약 불일치로 인해 발생했을 수 있습니다. 클라이언트 계약이 서비스 끝점 계약과 일치하는지 확인하십시오.</value>
  </data>
  <data name="FailedToInitializeRequestReplyCorrelationHandle" xml:space="preserve">
    <value>요청/회신 작업 '{0}'(으)로 구성된 Receive 작업에서 RequestReplyCorrelation 핸들을 초기화하지 못했습니다. 수신된 메시지의 CorrelationMessageProperty에 RequestReplyCorrelation이 있는 InstanceKey가 있어야 합니다.</value>
  </data>
  <data name="FailedToLoadBindingInControlEndpoint" xml:space="preserve">
    <value>표준 제어 끝점 '{2}'에 대한 바인딩 구성 '{1}'(으)로 '{0}' 바인딩을 로드하지 못했습니다.</value>
  </data>
  <data name="FailFastMessage" xml:space="preserve">
    <value>복구할 수 없는 오류가 발생했습니다. 오류와 관련된 다음 메시지가 진단용으로 제공됩니다. '{0}'.</value>
  </data>
  <data name="FaultContextNotFound" xml:space="preserve">
    <value>재발생 작업 '{0}'에서 TryCatch 작업으로 설정된 FaultContext를 찾을 수 없습니다. 이 문제를 해결하려면 실행 속성 컬렉션에서 FaultContext를 수정하거나 제거하지 마십시오.</value>
  </data>
  <data name="FaultTypeMismatch" xml:space="preserve">
    <value>지정된 오류 형식 '{0}'이(가) 계약 '{2}'의 작업 '{1}'에 대해 없습니다.</value>
  </data>
  <data name="FinalStateCannotHaveProperty" xml:space="preserve">
    <value>최종 상태 '{0}'에는 {1} 작업이 없어야 합니다.</value>
  </data>
  <data name="FinalStateCannotHaveTransition" xml:space="preserve">
    <value>최종 상태 '{0}'에는 송신 전환이 없어야 합니다.</value>
  </data>
  <data name="FirstParameterDoesnotMatchTheReturnValue" xml:space="preserve">
    <value>콘텐츠에 지정된 형식 '{0}'의 첫 번째 매개 변수가 계약 '{3}'의 작업 '{2}'에 대한 반환 값으로 지정된 형식 '{1}'과(와) 일치하지 않습니다.</value>
  </data>
  <data name="FlowchartContainsReferences" xml:space="preserve">
    <value>가져온 자식 작업에 대한 참조가 포함된 경우 순서도에서 동적 업데이트가 지원되지 않습니다.</value>
  </data>
  <data name="FlowchartContainsUnconnectedNodes" xml:space="preserve">
    <value>ValidateUnconnectedNodes가 True로 설정된 경우 순서도 '{0}'을(를) 사용하려면 먼저 모든 노드가 연결되어 있어야 합니다.</value>
  </data>
  <data name="FlowchartEmpty" xml:space="preserve">
    <value>Flowchart '{0}' - 노드 없이 실행되었습니다.</value>
  </data>
  <data name="FlowchartMissingStartNode" xml:space="preserve">
    <value>Flowchart '{0}'에 StartNode가 없습니다.</value>
  </data>
  <data name="FlowchartNextNull" xml:space="preserve">
    <value>Flowchart '{0}'/FlowStep - 다음 노드가 null입니다. Flowchart 실행이 종료됩니다.</value>
  </data>
  <data name="FlowchartStart" xml:space="preserve">
    <value>Flowchart '{0}' - 시작이 예약되었습니다.</value>
  </data>
  <data name="FlowchartSwitchCase" xml:space="preserve">
    <value>Flowchart '{0}'/FlowSwitch - Case '{1}'이(가) 선택되었습니다.</value>
  </data>
  <data name="FlowchartSwitchCaseNotFound" xml:space="preserve">
    <value>Flowchart '{0}'/FlowSwitch - Expression 결과와 일치하는 Case 작업 및 Default Case를 찾을 수 없습니다. Flowchart 실행이 종료됩니다.</value>
  </data>
  <data name="FlowchartSwitchDefault" xml:space="preserve">
    <value>Flowchart '{0}'/FlowSwitch - Default Case가 선택되었습니다.</value>
  </data>
  <data name="FlowDecisionRequiresCondition" xml:space="preserve">
    <value>Flowchart '{0}'의 FlowDecision을 사용하려면 먼저 조건을 설정해야 합니다.</value>
  </data>
  <data name="FlowedTransactionDifferentFromAmbient" xml:space="preserve">
    <value>트랜잭션의 흐름이 앰비언트 트랜잭션과 다릅니다.</value>
  </data>
  <data name="FlowNodeCannotBeShared" xml:space="preserve">
    <value>FlowNode는 여러 Flowchart에서 공유할 수 없습니다. FlowNode가 Flowchart '{0}'에 이미 있으므로 Flowchart '{1}'에서 사용될 수 없습니다.</value>
  </data>
  <data name="FlowNodeLockedForRuntime" xml:space="preserve">
    <value>Flowchart '{0}'의 FlowNode가 이미 열려 있으므로 수정할 수 없습니다. FlowNode는 디자인 타임에만 수정할 수 있습니다.</value>
  </data>
  <data name="FlowSwitchRequiresExpression" xml:space="preserve">
    <value>Flowchart '{0}'의 FlowSwitch를 사용하려면 먼저 식을 설정해야 합니다.</value>
  </data>
  <data name="ForEachRequiresNonNullValues" xml:space="preserve">
    <value>ForEach 작업 '{0}'을(를) 사용하려면 먼저 값을 null이 아닌 식에 바인딩해야 합니다.</value>
  </data>
  <data name="FoundProcessingError" xml:space="preserve">
    <value>명령 실패: {0}</value>
  </data>
  <data name="GeneratedAndProvidedMapConflict" xml:space="preserve">
    <value>제공된 구현 맵과 현재 업데이트 간에 이 작업에 대한 변경 사항이 충돌됩니다. 작업에서 원래 값을 두 맵에 모두 저장하려고 했습니다.</value>
  </data>
  <data name="GeneratedAndProvidedMapConflictRuntime" xml:space="preserve">
    <value>구현 업데이트와 대규모 워크플로 업데이트 간에 이 작업에 대한 변경 사항이 충돌됩니다. 작업에서 원래 값을 두 업데이트에 모두 저장하려고 했습니다.</value>
  </data>
  <data name="GenericInstanceCommand" xml:space="preserve">
    <value>이름이 {0}인 InstancePersistenceCommand 실행이 오류로 중단되었습니다.</value>
  </data>
  <data name="GenericInstanceCommandNull" xml:space="preserve">
    <value>InstancePersistenceCommand 실행이 오류로 중단되었습니다.</value>
  </data>
  <data name="GetLocationOnPublicAccessReference" xml:space="preserve">
    <value>CodeActivityPublicEnvironmentAccessor.TryGetAccessToPublicLocation이 생성되었기 때문에 이 공용 위치에서 작업 '{0}'(으)로 GetLocation을 호출할 수 없습니다. 값을 읽거나 쓰려면 ActivityContext.GetValue 또는 SetValue를 사용하십시오. 위치에 대한 직접 액세스를 얻으려면 CodeActivityPublicEnvironmentAccessor.TryGetReferenceToPublicLocation을 사용하여 선언하십시오.</value>
  </data>
  <data name="GetParameterTypeMismatch" xml:space="preserve">
    <value>이름이 {1}인 InstancePersistenceAction에서 요청된 인덱스 {0}에 있는 매개 변수가 잘못된 제네릭 형식 인수를 사용하여 요청되었습니다. GetParameter&lt;T&gt;를 호출하는 경우 T에 지정된 형식은 매개 변수의 문서화된 형식과 일치해야 합니다.</value>
  </data>
  <data name="GetRunnableRequiresOwner" xml:space="preserve">
    <value>이 메서드를 호출하기 전에 WorkflowApplication.CreateDefaultInstanceOwner를 호출하여 이 워크플로 호스트에 대해 지원되는 정의 ID를 지정하십시오.</value>
  </data>
  <data name="GuidCannotBeEmpty" xml:space="preserve">
    <value>인수는 0이 아닌 GUID여야 합니다.</value>
  </data>
  <data name="HandledException" xml:space="preserve">
    <value>예외를 처리하는 중입니다. 예외 정보: {0}</value>
  </data>
  <data name="HandledExceptionError" xml:space="preserve">
    <value>예외를 처리하는 중입니다. 예외 정보: {0}</value>
  </data>
  <data name="HandledExceptionVerbose" xml:space="preserve">
    <value>예외를 처리하는 중입니다. 예외 정보: {0}</value>
  </data>
  <data name="HandledExceptionWarning" xml:space="preserve">
    <value>예외를 처리하는 중입니다. 예외 정보: {0}</value>
  </data>
  <data name="HandleFreed" xml:space="preserve">
    <value>InstanceHandle이 잠겨 있지 않아 InstancePersistenceCommands 실행이 취소되었습니다.</value>
  </data>
  <data name="HandleFreedBeforeInitialized" xml:space="preserve">
    <value>InstanceHandle의 Free 메서드는 해당 핸들의 OnNewInstanceHandle이 실행되는 동안 호출되지 않을 수 있습니다.</value>
  </data>
  <data name="HandleFreedInDirectory" xml:space="preserve">
    <value>InstanceHandle이 잠겨 있지 않아 InstancePersistenceCommand 실행이 취소되었습니다.</value>
  </data>
  <data name="HandleInitializationContextDisposed" xml:space="preserve">
    <value>HandleInitializationContext는 전달된 함수 범위 내에서만 액세스할 수 있습니다.</value>
  </data>
  <data name="HandleNotInitialized" xml:space="preserve">
    <value>핸들이 초기화되지 않았습니다. 핸들은 런타임에 생성되고 초기화되어야 하며 핸들이 선언된 범위 내에서만 유효합니다.</value>
  </data>
  <data name="HasExecutingChildrenNoPersist" xml:space="preserve">
    <value>실행 중인 자식이 없을 경우 비지속성 블록만 설정할 수 있습니다.</value>
  </data>
  <data name="HostIdDoesNotMatchInstance" xml:space="preserve">
    <value>워크플로 호스트에서 제공된 인스턴스 ID {0}이(가) 직렬화된 인스턴스에 저장된 ID {1}과(와) 일치하지 않습니다. 호스트는 인스턴스를 직렬화할 때와 다른 ID를 사용하는 인스턴스는 역직렬화하지 않습니다.</value>
  </data>
  <data name="HostLockExpired" xml:space="preserve">
    <value>SqlWorkflowInstanceStore 잠금이 만료되었습니다. 이러한 문제는 SQL Server가 사용 중이거나 연결이 일시적으로 끊어진 경우 발생할 수 있습니다.</value>
  </data>
  <data name="HostLockNotFound" xml:space="preserve">
    <value>SqlWorkflowInstanceStore 잠금이 데이터베이스에 없습니다. 이러한 문제는 SQL Server가 사용 중이거나 연결이 일시적으로 끊어진 경우 발생할 수 있습니다.</value>
  </data>
  <data name="IdentityControlCharacter" xml:space="preserve">
    <value>WorkflowIdentity.Name 및 Package는 제어 문자(유니코드 문자 범주 Cc)를 포함할 수 없습니다.</value>
  </data>
  <data name="IdentityNameSemicolon" xml:space="preserve">
    <value>WorkflowIdentity.Name은 세미콜론 ';' 문자를 포함할 수 없습니다.</value>
  </data>
  <data name="IdentityNotSupportedWithActivation" xml:space="preserve">
    <value>SqlWorkflowInstanceStore에서는 DefinitionIdentities를 지정하는 InstanceOwners에 대한 활성화가 지원되지 않습니다.</value>
  </data>
  <data name="IdentityWhitespace" xml:space="preserve">
    <value>WorkflowIdentity.Name 및 Package는 선행 또는 후행 공백(유니코드 문자 범주 Zl, Zp 또는 Zs)을 포함할 수 없습니다.</value>
  </data>
  <data name="IdNotFoundInWorkflow" xml:space="preserve">
    <value>제공된 ID '{0}'을(를) 워크플로에서 찾을 수 없습니다. 워크플로에서 이동할 수 없는 하위 트리가 생성될 수도 있는 유효성 검사 오류가 있는지 확인하십시오.</value>
  </data>
  <data name="ImplementationVersionMismatch" xml:space="preserve">
    <value>로드된 작업 인스턴스의 ImplementationVersion('{0}')이 제공된 작업('{2}')의 ImplementationVersion('{1}')과 일치하지 않습니다. 인스턴스는 구현 맵을 적용하여 업데이트할 수 있습니다.</value>
  </data>
  <data name="InArgumentBound" xml:space="preserve">
    <value>작업 '{1}', DisplayName: '{2}', InstanceId: '{3}'에 대한 In Argument '{0}'이(가) 값: {4}에 바인딩되었습니다.</value>
  </data>
  <data name="IncompatibleArgumentType" xml:space="preserve">
    <value>잘못된 형식의 인수가 이 메서드에 전달되었습니다. 이 메서드에는 {0} 형식의 인수가 필요하지만 {1} 형식의 인수가 전달되었습니다.</value>
  </data>
  <data name="IncompatibleTypeForMultidimensionalArrayItemReference" xml:space="preserve">
    <value>제네릭 형식 '{0}'이(가) MultidimensionalArrayItemReference에 있는 Array 피연산자의 실제 항목 형식 '{1}'과(와) 호환되지 않습니다.</value>
  </data>
  <data name="IncorrectIndexForArgument" xml:space="preserve">
    <value>반환 인수의 인덱스가 '{0}' 컬렉션에서 올바르지 않습니다. 필요한 위치는 '{2}'인데 지정된 위치는 '{1}'입니다.</value>
  </data>
  <data name="IncorrectValueType" xml:space="preserve">
    <value>인스턴스 저장소에서 형식이 잘못된 값이 검색되었습니다. {0} 형식의 값이 필요하지만 {1} 형식의 값이 검색되었습니다.</value>
  </data>
  <data name="IndexOutOfBounds" xml:space="preserve">
    <value>인덱스 값 {0}이(가) 배열 길이인 {1}보다 크거나 같습니다.</value>
  </data>
  <data name="IndicesAreNeeded" xml:space="preserve">
    <value>{0} 작업 '{1}'에 적어도 하나의 인덱스 값을 제공해야 합니다.</value>
  </data>
  <data name="InferredContractDescription" xml:space="preserve">
    <value>Name='{0}'이고 Namespace='{1}'인 ContractDescription이 WorkflowService에서 유추되었습니다.</value>
  </data>
  <data name="InferredOperationDescription" xml:space="preserve">
    <value>계약 '{1}'에서 Name='{0}'인 OperationDescription이 WorkflowService에서 유추되었습니다. IsOneWay={2}</value>
  </data>
  <data name="InitializationIncomplete" xml:space="preserve">
    <value>작업 인스턴스의 초기화가 완료되지 않았습니다. 이 오류는 변수 기본값 또는 인수 식에 문제가 있을 때 발생하며 예외 처리기는 계속 실행을 허용합니다.</value>
  </data>
  <data name="InitializeCorrelationRequiresWorkflowServiceHost" xml:space="preserve">
    <value>작업 '{0}'은(는) WorkflowServiceHost에서 사용해야 합니다.</value>
  </data>
  <data name="InitialMetadataCannotBeDeleted" xml:space="preserve">
    <value>이름이 {0}인 지속성 값이 초기 메타데이터 값으로 제공되고 있으므로 InstanceValue.DeletedValue가 아닌 올바른 InstanceValue를 가져야 합니다.</value>
  </data>
  <data name="InitialStateCannotBeFinalState" xml:space="preserve">
    <value>초기 상태 '{0}'이(가) 최종 상태로도 설정되면 안 됩니다.</value>
  </data>
  <data name="InitialStateNotInStatesCollection" xml:space="preserve">
    <value>초기 상태 '{0}'은(은) 상태 시스템의 'States' 컬렉션에 추가되지 않아야 합니다.</value>
  </data>
  <data name="InlinedLocationReferenceOnlyAccessibleByOwner" xml:space="preserve">
    <value>이 공용 위치 참조는 '{1}' 작업에 대해서만 유효하므로 '{0}' 작업은 액세스할 수 없습니다. 공용 위치 참조를 확보한 작업만이 이를 사용할 수 있습니다.</value>
  </data>
  <data name="InputParametersCountMismatch" xml:space="preserve">
    <value>제공된 입력 매개 변수 개수 {0}이(가) 필요한 개수 {1}과(와) 일치하지 않습니다.</value>
  </data>
  <data name="InputParametersMissing" xml:space="preserve">
    <value>이름이 '{0}'인 입력 매개 변수가 필요하지만 없습니다.</value>
  </data>
  <data name="InputParametersTypeMismatch" xml:space="preserve">
    <value>이름이 '{1}'인 매개 변수에 '{0}' 형식의 입력 매개 변수 값이 필요합니다.</value>
  </data>
  <data name="InstanceCollisionDefault" xml:space="preserve">
    <value>인스턴스가 인스턴스 저장소에서 이미 지속되는 상태이기 때문에 InstancePersistenceCommand 실행이 중단되었습니다.</value>
  </data>
  <data name="InstanceCollisionSpecific" xml:space="preserve">
    <value>'{0}' 인스턴스가 인스턴스 저장소에서 이미 지속되는 상태이기 때문에 InstancePersistenceCommand 실행이 중단되었습니다.</value>
  </data>
  <data name="InstanceCompleteDefault" xml:space="preserve">
    <value>인스턴스가 이미 완료되었기 때문에 InstancePersistenceCommand 실행이 중단되었습니다.</value>
  </data>
  <data name="InstanceCompleteSpecific" xml:space="preserve">
    <value>'{0}' 인스턴스가 이미 완료되었기 때문에 InstancePersistenceCommand 실행이 중단되었습니다.</value>
  </data>
  <data name="InstanceHandleConflictDefault" xml:space="preserve">
    <value>다른 올바른 InstanceHandle이 인스턴스 잠금을 유지하고 있어 InstancePersistenceCommand 실행이 중단되었습니다. 다시 말해, 새로운 인스턴스 사본이 이미 로드된 상태입니다. 로드된 인스턴스 사본과 그에 연결된 InstanceHandle을 사용하거나 언로드해야 합니다.</value>
  </data>
  <data name="InstanceHandleConflictSpecific" xml:space="preserve">
    <value>다른 올바른 InstanceHandle이 '{0}' 인스턴스의 잠금을 유지하고 있어 InstancePersistenceCommand 실행이 중단되었습니다. 다시 말해, 새로운 인스턴스 사본이 이미 로드된 상태입니다. 로드된 인스턴스 사본과 그에 연결된 InstanceHandle을 사용하거나 언로드해야 합니다.</value>
  </data>
  <data name="InstanceKeyMetadataChangesNotSupported" xml:space="preserve">
    <value>SqlWorkflowInstanceStore에서는 이미 있는 키의 키 메타데이터를 수정할 수 없습니다.</value>
  </data>
  <data name="InstanceKeyRequiresValidGuid" xml:space="preserve">
    <value>Guid.Empty와 같이 값이 모두 0인 InstanceKey를 만들 수 없습니다. 값이 모두 0인 InstanceKey를 가져오려면 InstanceKey.InvalidKey를 사용하십시오.</value>
  </data>
  <data name="InstanceLockedUnderTransaction" xml:space="preserve">
    <value>식별자가 '{1}'인 서비스 인스턴스에서 제어 작업 '{0}'을 수행하지 못했습니다. 진행 중인 활성 트랜잭트 제어 작업이 있습니다.</value>
  </data>
  <data name="InstanceLockLostDefault" xml:space="preserve">
    <value>인스턴스의 잠금이 해제되었기 때문에 InstancePersistenceCommand 실행이 중단되었습니다. 이 오류는 메모리의 인스턴스 사본이 부실한 상태이고 InstanceHandle과 함께 삭제되어야 함을 나타냅니다.</value>
  </data>
  <data name="InstanceLockLostSpecific" xml:space="preserve">
    <value>'{0}' 인스턴스의 잠금이 해제되었기 때문에 InstancePersistenceCommand 실행이 중단되었습니다. 이 오류는 메모리의 인스턴스 사본이 부실한 상태이고 InstanceHandle과 함께 삭제되어야 함을 나타냅니다.</value>
  </data>
  <data name="InstanceLocksRecoveryError" xml:space="preserve">
    <value>다음 예외로 인해 인스턴스 잠금을 복구하지 못했습니다.</value>
  </data>
  <data name="InstanceMethodCallRequiresTargetObject" xml:space="preserve">
    <value>인스턴스 메서드 호출에서 대상 개체가 필요합니다.</value>
  </data>
  <data name="InstanceMustBePaused" xml:space="preserve">
    <value>이 작업을 수행하려면 인스턴스를 일시 중지해야 합니다.</value>
  </data>
  <data name="InstanceMustNotBePaused" xml:space="preserve">
    <value>이 작업을 수행하려면 인스턴스를 일시 중지하지 않아야 합니다.</value>
  </data>
  <data name="InstanceMustNotBeSuspended" xml:space="preserve">
    <value>인스턴스가 일시 중단된 상태이기 때문에 작업을 수행할 수 없습니다.</value>
  </data>
  <data name="InstanceNotReadyDefault" xml:space="preserve">
    <value>인스턴스가 아직 인스턴스 저장소에 대해 지속 상태가 아니기 때문에 InstancePersistenceCommand 실행이 중단되었습니다.</value>
  </data>
  <data name="InstanceNotReadySpecific" xml:space="preserve">
    <value>'{0}' 인스턴스가 아직 인스턴스 저장소에 대해 지속 상태가 아니기 때문에 InstancePersistenceCommand 실행이 중단되었습니다.</value>
  </data>
  <data name="InstanceOperationRequiresInstance" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 인스턴스가 필요한 작업을 수행한다고 보고했지만 작업에 바인딩된 인스턴스가 없습니다.</value>
  </data>
  <data name="InstanceOperationRequiresLock" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 인스턴스의 잠금을 유지해야 하는 작업을 수행한다고 보고했지만 잠금이 유지되어 있지 않습니다.</value>
  </data>
  <data name="InstanceOperationRequiresNotCompleted" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 인스턴스가 InstanceState.Completed 이외의 상태여야 하는 작업을 수행한다고 보고했지만 해당 인스턴스가 이 상태에 있습니다.</value>
  </data>
  <data name="InstanceOperationRequiresNotUninitialized" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 인스턴스가 InstanceState.Uninitialized 이외의 상태여야 하는 작업을 수행한다고 보고했지만 해당 인스턴스가 이 상태에 있습니다.</value>
  </data>
  <data name="InstanceOperationRequiresOwner" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 인스턴스 소유자가 필요한 작업을 수행한다고 보고했지만 작업에 바인딩된 소유자가 없습니다.</value>
  </data>
  <data name="InstanceOwnerDefault" xml:space="preserve">
    <value>인스턴스 소유자 등록이 잘못되었기 때문에 InstancePersistenceCommand 실행이 중단되었습니다. 이 오류는 이 소유자가 잠근 모든 인스턴스의 메모리 내 복사본이 부실한 상태이고 InstanceHandle과 함께 삭제해야 함을 나타냅니다. 일반적으로 이 오류는 호스트를 다시 시작하면 쉽게 해결됩니다.</value>
  </data>
  <data name="InstanceOwnerSpecific" xml:space="preserve">
    <value>소유자 ID '{0}'에 대한 인스턴스 소유자 등록이 잘못되었기 때문에 InstancePersistenceCommand 실행이 중단되었습니다. 이 오류는 이 소유자가 잠근 모든 인스턴스의 메모리 내 복사본이 부실한 상태이고 InstanceHandle과 함께 삭제해야 함을 나타냅니다. 일반적으로 이 오류는 호스트를 다시 시작하면 쉽게 해결됩니다.</value>
  </data>
  <data name="InstanceRequired" xml:space="preserve">
    <value>인스턴스 지속성 시스템에서 잘못된 InstancePersistenceCommand를 처리할 수 없습니다. 명령을 수행하려면 인스턴스가 필요하지만 InstanceHandle에 바인딩된 인스턴스가 없습니다.</value>
  </data>
  <data name="InstanceStoreBoundSameVersionTwice" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 같은 인스턴스에 대해 같은 버전의 잠금을 두 번 얻어서 커밋했다고 보고했습니다. 인스턴스의 잠금을 얻을 때마다 잠금 버전이 증가해야 합니다. 아니면 잠금 버전으로 항상 0을 보고해야 합니다. 이미 저절로 잠겨 있는 인스턴스를 잠그려고 하는 인스턴스 소유자의 시도를 감지한 공급자는 BindAcquiredLock 대신 BindReclaimedLock, BeginBindReclaimedLock 또는 CreateBeginBindReclaimedLockException을 호출해야 합니다.</value>
  </data>
  <data name="InstanceStoreDoesntMatchWorkflowApplication" xml:space="preserve">
    <value>인스턴스가 이 WorkflowApplication과 다른 InstanceStore로 구성되었습니다.</value>
  </data>
  <data name="InstanceStoreFailed" xml:space="preserve">
    <value>InstanceStore 구현으로 인해 InstancePersistenceException이 발생했습니다. InstancePersistenceException은 내부 예외입니다.</value>
  </data>
  <data name="InstanceStoreHasDefaultOwner" xml:space="preserve">
    <value>이 InstanceStore에 이미 DefaultInstanceOwner가 있습니다.</value>
  </data>
  <data name="InstanceStoreReadOnly" xml:space="preserve">
    <value>SqlWorkflowInstanceStore는 읽기 전용이므로 더 이상 구성할 수 없습니다. SqlWorkflowInstanceStore의 모든 구성은 첫번째 InstanceHandle을 생성하기 전에 수행해야 합니다.</value>
  </data>
  <data name="InstanceStoreRequiredToPersist" xml:space="preserve">
    <value>InstanceStore를 사용하여 구성한 WorkflowApplication만 유지하거나 언로드할 수 있습니다.</value>
  </data>
  <data name="InstanceSuspended" xml:space="preserve">
    <value>식별자가 '{1}'인 서비스 인스턴스가 현재 'Suspended' 상태입니다. 제어 작업 '{0}'을(를) 수행하지 못했습니다.</value>
  </data>
  <data name="InsufficientArraySize" xml:space="preserve">
    <value>배열 크기가 {0}이어서 작업 결과를 유지하는 데 충분하지 않습니다.</value>
  </data>
  <data name="InternalCacheMetadataStart" xml:space="preserve">
    <value>InternalCacheMetadata가 작업 '{0}'에서 시작되었습니다.</value>
  </data>
  <data name="InternalCacheMetadataStop" xml:space="preserve">
    <value>InternalCacheMetadata가 작업 '{0}'에서 중지되었습니다.</value>
  </data>
  <data name="InternalConstraintException" xml:space="preserve">
    <value>이름이 '{2}'인 {1} 형식의 작업에 대해 이름이 '{0}'인 제약 조건을 실행하는 동안 내부 제약 조건 예외가 발생했습니다. 예외: {3}</value>
  </data>
  <data name="InternalServerError" xml:space="preserve">
    <value>내부 오류로 인해 서버에서 요청을 처리할 수 없습니다. 오류에 대한 자세한 내용을 보려면 클라이언트에 예외 정보를 다시 보낼 수 있도록 서버에서 ServiceBehaviorAttribute 또는 &lt;serviceDebug&gt; 구성 동작의 IncludeExceptionDetailInFaults를 설정하거나 Microsoft .NET Framework 4.0 SDK 설명서마다 추적 기능을 설정하여 서버 추적 로그를 확인하십시오.</value>
  </data>
  <data name="InvalidActivityIdFormat" xml:space="preserve">
    <value>제공된 작업 ID의 형식이 잘못되었습니다. '1.12.3'과 같이 맨 앞과 맨 뒤에 점을 사용하지 않고, 점으로 구분된 정수 값 목록이어야 합니다.</value>
  </data>
  <data name="InvalidActivityToBlockUpdate" xml:space="preserve">
    <value>DynamicUpdateMapBuilder.DisallowUpdateInside의 작업 '{0}'이(가) DynamicUpdateMapBuilder.UpdatedWorkflowDefinition의 공용 멤버가 아닙니다. 이 작업이 업데이트된 워크플로 정의에 속하는지 확인하십시오. 이 작업이 업데이트 중에 제거된 경우 업데이트를 명시적으로 차단할 필요가 없습니다. 제거된 작업이 실행 중인 경우 업데이트가 자동으로 차단됩니다.</value>
  </data>
  <data name="InvalidActivityToBlockUpdateServices" xml:space="preserve">
    <value>작업 '{0}'이(가) updatedWorkflowDefinition의 공용 멤버가 아닙니다. 이 작업이 업데이트된 워크플로 정의에 속하는지 확인하십시오. 이 작업이 업데이트 중에 제거된 경우 업데이트를 명시적으로 차단할 필요가 없습니다. 제거된 작업이 실행 중인 경우 업데이트가 자동으로 차단됩니다.</value>
  </data>
  <data name="InvalidArgumentExpression" xml:space="preserve">
    <value>'{1}' 형식의 번호 {0} 인수 식이 잘못되었습니다.</value>
  </data>
  <data name="InvalidAsyncBeginMethodSignature" xml:space="preserve">
    <value>{1} 형식의 {0} 메서드에 대한 비동기 Begin 메서드 시그니처가 잘못되었습니다. Begin 메서드는 AsyncCallback과 개체를 마지막 두 인수로 사용하고 IAsyncResult를 반환해야 합니다.</value>
  </data>
  <data name="InvalidAsyncCancelMethodSignature" xml:space="preserve">
    <value>{1} 형식의 {0} 메서드에 대한 비동기 Cancel 메서드 시그니처가 잘못되었습니다. Cancel 메서드는 인수를 사용하지 않고 void를 반환해야 합니다.</value>
  </data>
  <data name="InvalidAsyncEndMethodSignature" xml:space="preserve">
    <value>{1} 형식의 {0} 메서드에 대한 비동기 End 메서드 시그니처가 잘못되었습니다. End 메서드는 IAsyncResult를 마지막 인수로 사용해야 합니다. </value>
  </data>
  <data name="InvalidAsyncResult" xml:space="preserve">
    <value>잘못된 IAsyncResult가 'End' 메서드에 제공되었습니다. 'End'에 전달된 IAsyncResult 개체는 일치하는 'Begin'으로부터 반환된 것이거나 'Begin'에 제공된 콜백으로 전달되어야 합니다.</value>
  </data>
  <data name="InvalidAsyncResultImplementation" xml:space="preserve">
    <value>IAsyncResult 인터페이스를 잘못 구현하면 CompletedSynchronously 속성에서 잘못된 값이 반환되거나 AsyncCallback가 두 번 이상 호출될 수 있습니다. 형식 '{0}'의 구현이 잘못되었을 수 있습니다.</value>
  </data>
  <data name="InvalidAsyncResultImplementationGeneric" xml:space="preserve">
    <value>IAsyncResult 인터페이스를 잘못 구현하면 CompletedSynchronously 속성에서 잘못된 값이 반환되거나 AsyncCallback가 두 번 이상 호출될 수 있습니다.</value>
  </data>
  <data name="InvalidCallbackState" xml:space="preserve">
    <value>콜백 상태 개체에 대해 올바른 {0} 데이터를 전달해야 합니다.</value>
  </data>
  <data name="InvalidCompensateActivityUsage" xml:space="preserve">
    <value>'Target' InArgument가 설정되지 않은 Compensate 작업 '{0}'은(는) Compensation/Confirmation/Cancellation 처리기의 컨텍스트 내에서만 사용할 수 있습니다.</value>
  </data>
  <data name="InvalidCompensationToken" xml:space="preserve">
    <value>'Target' InArgument에 바인딩된 Variable에 null 값이 있습니다. 'Target' InArgument는 CompensableActivity에서 가져온 올바른 CompensationToken을 사용하여 설정해야 합니다. 그렇지 않고 기본 Compensation/Confirmation을 사용하는 경우 'Target' InArgument를 설정하지 말고 Compensation/Confirmation/Cancellation 처리기 컨텍스트 내에서 '{0}' 작업을 사용하십시오.</value>
  </data>
  <data name="InvalidConfirmActivityUsage" xml:space="preserve">
    <value>'Target' InArgument가 설정되지 않은 Confirm 작업 '{0}'은(는) Compensation/Confirmation/Cancellation 처리기의 컨텍스트 내에서만 사용할 수 있습니다.</value>
  </data>
  <data name="InvalidDataFromReceiveBookmarkState" xml:space="preserve">
    <value>받기 작업 '{0}'에 대한 책갈피가 다시 시작될 때 올바른 MessageContext를 가져올 수 없습니다.</value>
  </data>
  <data name="InvalidDataFromSendBookmarkState" xml:space="preserve">
    <value>보내기 작업 '{0}'에 대한 책갈피가 다시 시작될 때 올바른 CorrelationMessageProperty나 오류를 가져올 수 없습니다.</value>
  </data>
  <data name="InvalidDirectionForArgument" xml:space="preserve">
    <value>'{0}' 컬렉션에서 {1} 위치의 인수에 대한 인수 방향이 잘못되었습니다. 필요한 방향은 '{3}'인데 지정된 방향은 '{2}'입니다.</value>
  </data>
  <data name="InvalidDynamicActivityProperty" xml:space="preserve">
    <value>이 속성 설명자가 잘못되었습니다. 제공된 구성 요소에 이 설명자({0})에 해당하는 속성이 없습니다.</value>
  </data>
  <data name="InvalidEvaluationOrderValue" xml:space="preserve">
    <value>EvaluationOrder 값이 잘못되었습니다. 평가 순서 값은 0부터 순차적으로 증가하는 고유 값이어야 합니다. 평가 순서를 설정하지 않으려면 -1을 사용하십시오.</value>
  </data>
  <data name="InvalidExecutionCallback" xml:space="preserve">
    <value>'{0}'은(는) 올바른 작업 실행 콜백이 아닙니다. '{1}'에 사용되는 실행 콜백은 '{1}'의 인스턴스 메서드여야 합니다.</value>
  </data>
  <data name="InvalidExpressionForLocation" xml:space="preserve">
    <value>Location은 형식이 '{0}'인 Expression에서 생성할 수 없습니다.</value>
  </data>
  <data name="InvalidExpressionProperty" xml:space="preserve">
    <value>형식이 '{0}'인 'Expression' 속성이 잘못되었습니다.</value>
  </data>
  <data name="InvalidFileName" xml:space="preserve">
    <value>{0} 작업에 대해 잘못된 fileName을 지정했습니다.</value>
  </data>
  <data name="InvalidGenericTypeInfo" xml:space="preserve">
    <value>'{0}' 형식에 잘못된 제네릭 형식 정보가 들어 있습니다.</value>
  </data>
  <data name="InvalidIdleAction" xml:space="preserve">
    <value>반환된 PersistableIdleAction이 범위를 벗어났습니다. None, Unload, Persist 중 하나여야 합니다.</value>
  </data>
  <data name="InvalidImplementationAsWorkflowRoot" xml:space="preserve">
    <value>구현 맵을 워크플로 인스턴스에 직접 적용하려면 정의 루트가 공용/가져온 자식 또는 공용/가져온 대리자를 포함해서는 안됩니다.</value>
  </data>
  <data name="InvalidImplementationAsWorkflowRootForRuntimeState" xml:space="preserve">
    <value>구현 맵을 워크플로 인스턴스에 직접 적용하려면 정의 루트가 공용 자식을 포함해서는 안됩니다. 인스턴스에 현재 실행 중인 공용 자식이 하나 이상 포함됩니다.</value>
  </data>
  <data name="InvalidImplementationAsWorkflowRootForRuntimeStateBecauseArgumentsChanged" xml:space="preserve">
    <value>구현 맵을 워크플로 인스턴스에 직접 적용하려면 구현 맵에 인수에 대한 변경 사항이 없는 것으로 표시되어야 합니다. 구현 맵에는 작업 정의의 인수가 변경된 것으로 표시됩니다.</value>
  </data>
  <data name="InvalidImplementationMap" xml:space="preserve">
    <value>제공된 구현 맵이 작업의 정의와 일치하지 않습니다. 업데이트된 워크플로에서 참조되는 작업의 버전이 제공된 맵에서 대상으로 지정된 것과 동일한 버전인지 확인하십시오.]D;]A;    ]D;]A;문제 해결 세부 정보: 맵의 멤버 수: '{0}', 정의의 멤버 수: '{1}'.</value>
  </data>
  <data name="InvalidImplementationMapAssociation" xml:space="preserve">
    <value>작업에 구현 자식이 포함되지 않기 때문에 DynamicUpdateMapBuilder.LookupImplementationMap을 통해 작업 '{0}'에 대해 제공된 구현 맵을 사용할 수 없습니다. 올바른 작업으로 SetImplementationMap이 호출되었는지 확인하십시오.</value>
  </data>
  <data name="InvalidImplementationMapAssociationServices" xml:space="preserve">
    <value>작업에 구현 자식이 포함되지 않기 때문에 DynamicUpdateServices.SetImplementationMap을 통해 작업 '{0}'에 대해 제공된 구현 맵을 사용할 수 없습니다. 올바른 작업으로 SetImplementationMap이 호출되었는지 확인하십시오.</value>
  </data>
  <data name="InvalidImplementationMapRuntime" xml:space="preserve">
    <value>업데이트 맵을 작성할 때 잘못된 구현 맵이 이 작업에 대해 제공되었습니다.</value>
  </data>
  <data name="InvalidInstanceId" xml:space="preserve">
    <value>값이 모두 0인 잘못된 인스턴스 ID(Guid.Empty)를 사용하여 인스턴스를 로드했습니다.</value>
  </data>
  <data name="InvalidInstanceState" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 InstanceState 값이 잘못된 인스턴스를 로드한다고 보고했습니다.</value>
  </data>
  <data name="InvalidKey" xml:space="preserve">
    <value>잘못된 키를 사용하여 인스턴스를 만들거나 로드했습니다.</value>
  </data>
  <data name="InvalidKeyArgument" xml:space="preserve">
    <value>Guid.Empty와 같이 모두 0인 잘못된 키가 인수로 전달되었습니다.</value>
  </data>
  <data name="InvalidLocationExpression" xml:space="preserve">
    <value>위치 식이 잘못되었습니다. "[...]5D;"가 필요합니다.</value>
  </data>
  <data name="InvalidLockRenewalPeriod" xml:space="preserve">
    <value>제공된 잠금 갱신 기간 {0}이(가) 최소 잠금 갱신 기간 {1}보다 작습니다.</value>
  </data>
  <data name="InvalidLockToken" xml:space="preserve">
    <value>InstancePersistenceContext.BindLock에 전달된 instanceVersion은 지속성 공급자가 잠금 버전 관리를 구현하면 0보다 커야 하고 그렇지 않으면 0이어야 합니다.</value>
  </data>
  <data name="InvalidLValueExpression" xml:space="preserve">
    <value>L-value 식이 잘못되었습니다.</value>
  </data>
  <data name="InvalidMergeMap" xml:space="preserve">
    <value>작업 ID '{1}'에 대한 위치 '{0}'(0 기준)의 맵이 선행하는 맵과 일치하지 않습니다. 모든 맵이 동일한 워크플로 정의에 대해 연속된 업데이트를 제공하는지 확인하십시오.]D;]A;    ]D;]A;문제 해결 세부 정보: {2}</value>
  </data>
  <data name="InvalidMergeMapArgumentCount" xml:space="preserve">
    <value>필요한 원래 인수 수 = '{0}', 실제 = '{1}'.</value>
  </data>
  <data name="InvalidMergeMapArgumentsChanged" xml:space="preserve">
    <value>인수(이름, 방향, 형식 또는 순서)에서 예기치 않은 변경 사항이 발생했습니다.</value>
  </data>
  <data name="InvalidMergeMapEnvironmentCount" xml:space="preserve">
    <value>필요한 원래 인수 수 = '{0}', 공용 변수 수 = '{1}', 전용 변수 수 = '{2}'. 실제 원래 인수 수 = '{3}', 공용 변수 수 = '{4}', 전용 변수 수 = '{5}'.</value>
  </data>
  <data name="InvalidMergeMapForImplementation" xml:space="preserve">
    <value>필요한 ForImplementation = '{0}', 실제 = '{1}'.</value>
  </data>
  <data name="InvalidMergeMapMemberCount" xml:space="preserve">
    <value>필요한 원래 멤버 수 = '{0}', 실제 = '{1}'.</value>
  </data>
  <data name="InvalidMetadataValue" xml:space="preserve">
    <value>메타데이터 속성 '{0}'에 지정된 값은 {1} 형식이어야 합니다.</value>
  </data>
  <data name="InvalidNullAsyncResult" xml:space="preserve">
    <value>null 값이 비동기 'Begin' 메서드에서 반환되었거나 AsyncCallback에 전달되었습니다. 비동기 'Begin' 구현은 null이 아닌 IAsyncResult를 반환해야 하며 AsyncCallback에 대한 매개 변수와 동일한 IAsyncResult 개체를 전달해야 합니다.</value>
  </data>
  <data name="InvalidOriginalWorkflowDefinitionForImplementationMapCreation" xml:space="preserve">
    <value>맵 작성기에 제공된 OriginalWorkflowDefinition은 구현 자식을 포함하지 않기 때문에 구현 맵에 대해 올바르지 않습니다.</value>
  </data>
  <data name="InvalidParameterInfo" xml:space="preserve">
    <value>'{1}' 형식의 번호 {0} 매개 변수 정보가 잘못되었습니다.</value>
  </data>
  <data name="InvalidPrepareForRuntimeValidationSettings" xml:space="preserve">
    <value>ValidationSettings에 SingleLevel, SkipValidatingRootConfiguration 또는 OnlyUseAdditionalConstraints 중 하나라도 설정된 경우 런타임을 위해 워크플로를 준비할 수 없습니다.</value>
  </data>
  <data name="InvalidProperty" xml:space="preserve">
    <value>속성({0})이 잘못되었거나 정의되지 않았습니다.</value>
  </data>
  <data name="InvalidPropertyType" xml:space="preserve">
    <value>'{1}' 속성의 '{0}' 형식을 확인할 수 없습니다.</value>
  </data>
  <data name="InvalidReceiveStateForDU" xml:space="preserve">
    <value>Receive가 인스턴스 업데이트가 지원되지 않는 상태입니다. Receive가 서버 쪽의 요청 메시지를 기다리는 동안에만 업데이트를 수행할 수 있습니다.</value>
  </data>
  <data name="InvalidRootMergeMap" xml:space="preserve">
    <value>위치 '{0}'(0 기준)의 루트 맵이 선행하는 맵과 일치하지 않습니다. 모든 맵이 동일한 워크플로 정의에 대해 연속된 업데이트를 제공하는지 확인하십시오.]D;]A;    ]D;]A;문제 해결 세부 정보: {1}</value>
  </data>
  <data name="InvalidRunnableInstancesDetectionPeriod" xml:space="preserve">
    <value>제공된 실행 가능한 인스턴스 검색 기간 {0}이(가) 최소 허용 기간 {1}보다 작습니다.</value>
  </data>
  <data name="InvalidRuntimeState" xml:space="preserve">
    <value>제공된 값이 올바른 런타임 상태가 아닙니다.</value>
  </data>
  <data name="InvalidSemaphoreExit" xml:space="preserve">
    <value>개체 동기화 메서드가 동기화되지 않은 코드 블록으로부터 호출되었습니다.</value>
  </data>
  <data name="InvalidServiceImplementation" xml:space="preserve">
    <value>WorkflowServiceHost에 제공되는 serviceImplementation은 Activity 또는 WorkflowService여야 합니다.</value>
  </data>
  <data name="InvalidSourceLocationColumn" xml:space="preserve">
    <value>열 번호는 0보다 커야 합니다(1부터 시작).  {0} = {1}은(는) 잘못되었습니다.</value>
  </data>
  <data name="InvalidSourceLocationLineNumber" xml:space="preserve">
    <value>줄 번호는 0보다 커야 합니다(1부터 시작).  {0} = {1}은(는) 잘못되었습니다.</value>
  </data>
  <data name="InvalidStateForAsyncCallback" xml:space="preserve">
    <value>비동기 콜백으로 전달된 IAsyncResult에 올바른 AsyncState가 없습니다.</value>
  </data>
  <data name="InvalidStateInAsyncResult" xml:space="preserve">
    <value>제공된 비동기 결과 상태 컨텍스트가 잘못되었습니다.</value>
  </data>
  <data name="InvalidTypeConverterUsage" xml:space="preserve">
    <value>TypeConverter 사용이 잘못되었습니다.</value>
  </data>
  <data name="InvalidTypeForArgument" xml:space="preserve">
    <value>'{0}' 컬렉션에서 {1} 위치의 인수에 지정된 형식이 필요한 형식과 일치하지 않습니다. 지정된 형식은 '{2}'이고 필요한 형식은 '{3}'입니다.</value>
  </data>
  <data name="InvalidUnhandledExceptionAction" xml:space="preserve">
    <value>반환된 UnhandledExceptionAction이 범위를 벗어났습니다. Abort, Cancel, Terminate 중 하나여야 합니다.</value>
  </data>
  <data name="InvalidUpdatedWorkflowDefinitionForImplementationMapCreation" xml:space="preserve">
    <value>맵 작성기에 제공된 UpdatedWorkflowDefinition은 구현 자식을 포함하지 않기 때문에 구현 맵에 대해 올바르지 않습니다.</value>
  </data>
  <data name="InvalidUpdateMap" xml:space="preserve">
    <value>업데이트 맵이 워크플로 정의와 일치하지 않습니다. 이 정의에 대한 올바른 맵인지, 그리고 직렬화된 맵이 수동으로 변경되지 않았는지 확인하십시오.]D;]A;    ]D;]A;문제 해결 세부 정보: {0}</value>
  </data>
  <data name="InvalidVisualBasicSettingsValue" xml:space="preserve">
    <value>Settings 속성의 값이 잘못되었습니다. Settings 속성을 빈 문자열 또는 "XML 네임스페이스로 serialization된 가져온 네임스페이스 및 어셈블리 참조" 문자열로 설정하십시오.</value>
  </data>
  <data name="InvalidXamlMember" xml:space="preserve">
    <value>'{0}'은(는) XAML에서 올바른 식별자가 아닙니다.</value>
  </data>
  <data name="InvokedMethodThrewException" xml:space="preserve">
    <value>작업 '{0}'(으)로 호출된 메서드에서 예외가 발생했습니다. {1}</value>
  </data>
  <data name="InvokeMethodDoesNotUseAsyncPattern" xml:space="preserve">
    <value>InvokeMethod '{0}' - 메서드에서 비동기 패턴을 사용하지 않습니다.</value>
  </data>
  <data name="InvokeMethodIsNotStatic" xml:space="preserve">
    <value>InvokeMethod '{0}' - 메서드가 Static이 아닙니다.</value>
  </data>
  <data name="InvokeMethodIsStatic" xml:space="preserve">
    <value>InvokeMethod '{0}' - 메서드가 Static입니다.</value>
  </data>
  <data name="InvokeMethodUseAsyncPattern" xml:space="preserve">
    <value>InvokeMethod '{0}' - 메서드에서 '{1}' 및 '{2}'의 비동기 패턴을 사용합니다.</value>
  </data>
  <data name="IsolationLevelValidation" xml:space="preserve">
    <value>중첩된 TransactionScope 작업의 IsolationLevel은 해당 부모의 수준과 같아야 합니다.</value>
  </data>
  <data name="ITextExpressionParameterMustBeActivity" xml:space="preserve">
    <value>'expression' 매개 변수는 작업 형식이어야 합니다.</value>
  </data>
  <data name="KeyAlreadyAssociated" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 키가 이미 연결되어 있는 인스턴스에 키를 연결한다고 보고했습니다.</value>
  </data>
  <data name="KeyAlreadyCompleted" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 이미 완료된 키를 완료한다고 보고했습니다.</value>
  </data>
  <data name="KeyAlreadyUnassociated" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 현재 인스턴스에 연결되어 있으나 완료되지 않은 키의 연결을 끊는다고 보고했습니다.</value>
  </data>
  <data name="KeyCollectionUpdatesNotAllowed" xml:space="preserve">
    <value>사전에서 파생된 키 컬렉션은 변경할 수 없습니다.</value>
  </data>
  <data name="KeyCollisionDefault" xml:space="preserve">
    <value>키 충돌로 인해 InstancePersistenceCommand 실행이 중단되었습니다.</value>
  </data>
  <data name="KeyCollisionSpecific" xml:space="preserve">
    <value>키 충돌로 인해 InstancePersistenceCommand 실행이 중단되었습니다. 이미 다른 '{2}' 인스턴스와 연관되어 있으므로 값이 '{1}'인 인스턴스 키를 '{0}' 인스턴스와 연관시킬 수 없습니다.</value>
  </data>
  <data name="KeyCollisionSpecificKeyOnly" xml:space="preserve">
    <value>키 충돌로 인해 InstancePersistenceCommand 실행이 중단되었습니다. 이미 다른 인스턴스와 연관되어 있으므로 값이 '{0}'인 인스턴스 키를 이 인스턴스와 연관시킬 수 없습니다.</value>
  </data>
  <data name="KeyCompleteDefault" xml:space="preserve">
    <value>인스턴스 키가 이미 완료되었기 때문에 InstancePersistenceCommand 실행이 중단되었습니다.</value>
  </data>
  <data name="KeyCompleteSpecific" xml:space="preserve">
    <value>인스턴스 키 '{0}'이(가) 이미 완료되었기 때문에 InstancePersistenceCommand 실행이 중단되었습니다.</value>
  </data>
  <data name="KeyNotAssociated" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 현재 인스턴스에 연결되어 있지 않은 키를 완료하거나 수정한다고 보고했습니다.</value>
  </data>
  <data name="KeyNotCompleted" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 아직 완료되지 않은 키의 연결을 끊는다고 보고했습니다.</value>
  </data>
  <data name="KeyNotFoundInDictionary" xml:space="preserve">
    <value>지정된 키가 사전에 없습니다.</value>
  </data>
  <data name="KeyNotReadyDefault" xml:space="preserve">
    <value>인스턴스 키가 인스턴스에 연결되지 않아 InstancePersistenceCommand 실행이 중단되었습니다. 이 현상은 인스턴스 또는 키를 지웠거나 키가 잘못된 것일 때 발생합니다. 키 생성 메시지를 잘못된 시간에 보냈거나 부정확한 상관 관계 데이터가 메시지에 들어 있는 경우 키가 잘못될 수 있습니다.</value>
  </data>
  <data name="KeyNotReadySpecific" xml:space="preserve">
    <value>인스턴스 키 '{0}'이(가) 인스턴스에 연결되지 않아 InstancePersistenceCommand 실행이 중단되었습니다. 이 현상은 인스턴스 또는 키를 지웠거나 키가 잘못된 것일 때 발생합니다. 키 생성 메시지를 잘못된 시간에 보냈거나 부정확한 상관 관계 데이터가 메시지에 들어 있는 경우 키가 잘못될 수 있습니다.</value>
  </data>
  <data name="LambdaExpressionReturnTypeInvalid" xml:space="preserve">
    <value>제공된 람다 식의 반환 형식이 null 또는 void가 아니어야 합니다.</value>
  </data>
  <data name="LambdaExpressionTypeRequired" xml:space="preserve">
    <value>제공된 식은 LambdaExpression이어야 합니다. </value>
  </data>
  <data name="LambdaNotXamlSerializable" xml:space="preserve">
    <value>이 워크플로에는 코드에 지정된 람다 식이 포함됩니다. 이러한 식은 직렬화할 수 있는 XAML 식이 아닙니다. 워크플로를 직렬화할 수 있는 XAML로 만들려면 VisualBasicValue/VisualBasicReference 또는 ExpressionServices.Convert(lambda)를 사용하십시오. 그러면 람다 식이 식 작업으로 변환됩니다.</value>
  </data>
  <data name="LineNumberTooLarge" xml:space="preserve">
    <value>{0} 작업에 대해 지정한 줄 번호가 너무 커서 부분 신뢰에서 지원되지 않습니다.</value>
  </data>
  <data name="LiteralsMustBeValueTypesOrImmutableTypes" xml:space="preserve">
    <value>리터럴은 값 형식과 불변 형식 {0}만 지원합니다. {1} 형식은 리터럴로 사용할 수 없습니다.</value>
  </data>
  <data name="LoadedWriteOnlyValue" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 InstanceValueOptions.WriteOnly가 설정된 InstanceValue를 로드한다고 보고했습니다. 쓰기 전용 값은 로드할 수 없습니다.</value>
  </data>
  <data name="LoadingAborted" xml:space="preserve">
    <value>인스턴스 로드 시도가 중단되었습니다.</value>
  </data>
  <data name="LoadingWorkflowApplicationRequiresInstanceStore" xml:space="preserve">
    <value>Load 또는 LoadRunnableInstance를 호출하려면 WorkflowApplication에 유효한 InstanceStore가 설정되어 있어야 합니다.</value>
  </data>
  <data name="LoadOpAssociateKeysCannotContainLookupKey" xml:space="preserve">
    <value>LoadWorkflowByInstanceKeyCommand.AssociateLookupKeyToInstanceId가 지정되어 있지 않으면 LookupInstanceKey가 이미 인스턴스에 연결되어 있거나 LoadWorkflowByInstanceKeyCommand가 실패합니다. 따라서 AssociateLookupKeyToInstanceId가 설정되어 있지 않을 때 InstanceKeysToAssociate 컬렉션에 LookupInstanceKey를 지정하는 것도 잘못된 것입니다.</value>
  </data>
  <data name="LoadOpFreeKeyRequiresAcceptUninitialized" xml:space="preserve">
    <value>LoadByKeyOperation.InstanceIdForFreeKey가 지정된 경우 AcceptUninitializedInstance를 true로 설정해야 합니다. Free 상태인 키는 제공된 인스턴스 ID를 가진 초기화되지 않은 인스턴스에 연결됩니다.</value>
  </data>
  <data name="LoadOpKeyMustBeValid" xml:space="preserve">
    <value>인스턴스를 찾는 데 사용되는 키인 LoadByKeyOperation.LookupKey는 Guid.Empty처럼 모두 0이 아니어야 합니다.</value>
  </data>
  <data name="LocationExpressionCouldNotBeResolved" xml:space="preserve">
    <value>위치 식 '{0}'을(를) 변수 또는 속성으로 확인할 수 없습니다. 위치 식은 범위 계층 구조에 정의된 변수 또는 속성으로 확인됩니다.</value>
  </data>
  <data name="LocationTypeMismatch" xml:space="preserve">
    <value>이름이 '{0}'인 위치는 형식이 '{2}'(이)기 때문에 '{1}' 형식 위치로 검색되지 않습니다. 읽기 및 쓰기 권한 모두 위치에서 공급되기 때문에 형식이 정확히 일치해야 합니다.</value>
  </data>
  <data name="LockRetryTimeout" xml:space="preserve">
    <value>인스턴스 잠금을 얻으려는 중 시간이 초과되었습니다. 할당된 시간 제한인 {0} 내에 작업을 완료하지 못했습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</value>
  </data>
  <data name="LockTimeoutExceptionMessage" xml:space="preserve">
    <value>할당된 시간 제한인 {0} 내에서 잠금을 요구할 수 없습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</value>
  </data>
  <data name="MapEntryNotFound" xml:space="preserve">
    <value>작업 '{0}'에 대한 업데이트 맵 항목을 찾을 수 없습니다.</value>
  </data>
  <data name="MarkCanceledOnlyCallableIfCancelRequested" xml:space="preserve">
    <value>취소하도록 요청된 작업만 MarkCanceled를 호출할 수 있습니다. 이 메서드를 호출하기 전에 먼저 ActivityInstance.HasCancelBeenRequested를 확인하십시오.</value>
  </data>
  <data name="MaximumRetriesExceededForSqlCommand" xml:space="preserve">
    <value>최대 재시도 횟수를 초과하여 SQL 명령 재시도를 중단합니다.</value>
  </data>
  <data name="MaxInstancesExceeded" xml:space="preserve">
    <value>시스템이 스로틀 'MaxConcurrentInstances'에 대해 설정된 한도에 도달했습니다. 이 스로틀의 한도가 {0}(으)로 설정되었습니다. 스로틀 값은 serviceThrottle 요소에서 'maxConcurrentInstances' 특성을 수정하거나 ServiceThrottlingBehavior 동작에서 'MaxConcurrentInstances' 속성을 수정하여 변경할 수 있습니다.</value>
  </data>
  <data name="MaxPendingMessagesPerChannelExceeded" xml:space="preserve">
    <value>'{0}'의 스로틀 'MaxPendingMessagesPerChannel' 한도에 도달했습니다. 이 한도를 늘리려면 BufferedReceiveServiceBehavior에서 MaxPendingMessagesPerChannel 속성을 조정하십시오.</value>
  </data>
  <data name="MaxPendingMessagesPerChannelMustBeGreaterThanZero" xml:space="preserve">
    <value>스로틀 한계는 0보다 커야 합니다. 사용하지 않으려면 Int32.MaxValue로 설정하십시오.</value>
  </data>
  <data name="MayBindLockCommandShouldValidateOwner" xml:space="preserve">
    <value>AutomaticallyAcquiringLock에서 true를 반환하는 InstancePersistenceCommand는 InstanceOwner에 바인딩되지 않은 InstanceHandle을 사용하여 명령을 실행할 때 InvalidOperationException을 발생시키도록 Validate도 다시 정의해야 합니다.</value>
  </data>
  <data name="MemberCannotBeNull" xml:space="preserve">
    <value>{1} 작업 '{2}'의 '{0}'은(는) null일 수 없습니다.</value>
  </data>
  <data name="MemberIsReadOnly" xml:space="preserve">
    <value>'{1}' 형식의 멤버 '{0}'이(가) 읽기 전용입니다. 이 멤버는 LValue일 수 없습니다.</value>
  </data>
  <data name="MemberNotFound" xml:space="preserve">
    <value>'{1}' 형식의 이름이 '{0}'인 멤버가 없습니다.</value>
  </data>
  <data name="MemberNotSupportedByActivityXamlServices" xml:space="preserve">
    <value>ActivityXamlServices에 DynamicActivity에서 지원되지 않는 멤버({0})가 있습니다.</value>
  </data>
  <data name="MessageCannotBeEmpty" xml:space="preserve">
    <value>메시지 콘텐츠가 계약 '{1}'의 작업 '{0}'과(와) 일치하지 않는 null입니다.</value>
  </data>
  <data name="MessageContentCannotHaveMoreThanOneParameter" xml:space="preserve">
    <value>구현된 계약 '{1}'의 작업 '{0}'은(는) 메시지 계약에 대한 매개 변수를 두 개 이상 포함할 수 없습니다.</value>
  </data>
  <data name="MessageHeaderNotSupported" xml:space="preserve">
    <value>MessageDescription의 사용자 지정 메시지 헤더가 지원되지 않습니다. 계약 '{1}'의 작업 '{0}'에서 MessageContract로 데코레이트된 형식을 사용하십시오.</value>
  </data>
  <data name="MessagePropertyIsNotSupported" xml:space="preserve">
    <value>MessageDescription의 사용자 지정 메시지 속성이 지원되지 않습니다. 계약 '{1}'의 작업 '{0}'에서 MessageContract로 데코레이트된 형식을 사용하십시오.</value>
  </data>
  <data name="MessageTypeMismatch" xml:space="preserve">
    <value>Receive에서 구현된 계약 '{2}'의 작업 '{1}'에 지정된 메시지 형식 '{0}'과(와) 다른 ReceiveMessageContent의 System.ServiceModel.Channels.Message 형식이 지정되었습니다.</value>
  </data>
  <data name="MessageVersionInformationNotFound" xml:space="preserve">
    <value>응답 메시지 버전 정보를 찾을 수 없습니다.</value>
  </data>
  <data name="MetadataCannotContainNullKey" xml:space="preserve">
    <value>InstanceValue의 명명된 컬렉션(사전)에 Null 이름이 제공되었습니다. Null은 InstanceValue에 유효한 이름이 아닙니다.</value>
  </data>
  <data name="MetadataCannotContainNullValue" xml:space="preserve">
    <value>InstanceValue의 명명된 컬렉션(사전)에 Null 값이 제공되었습니다. 이 Null 값에 제공된 이름은 {0}입니다. Null은 올바른 InstanceValue가 아닙니다. Null 값을 지정하려면 InstanceValue 생성자에 Null을 전달하여 Null 데이터를 가진 InstanceValue 인스턴스를 사용하십시오. 명명된 값을 삭제하도록 하려면 InstanceValue.DeletedValue를 사용하십시오.</value>
  </data>
  <data name="MethodInfoRequired" xml:space="preserve">
    <value>형식이 '{0}'인 Method 속성이 필요합니다.</value>
  </data>
  <data name="MethodNameRequired" xml:space="preserve">
    <value>형식이 '{0}'인 Name 속성이 필요합니다.</value>
  </data>
  <data name="MissingArgument" xml:space="preserve">
    <value>이름 '{0}'(으)로 연결된 Argument가 '{1}' 컬렉션에서 null입니다.</value>
  </data>
  <data name="MissingBindingInEndpoint" xml:space="preserve">
    <value>Name='{0}'이고 ServiceContract가 '{1}'인 Endpoint에 Binding이 없습니다. 이 Endpoint에 Binding을 제공하십시오.</value>
  </data>
  <data name="MissingBodyInWorkflowService" xml:space="preserve">
    <value>현재 WorkflowService의 Body 속성이 null입니다. 이 WorkflowService에 대한 Body를 제공하십시오.</value>
  </data>
  <data name="MissingDisplayNameInRootActivity" xml:space="preserve">
    <value>루트 활동의 DisplayName이 비어 있습니다. 루트 활동의 DisplayName을 null 또는 빈 문자열 이외의 값으로 설정하거나 WorkflowService의 Name을 제공하십시오.</value>
  </data>
  <data name="MissingKnownTypes" xml:space="preserve">
    <value>계약 '{2}'의 작업 '{1}'에 대해 알려진 형식 '{0}'이(가) 누락되었습니다.</value>
  </data>
  <data name="MissingNameProperty" xml:space="preserve">
    <value>'{0}' 형식의 인수에 이름이 없습니다. 이 컬렉션의 항목에 Name 속성을 지정해야 합니다.</value>
  </data>
  <data name="MissingOperationName" xml:space="preserve">
    <value>OperationName 속성은 '{0}' 작업에서 설정해야 합니다.</value>
  </data>
  <data name="MissingParameter" xml:space="preserve">
    <value>매개 변수 컬렉션에 계약 '{2}'의 작업 '{1}'에 지정된 매개 변수 '{0}'이(가) 없습니다.</value>
  </data>
  <data name="MissingServiceContractName" xml:space="preserve">
    <value>ServiceContractName 속성은 OperationName='{1}'인 '{0}' 작업에서 설정해야 합니다.</value>
  </data>
  <data name="MissingSetAccessorForIndexer" xml:space="preserve">
    <value>{1} 형식에 대한 인덱서 속성 {0}이(가) setter 접근자를 노출하지 않습니다.</value>
  </data>
  <data name="MissingUriInEndpoint" xml:space="preserve">
    <value>Name='{0}'이고 ServiceContract가 '{1}'인 Endpoint에 null이거나 빈 URI 속성이 있습니다. 이 Endpoint에 대한 URI를 제공해야 합니다.</value>
  </data>
  <data name="MisuseOfMessageContent" xml:space="preserve">
    <value>데이터 계약이 계약 '{1}'의 작업 '{0}'에 대해 지정되었습니다. Receive 작업에 대해 ReceiveParameterContent를 사용하고 SendReply 작업에 대해 SendParameterContent를 사용하여 계약 정의를 일치시키십시오.</value>
  </data>
  <data name="MisuseOfParameterContent" xml:space="preserve">
    <value>메시지 계약 형식이 계약 '{1}'의 작업 '{0}'에 대해 지정되었습니다. Receive 작업에 대해 ReceiveMessageContent를 사용하고 SendReply 작업에 대해 SendMessageContent를 사용하여 계약 정의를 일치시키십시오. </value>
  </data>
  <data name="MovingActivitiesInStateBlockDU" xml:space="preserve">
    <value>원래 정의의 작업 속성이 상태 또는 해당 전환 내의 다른 속성에 다시 할당되는 경우 StateMachine은 동적 업데이트를 지원하지 않습니다.</value>
  </data>
  <data name="MultiDimensionalArraysNotSupported" xml:space="preserve">
    <value>다차원 배열은 지원되지 않습니다.</value>
  </data>
  <data name="MultipleFlowNodesSharingSameChildBlockDU" xml:space="preserve">
    <value>두 개 이상의 FlowNode가 동일한 자식 작업을 공유하는 경우 순서도에서 동적 업데이트가 지원되지 않습니다.</value>
  </data>
  <data name="MultipleLockOwnersNotSupported" xml:space="preserve">
    <value>SqlWorkflowInstanceStore에서는 동시에 둘 이상의 잠금 소유자를 만들 수 없습니다. 여러 응용 프로그램에서 저장소를 공유하도록 InstanceStore.DefaultInstanceOwner를 설정하는 방법도 있습니다.</value>
  </data>
  <data name="MultipleOverloadGroupsConfigured" xml:space="preserve">
    <value>다음 오버로드 그룹이 구성되어 있습니다. {0}. 하나의 오버로드 그룹에만 인수를 구성해야 합니다.</value>
  </data>
  <data name="MustCallPrepareBeforeFinalize" xml:space="preserve">
    <value>워크플로 정의에 해당 원본 정의에 대한 연결된 복사본이 없습니다. 워크플로를 업데이트하기 전에 DynamicUpdateServices.PrepareForUpdate를 호출하여 원래 정의의 복사본을 저장하십시오.</value>
  </data>
  <data name="MustCancelOldTimer" xml:space="preserve">
    <value>새 타이머를 설정하려면 먼저 이전 타이머를 취소해야 합니다.</value>
  </data>
  <data name="MustMatchReferenceExpressionReturnType" xml:space="preserve">
    <value>참조 식은 변환으로 끝날 수 없습니다. 제공된 식의 형식은 VisualBasicReference&lt;T&gt; 또는 LambdaReference&lt;T&gt;의 T 형식과 정확히 일치해야 합니다.</value>
  </data>
  <data name="MustSetTransactionOnFirstCall" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. InstancePersistenceContext.Execute 또는 InstancePersistenceContext.BeginExecute를 호출하는 스레드에 앰비언트 트랜잭션(System.Transactions.Transaction.Current)이 설정되어 있지만 트랜잭션이 설정되지 않은 이 실행 에피소드 중에 명령이 이미 실행되었습니다. 앰비언트 트랜잭션은 첫 번째 Execute 또는 BeginExecute 호출에서만 설정할 수 있으며 해당 에피소드에 대해 설정된 다른 트랜잭션이 없어야 합니다.</value>
  </data>
  <data name="MustSpecifyConnectionStringOrName" xml:space="preserve">
    <value>connectionString 또는 connectionStringName 속성 중 하나를 지정해야 합니다.</value>
  </data>
  <data name="NameCollisionOnCollect" xml:space="preserve">
    <value>'{1}' 형식의 지속성 참석자가 제공한 이름 '{0}'에 대해 이름 충돌이 발견되었습니다. 참석자의 CollectValues 구현으로 제공된 값의 이름이 이 참석자 또는 다른 지속성 참석자가 제공한 다른 값과 동일합니다. 충돌을 피하기 위해 참석자가 다른 이름을 사용하도록 수정하거나 워크플로 확장 컬렉션에서 해당 참석자를 제거하십시오.</value>
  </data>
  <data name="NameCollisionOnMap" xml:space="preserve">
    <value>'{1}' 형식의 지속성 참석자가 제공한 이름 '{0}'에 대해 이름 충돌이 발견되었습니다. 참석자의 MapValues 구현으로 제공된 값의 이름이 이 참석자 또는 다른 지속성 참석자가 제공한 다른 값과 동일합니다. 충돌을 피하기 위해 참석자가 다른 이름을 사용하도록 수정하거나 워크플로 확장 컬렉션에서 해당 참석자를 제거하십시오.</value>
  </data>
  <data name="NativeActivityUpdateInstanceThrewException" xml:space="preserve">
    <value>작업에서 UpdateInstance 메서드로부터 예외가 발생했습니다. {0}</value>
  </data>
  <data name="NAUCDisposed" xml:space="preserve">
    <value>NativeActivityUpdateContext는 전달된 함수 범위 내에서만 액세스할 수 있습니다.</value>
  </data>
  <data name="NewArrayBoundsRequiresIntegralArguments" xml:space="preserve">
    <value>'NewArrayBounds'에 정수 계열 인수가 필요합니다.</value>
  </data>
  <data name="NewArrayRequiresArrayTypeAsResultType" xml:space="preserve">
    <value>'NewArray' 작업의 결과 형식은 구체적인 배열 형식이어야 합니다.</value>
  </data>
  <data name="NoAdditionalKeysOnInstanceIdLoad" xml:space="preserve">
    <value>InstanceStore를 지속성 공급자로 사용하는 경우, 인스턴스 ID로 인스턴스를 로드할 때 추가 키를 지정할 수 없습니다.</value>
  </data>
  <data name="NoCAInSecondaryRoot" xml:space="preserve">
    <value>CompensableActivity는 부모 CompensableActivity의 Compensation, Confirmation 또는 Cancellation 처리기 내부에 중첩될 수 없습니다.</value>
  </data>
  <data name="NoChangesMapQueryNotSupported" xml:space="preserve">
    <value>NoChanges 맵 쿼리는 지원되지 않습니다.</value>
  </data>
  <data name="NoDynamicArgumentsInActivityDefinitionChange" xml:space="preserve">
    <value>제공된 구현 맵과 현재 업데이트 간에 이 작업에 대한 변경 사항이 충돌됩니다. 작업의 인수가 두 업데이트 모두에서 변경되었습니다.</value>
  </data>
  <data name="NoDynamicArgumentsInActivityDefinitionChangeRuntime" xml:space="preserve">
    <value>구현 업데이트와 대규모 워크플로 업데이트 간에 이 작업에 대한 변경 사항이 충돌됩니다. 작업의 인수가 두 업데이트 모두에서 변경되었습니다.</value>
  </data>
  <data name="NoNamespace" xml:space="preserve">
    <value>네임스페이스 '{0}:'을(를) 확인할 수 없습니다.</value>
  </data>
  <data name="NonWASActivationNotSupported" xml:space="preserve">
    <value>SqlWorkflowInstanceStore는 WAS 활성화만 지원합니다.</value>
  </data>
  <data name="NoOutputLocationWasFound" xml:space="preserve">
    <value>{0} 인수를 올바른 출력 위치에 맞출 수 없습니다.</value>
  </data>
  <data name="NoOverloadGroupsAreConfigured" xml:space="preserve">
    <value>일부 오버로드 그룹에서 필수/선택 작업 인수가 구성되어 있지 않습니다.</value>
  </data>
  <data name="NoPersistScopeCannotContainPersist" xml:space="preserve">
    <value>NoPersistScope 작업 '{0}'은(는) Persist 작업 '{1}'을(를) 포함할 수 없습니다.</value>
  </data>
  <data name="NoPromotionsDefined" xml:space="preserve">
    <value>명명된 승격 {0}이(가) 어떤 승격도 정의하지 않습니다.</value>
  </data>
  <data name="NoRunnableInstances" xml:space="preserve">
    <value>InstanceStore에 로드할 실행 가능한 워크플로 인스턴스가 없습니다.</value>
  </data>
  <data name="NoRuntimeTransactionExists" xml:space="preserve">
    <value>런타임에 활성 트랜잭션이 없는 경우 CompleteTransaction을 호출할 수 없습니다.</value>
  </data>
  <data name="NotSpecified" xml:space="preserve">
    <value>&lt;지정되지 않음&gt;</value>
  </data>
  <data name="NotSupportMoreThanOneParametersInMessageContract" xml:space="preserve">
    <value>계약 '{1}'의 작업 '{0}'에 대해 MessageContracts를 사용할 때는 작업에 매개 변수가 두 개 이상 포함될 수 없습니다. 올바른 계약 정의를 제공하십시오. </value>
  </data>
  <data name="NullAssignedToValueType" xml:space="preserve">
    <value>인스턴스 저장소에서 형식이 잘못된 값이 검색되었습니다. {0} 형식의 값이 필요하지만 null 값이 검색되었습니다.</value>
  </data>
  <data name="NullCorrelationHandleInInitializeCorrelation" xml:space="preserve">
    <value>CorrelationHandle은 '{0}'에서 null일 수 없습니다.</value>
  </data>
  <data name="NullCorrelationHandleInMultipleQueryCorrelation" xml:space="preserve">
    <value>하나 이상의 QueryCorrelationInitializer에 상관 관계 핸들이 설정되어 있지 않습니다. CorrelationInitializers 컬렉션에 QueryCorrelationInitializer가 둘 이상 있을 경우 CorrelationHandle을 지정해야 합니다.</value>
  </data>
  <data name="NullKeyAlreadyPresent" xml:space="preserve">
    <value>null 키가 있는 항목이 이미 추가되었습니다.</value>
  </data>
  <data name="NullReferencedMemberAccess" xml:space="preserve">
    <value>{0} 형식의 null 개체를 {1} 멤버로 역참조할 수 없습니다.</value>
  </data>
  <data name="NullReplyMessageContractMismatch" xml:space="preserve">
    <value>서버에서 null 회신 메시지를 받았습니다. 이것은 클라이언트측과 서버측 간의 계약 불일치 때문일 수 있습니다. 서버측 워크플로가 양방향 작업으로 구성되어 있는지 확인하십시오.</value>
  </data>
  <data name="OnCancelRequestedThrew" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 취소 처리기에서 예외가 발생했습니다. 처리기는 InstancePersistenceContext.SetCancellationHandler 메서드를 통해 지정되었습니다.</value>
  </data>
  <data name="OneOfTwoPropertiesMustBeSet" xml:space="preserve">
    <value>'{3}' 작업의 '{2}'에는 '{0}' 속성 또는 '{1}' 속성이 필요합니다.</value>
  </data>
  <data name="OnewayContractIsImplementedAsTwoWay" xml:space="preserve">
    <value>계약 '{1}'의 단방향 작업 '{0}'에는 SendReply 작업이 포함될 수 없습니다. </value>
  </data>
  <data name="OnFreeInstanceHandleThrew" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. OnFreeInstanceHandle 구현에서 예외가 발생했습니다.</value>
  </data>
  <data name="OnlyBookmarkOwnerCanRemove" xml:space="preserve">
    <value>책갈피는 책갈피를 만든 작업 인스턴스에서만 제거할 수 있습니다.</value>
  </data>
  <data name="OnlyOneOperationPerActivity" xml:space="preserve">
    <value>지정된 시간에 한 동작에 대해 하나의 작업만 활성화될 수 있습니다. 이미 다른 작업이 진행 중입니다.</value>
  </data>
  <data name="OnlyOneRequireTransactionContextAllowed" xml:space="preserve">
    <value>런타임에서 이미 RequireTransactionContext 호출을 제공하려고 합니다.</value>
  </data>
  <data name="OnlySingleCastDelegatesAllowed" xml:space="preserve">
    <value>WorkflowApplication 이벤트에는 멀티캐스트가 아닌 대리자만 허용됩니다. 제공된 대리자에 길이가 1보다 큰 호출 목록이 있습니다.</value>
  </data>
  <data name="OperationAlreadyCompleted" xml:space="preserve">
    <value>작업이 이미 완료되었습니다.</value>
  </data>
  <data name="OperationDoesNotExistInContract" xml:space="preserve">
    <value>작업 '{0}'이(가) 이름이 '{1}'이고 네임스페이스가 '{2}'인 계약에 없습니다.</value>
  </data>
  <data name="OperationFormatterAndFaultFormatterIncorrectlySet" xml:space="preserve">
    <value>OperationFormatter와 FaultFormatter는 동시에 설정할 수 없습니다.</value>
  </data>
  <data name="OperationFormatterAndFaultFormatterNotSet" xml:space="preserve">
    <value>OperationFormatter와 FaultFormatter는 동시에 null일 수 없습니다.</value>
  </data>
  <data name="OperationHasSerializerBehavior" xml:space="preserve">
    <value>계약 '{1}'의 '{0}' 작업에 '{2}' 동작이 이미 있으므로 새 동작을 추가할 수 없습니다. 이 문제는 일반적으로 IOperationSerializer.ApplyToOperation 메서드가 이 작업에 대해 이미 호출되었음을 나타냅니다.</value>
  </data>
  <data name="OperationIsNotImplemented" xml:space="preserve">
    <value>계약 '{1}'의 작업 '{0}'이(가) 워크플로에 구현되지 않았습니다.</value>
  </data>
  <data name="OperationNotAvailable" xml:space="preserve">
    <value>현재 식별자가 '{1}'인 서비스 인스턴스의 '{0}' 작업을 수행할 수 없습니다. 작업이 올바른 순서대로 수행되고 사용 중인 바인딩에서 순서가 지정된 배달이 제공되는지 확인하십시오.</value>
  </data>
  <data name="OperationNotFound" xml:space="preserve">
    <value>계약이 {0}이고 작업이 {1}인 Receive를 기본 WorkflowService에서 찾을 수 없습니다. 다른 WorkflowService 버전의 모든 작업이 먼저 기본 WorkflowService에 추가되었는지 확인하십시오.</value>
  </data>
  <data name="OptionalExtensionTypeMatchedMultiple" xml:space="preserve">
    <value>'{0}' 형식의 확장이 여러 개 있습니다. 이 워크플로를 실행할 때 이 형식의 확장은 하나만 허용됩니다.</value>
  </data>
  <data name="OriginalActivityReusedInModifiedDefinition" xml:space="preserve">
    <value>원본 정의의 작업 '{0}'을(를) 업데이트된 정의에서 다시 사용하지 못할 수 있습니다.</value>
  </data>
  <data name="OriginalVariableReusedInModifiedDefinition" xml:space="preserve">
    <value>원본 정의의 변수 '{0}'을(를) 업데이트된 정의에서 다시 사용하지 못할 수 있습니다.</value>
  </data>
  <data name="OriginCannotBeRuntimeIntrinsic" xml:space="preserve">
    <value>이미 워크플로 정의 요소(Activity, ActivityDelegate, Argument 또는 LocationReference)이기 때문에 개체 '{0}'을(를) 원본으로 사용할 수 없습니다.</value>
  </data>
  <data name="OutArgumentCannotHaveInputValue" xml:space="preserve">
    <value>OutArgument '{0}'을(를) 입력 값으로 구성할 수 없습니다. 키 '{0}'은(는) 입력 사전에서 제거해야 합니다.</value>
  </data>
  <data name="OutOfIdSpaceIds" xml:space="preserve">
    <value>이 ID 공간의 작업 수가 Int32.MaxValue를 초과했습니다. 워크플로의 일부를 새 Activity 서브클래스로 리팩터링하십시오.</value>
  </data>
  <data name="OutOfInstanceIds" xml:space="preserve">
    <value>워크플로에서 long.MaxValue 작업 인스턴스만 실행할 수 있습니다.</value>
  </data>
  <data name="OutOfInternalBookmarks" xml:space="preserve">
    <value>워크플로에 대한 long.MaxValue 내부 책갈피만 생성할 수 있습니다.</value>
  </data>
  <data name="OutOfRangeSourceLocationEndColumn" xml:space="preserve">
    <value>단일 줄 SourceLocation의 경우, endColumn은 startColumn(= {0})보다 크거나 같아야 합니다.</value>
  </data>
  <data name="OutOfRangeSourceLocationEndLine" xml:space="preserve">
    <value>SourceLocation의 endLine은 startLine(= {0})보다 크거나 같아야 합니다.</value>
  </data>
  <data name="OutsideInstanceExecutionScope" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. {0} 메서드는 명령을 처리하는 동안에만 호출할 수 있습니다. 나중에 사용하기 위해 InstancePersistenceContext의 인스턴스를 보관하지 마십시오. TryCommand 및 BeginTryCommand에 제공된 InstancePersistenceContext는 해당 명령을 처리하는 동안에만 사용할 수 있습니다.</value>
  </data>
  <data name="OutsideTransactionalCommand" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 트랜잭션 일관성이 필요 없는 명령을 수행하는 중 트랜잭션 일관성이 필요한 InstancePersistenceContext의 {0} 메서드를 호출했습니다. 이로 인해 데이터가 손실될 수 있습니다. 이 오류는 잘못된 지속성 공급자 구현을 나타냅니다.</value>
  </data>
  <data name="OverloadGroupHasSubsets" xml:space="preserve">
    <value>다음 오버로드 그룹은 '{0}' 그룹의 하위 집합입니다. {1}. 오버로드 그룹을 다른 그룹의 하위 집합으로 사용할 경우 오류가 발생합니다.</value>
  </data>
  <data name="OverloadGroupsAreEquivalent" xml:space="preserve">
    <value>다음 오버로드 그룹은 서로 같습니다. {0}. 여기에서는 하나의 오버로드 그룹만 정의하면 충분합니다.</value>
  </data>
  <data name="OverloadingMethodMustBeStatic" xml:space="preserve">
    <value>연산자를 오버로드하는 메서드는 정적이어야 합니다.</value>
  </data>
  <data name="OverloadOnlyCallableFromWorkflowThread" xml:space="preserve">
    <value>이 메서드 오버로드는 워크플로 스레드에서만 호출할 수 있습니다.</value>
  </data>
  <data name="OwnerBelongsToWrongStore" xml:space="preserve">
    <value>잘못된 InstanceOwner가 제공되었습니다. InstanceStore에 제공된 InstanceOwner는 InstanceStore에 속해야 합니다. InstanceOwner 개체를 만든 InstanceStore하고만 사용하십시오.</value>
  </data>
  <data name="OwnerRequired" xml:space="preserve">
    <value>인스턴스 지속성 시스템에서 잘못된 InstancePersistenceCommand를 처리할 수 없습니다. 명령을 수행하려면 인스턴스 소유자가 필요하지만 InstanceHandle에 바인딩된 소유자가 없습니다.</value>
  </data>
  <data name="ParallelForEachRequiresNonNullValues" xml:space="preserve">
    <value>ParallelForEach 작업 '{0}'을(를) 사용하려면 먼저 값을 null이 아닌 식에 바인딩해야 합니다</value>
  </data>
  <data name="ParameterNumberMismatch" xml:space="preserve">
    <value>매개 변수 '{0}'이(가) 계약 '{2}'의 작업 '{1}'에 없습니다.</value>
  </data>
  <data name="ParameterPositionMismatch" xml:space="preserve">
    <value>매개 변수 '{0}'이(가) 계약 '{2}'의 작업 '{1}'에 대해 올바른 순서가 아닙니다. 매개 변수 컬렉션에서 위치 '{3}'(으)로 이동하십시오. </value>
  </data>
  <data name="ParameterTypeMismatch" xml:space="preserve">
    <value>매개 변수 '{0}'의 형식이 구현된 계약 '{3}'의 작업 '{2}'에 지정된 형식 '{1}'과(와) 일치하지 않습니다.</value>
  </data>
  <data name="PartialTrustPerformanceCounterNotEnabled" xml:space="preserve">
    <value>성능 카운터에 대한 액세스가 거부되었습니다. 응용 프로그램이 부분 신뢰 상태에서 실행되고 있을 수 있습니다. 성능 카운터를 사용하지 않도록 설정하거나 응용 프로그램이 완전 신뢰 상태에서 실행되도록 구성하십시오.</value>
  </data>
  <data name="PauseWhenPersistableInvalidIfPersistable" xml:space="preserve">
    <value>PauseWhenPersistable은 IsPersistable이 False인 경우에만 호출할 수 있습니다.</value>
  </data>
  <data name="PendingMessagesPerChannelRatio" xml:space="preserve">
    <value>채널당 보류 중인 메시지 비율: {0}/{1}</value>
  </data>
  <data name="PermissionArgumentWrongType" xml:space="preserve">
    <value>인수가 잘못된 형식입니다. '{0}'이(가) 필요합니다.</value>
  </data>
  <data name="PersistenceInitializerThrew" xml:space="preserve">
    <value>IPersistenceContextInitializer 구현에서 예외가 발생했습니다. WorkflowServiceInstance와 같은 지속적인 서비스 인스턴스를 로드하거나 만들 수 없습니다. InnerException 속성에는 원본 예외가 포함되어 있습니다.</value>
  </data>
  <data name="PersistencePipelineAbortThrew" xml:space="preserve">
    <value>'{0}' 형식의 지속성 참석자가 Abort를 구현하여 예외가 발생했습니다. Abort 구현에서는 예외가 발생하지 않아야 합니다.</value>
  </data>
  <data name="PersistenceProviderRequiredToPersist" xml:space="preserve">
    <value>PersistenceProvider 확장으로 구성된 워크플로 인스턴스만 지속되거나 언로드될 수 있습니다.</value>
  </data>
  <data name="PersistenceTooLateToEnlist" xml:space="preserve">
    <value>트랜잭션에 참여하기에는 너무 늦었습니다. 이미 커밋 또는 중단이 시작되었습니다.</value>
  </data>
  <data name="PersistenceViolationNoCreate" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. InstanceNotReadyException이 발생했을 때는 새 인스턴스를 만들어야 합니다.</value>
  </data>
  <data name="PickBranchRequiresTrigger" xml:space="preserve">
    <value>PickBranch '{0}'을(를) 사용하려면 먼저 트리거를 설정해야 합니다.</value>
  </data>
  <data name="PickBranchTriggerActionSwapped" xml:space="preserve">
    <value>PickBranch의 트리거와 작업이 바뀐 경우 Pick에서 동적 업데이트가 지원되지 않습니다.</value>
  </data>
  <data name="PrepareForSerializationRequiresPersistability" xml:space="preserve">
    <value>PrepareForSerialization은 IsPersistable이 True인 경우에만 호출할 수 있습니다.</value>
  </data>
  <data name="PrivateMembersHaveChanged" xml:space="preserve">
    <value>이 작업의 전용 구현이 변경되었습니다(구현 자식, 대리자, 변수 또는 인수 추가, 제거 또는 다시 정렬). 동적 업데이트에는 작업의 공용 구성과는 독립적으로 구현 맵에 지정된 구현 변경 사항만 지원됩니다.</value>
  </data>
  <data name="PromotionAlreadyDefined" xml:space="preserve">
    <value>승격 설정 {0}이(가) 이미 정의되었습니다.</value>
  </data>
  <data name="PromotionTooManyDefined" xml:space="preserve">
    <value>승격 설정 {0}(으)로 최대 허용 승격 {3}을(를) 초과하는 {1} {2} 승격이 정의되었습니다.</value>
  </data>
  <data name="PropertyCannotBeModified" xml:space="preserve">
    <value>SqlTrackingParticipant에서 레코드를 처리하기 시작한 후에는 {0} 속성을 수정할 수 없습니다.</value>
  </data>
  <data name="PropertyMemberNotSupportedByActivityXamlServices" xml:space="preserve">
    <value>ActivityXamlServices에 DynamicActivityProperty에서 지원되지 않는 x:Property 멤버({0})가 있습니다.</value>
  </data>
  <data name="PropertyMismatch" xml:space="preserve">
    <value>'{0}'이(가) 계약 '{4}'의 작업 '{3}'에 제공된 '{1}' 값 '{2}'과(와) 일치하지 않습니다.</value>
  </data>
  <data name="PropertyReadOnlyInWorkflowDataContext" xml:space="preserve">
    <value>'{0}' 속성은 WorkflowDataContext에서 읽기 전용입니다.</value>
  </data>
  <data name="PropertyReferenceNotFound" xml:space="preserve">
    <value>PropertyReference에서 '{0}' 속성을 확인할 수 없습니다.</value>
  </data>
  <data name="ProtectionLevelIsNotSupported" xml:space="preserve">
    <value>사용자 지정 ProtectionLevel 설정은 MessageContract를 통해서만 지원됩니다. 구현된 계약 '{1}'의 작업 '{0}'에 대해 MessageContract 형식을 지정하십시오.</value>
  </data>
  <data name="ProtectionLevelNotSupported" xml:space="preserve">
    <value>워크플로에서는 오류에 대한 사용자 지정 ProtectionLevel 설정이 지원되지 않습니다. 구현된 계약 '{1}'의 작업 '{0}'에서 FaultContract에 대한 ProtectionLevel을 지정하지 마십시오.</value>
  </data>
  <data name="ProvidedStateInitializedForExecution" xml:space="preserve">
    <value>런타임 상태가 실행을 위해 초기화되었으므로 런타임 상태를 업데이트할 수 없습니다. 지속성에서 상태를 다시 로드하십시오.</value>
  </data>
  <data name="ProviderDoesNotSupportCommand" xml:space="preserve">
    <value>InstanceStore의 지속성 공급자 구현은 이름이 {0}인 명령을 지원하지 않습니다. 다른 공급자를 선택하거나 이 지속성 명령이 시도되지 않도록 하십시오.</value>
  </data>
  <data name="PublicChildrenChangeBlockDU" xml:space="preserve">
    <value>이 작업에서는 해당 공용 자식에 대한 변경이 지원되지 않습니다(Activities 또는 ActivityDelegates 추가, 제거 또는 다시 정렬).</value>
  </data>
  <data name="PublicEnvironmentAccessToNonGenericActivity" xml:space="preserve">
    <value>공용 환경 액세스는 CodeActivity가 아닌 CodeActivity&lt;TResult&gt;에서 파생된 작업에서만 사용할 수 있습니다.</value>
  </data>
  <data name="PublicMethodWithMatchingParameterDoesNotExist" xml:space="preserve">
    <value>'{0}'에 InvokeMethod '{3}'에 제공된 매개 변수 형식, 제네릭 형식 인수 및 제네릭 형식 제약 조건과 일치하는 이름이 '{2}'인 public {1} 메서드가 없습니다.</value>
  </data>
  <data name="PublicReferencesOnActivityRequiringArgumentResolution" xml:space="preserve">
    <value>작업 '{0}'에서는 기본 제공된 Result 인수 이외의 인수를 정의할 수 없으며, CodeActivityPublicEnvironmentAccessor를 통해 공용 위치에 대한 액세스를 선언합니다. 인수를 통해 또는 CodeActivityPublicEnvironmentAccessor.TryGetAccessToPublicLocation 및 TryGetReferenceToPublicLocation을 통해 작업에 모든 데이터를 전달하십시오.</value>
  </data>
  <data name="QueryActivityIsInImplementation" xml:space="preserve">
    <value>이 작업은 복합 작업 '{0}'의 구현 내에 포함됩니다. 업데이트 가능 여부를 쿼리하려면 복합 작업에 대해 구현 맵을 사용하십시오.</value>
  </data>
  <data name="QueryActivityIsNotInDefinition" xml:space="preserve">
    <value>이 작업은 원래 워크플로 정의 또는 업데이트된 워크플로 정의에 속하지 않습니다.</value>
  </data>
  <data name="QueryActivityIsPublic" xml:space="preserve">
    <value>이 작업은 루트 워크플로 정의에 속합니다. 업데이트 가능 여부를 쿼리하려면 복합 작업 '{0}'에 대한 구현 맵 대신 워크플로에 대한 업데이트 맵을 사용하십시오.</value>
  </data>
  <data name="QueryCorrelationInitializerCannotBeInitialized" xml:space="preserve">
    <value>QueryCorrelationInitializer를 초기화할 수 있는 상관 관계 핸들이 없습니다. 쿼리 이니셜라이저에 명시적으로 설정된 핸들이 없고 상관 관계 범위에서 사용할 수 있는 핸들이 없기 때문입니다.</value>
  </data>
  <data name="QueryCorrelationInitializerWithEmptyMessageQuerySet" xml:space="preserve">
    <value>DisplayName='{0}', OperationName='{1}'인 작업에 MessageQuerySet가 비어 있는 QueryCorrelationInitializer가 있습니다.</value>
  </data>
  <data name="QueryVariableIsInImplementation" xml:space="preserve">
    <value>이 변수는 복합 작업 '{0}'의 구현 내에 포함됩니다. 업데이트 가능 여부를 쿼리하려면 복합 작업에 대해 구현 맵을 사용하십시오.</value>
  </data>
  <data name="QueryVariableIsNotInDefinition" xml:space="preserve">
    <value>이 변수는 원래 워크플로 정의 또는 업데이트된 워크플로 정의에 속하지 않습니다.</value>
  </data>
  <data name="QueryVariableIsNotPublic" xml:space="preserve">
    <value>이 변수는 공용이 아닙니다. 공용 변수만 동적 업데이트를 통해 변경할 수 있습니다.</value>
  </data>
  <data name="QueryVariableIsPublic" xml:space="preserve">
    <value>이 변수는 루트 워크플로 정의에 속합니다. 업데이트 가능 여부를 쿼리하려면 복합 작업 '{0}'에 대한 구현 맵 대신 워크플로에 대한 업데이트 맵을 사용하십시오.</value>
  </data>
  <data name="QueuingSqlRetry" xml:space="preserve">
    <value>{0}밀리초의 지연으로 SQL 재시도를 큐에 넣고 있습니다.</value>
  </data>
  <data name="ReadAccessToWriteOnlyPublicReference" xml:space="preserve">
    <value>작업 '{0}'이(가) ArgumentDirection.Out으로 선언되었기 때문에 이 공용 위치에서 읽을 수 없습니다. 읽기 및 쓰기를 모두 허용하려면 ArgumentDirection.InOut으로 참조를 선언하십시오.</value>
  </data>
  <data name="ReadNotSupported" xml:space="preserve">
    <value>이 스트림에서는 읽기가 지원되지 않습니다.</value>
  </data>
  <data name="ReadonlyNameScopeCannotBeUpdated" xml:space="preserve">
    <value>이름 범위 구현은 읽기 전용이므로 작업을 사용할 수 없습니다.</value>
  </data>
  <data name="ReadonlyPropertyCannotBeSet" xml:space="preserve">
    <value>set 접근자에 액세스할 수 없으므로 이 컨텍스트에서 속성 또는 인덱서 '{0}.{1}'을(를) 사용할 수 없습니다.</value>
  </data>
  <data name="ReceiveAndReceiveParametersHaveSameName" xml:space="preserve">
    <value>ReceiveContent 형식이 다른 두 개의 Receive에서 ServiceContractName 및 OperationName '{0}'이(가) 동일합니다.</value>
  </data>
  <data name="ReceiveContentChanged" xml:space="preserve">
    <value>이 Receive 작업의 콘텐츠가 형식 없는 콘텐츠와 형식화된 콘텐츠 사이에서 변경되었습니다.</value>
  </data>
  <data name="ReceiveCorrelationInitializiersChanged" xml:space="preserve">
    <value>이 Receive 작업의 CorrelationInitializers가 변경되었습니다.</value>
  </data>
  <data name="ReceiveIsInTRSWhenTransactionFlowNotAllowed" xml:space="preserve">
    <value>구현된 계약 '{1}'의 작업 '{0}'에서 TransactionFlowOption이 NotAllowed로 설정된 동안에는 Receive가 TransactedReceiveScope에 있습니다.</value>
  </data>
  <data name="ReceiveIsNotInTRS" xml:space="preserve">
    <value>구현된 계약 '{1}'의 작업 '{0}'에서는 트랜잭션이 진행되어야 하지만 Receive가 TransactedReceiveScope에 없습니다.</value>
  </data>
  <data name="ReceiveMessageNeedsToPairWithSendMessageForTwoWayContract" xml:space="preserve">
    <value>Receive 작업은 요청/회신 작업 '{0}'(으)로 구성되어 있지만 연결할 SendReply가 없습니다. Receive와 SendReply를 연결하고 CorrelationHandle을 사용하여 상관 관계를 지정하십시오.</value>
  </data>
  <data name="ReceiveNotWithinATransactedReceiveScope" xml:space="preserve">
    <value>트랜잭션 방향의 Receive 작업이 TransactedReceiveScope 내에 포함되어 있지 않습니다.</value>
  </data>
  <data name="ReceivePairedWithSendReplyAndSendReplyParameters" xml:space="preserve">
    <value>SendMessageContent를 포함하는 SendReply 및 SendParametersContent를 포함하는 SendReply가 모두 OperationName='{0}'인 동일한 Receive와 연결됩니다. 이것은 허용되지 않습니다.</value>
  </data>
  <data name="ReceiveParametersContentDoesNotSupportMessage" xml:space="preserve">
    <value>DisplayName='{0}'인 작업에 Message 또는 MessageContract인 '{1}' 인수가 있습니다. ReceiveParametersContent는 Message 또는 MessageContract를 지원하지 않습니다. Message 또는 MessageContract 기반 콘텐츠에는 콘텐츠 속성을 ReceiveMessageContent로 지정해야 합니다.</value>
  </data>
  <data name="ReceiveReplyRequestCannotBeNull" xml:space="preserve">
    <value>'{0}' 활동의 Request 속성은 null일 수 없습니다. 이 요청/회신 쌍에 속하는 Send 활동으로 설정해야 합니다.</value>
  </data>
  <data name="ReferencedChildInIsNewlyAdded" xml:space="preserve">
    <value>이 메서드는 가져온 자식에 대한 참조인 작업에 대해 호출할 수 없습니다. 이 메서드를 호출하기 전에 NativeActivityUpdateContext.IsReferenceToImportedChild를 확인하십시오.</value>
  </data>
  <data name="RegisteredBookmarkScopeRequired" xml:space="preserve">
    <value>등록된 책갈피 범위만 범위가 지정된 책갈피를 만드는 데 사용할 수 있습니다.</value>
  </data>
  <data name="RelativeUriRequiresBinding" xml:space="preserve">
    <value>Endpoint의 Binding 속성이 null이므로 Name='{0}'이고 ServiceContract가 '{1}'인 Endpoint의 상대 URI '{2}'을(를) 절대 URI로 변환할 수 없습니다. Binding 속성을 설정하거나 상대 URI를 절대 URI로 변경하십시오.</value>
  </data>
  <data name="RelativeUriRequiresHost" xml:space="preserve">
    <value>GetAddress 메서드의 호스트 인수가 null이므로 Name='{0}'이고 ServiceContract가 '{1}'인 Endpoint의 상대 URI '{2}'을(를) 절대 URI로 변환할 수 없습니다. 끝점을 호스팅하는 서비스 호스트 인스턴스를 제공하거나 상대 URI를 절대 URI로 변경하십시오.</value>
  </data>
  <data name="RemovingTransitionsBlockDU" xml:space="preserve">
    <value>실행 중인 상태에서 전환이 제거되는 경우 StateMachine은 동적 업데이트를 지원하지 않습니다.</value>
  </data>
  <data name="RenewLockSystemError" xml:space="preserve">
    <value>잠금 만료를 연장하지 못했습니다. 잠금 만료가 이미 지났거나 잠금 소유자가 삭제되었습니다. SqlWorkflowInstanceStore를 중단하는 중입니다.</value>
  </data>
  <data name="ReplyShouldNotIncludeRequestReplyHandle" xml:space="preserve">
    <value>OperationName='{1}'인 '{0}' 작업은 추가 상관 관계에서 요청/회신 핸들을 포함할 수 없습니다.</value>
  </data>
  <data name="RequestMustBeSpecified" xml:space="preserve">
    <value>작업 '{0}'에서 Request 인수를 지정해야 합니다.</value>
  </data>
  <data name="RequestReplyHandleShouldNotBePresentForOneWay" xml:space="preserve">
    <value>단방향 Send 또는 Receive 활동에 대해 RequestReplyCorrelationInitializer를 지정하면 안 됩니다. RequestReply 상관 관계를 초기화할 때 Send는 ReceiveReply 활동과 쌍을 이루어야 하고 Receive는 SendReply 활동과 쌍을 이루어야 합니다.</value>
  </data>
  <data name="RequiredArgumentValueNotSupplied" xml:space="preserve">
    <value>필수 작업 인수 '{0}'의 값이 제공되지 않았습니다.</value>
  </data>
  <data name="RequiredExtensionTypeNotFound" xml:space="preserve">
    <value>이 워크플로를 실행하려면 '{0}' 형식의 확장을 구성해야 합니다.</value>
  </data>
  <data name="RequiredVariableCoundNotBeExtracted" xml:space="preserve">
    <value>작업: {1}에서 필수 변수 {0}은(는) 추출에 사용할 수 없습니다.</value>
  </data>
  <data name="RequireExtensionOnlyAcceptsReferenceTypes" xml:space="preserve">
    <value>'{0}'은(는) 값 형식입니다. RequireExtension에는 참조 형식만 사용할 수 있습니다.</value>
  </data>
  <data name="ResponseContextIsNotNull" xml:space="preserve">
    <value>ResponseContext는 null이 아닙니다.</value>
  </data>
  <data name="ResultArgumentHasRequiredTypeAndDirection" xml:space="preserve">
    <value>작업 작성자가 제공한 이름이 'Result'인 RuntimeArgument는 ArgumentDirection이 Out이어야 하고 형식이 {0}이어야 하지만 ArgumentDirection이 {1}이고 형식이 {2}입니다.</value>
  </data>
  <data name="ResultArgumentMustBeBoundToResultProperty" xml:space="preserve">
    <value>작업 작성자가 제공한 이름이 'Result'인 RuntimeArgument는 작업의 Result 속성에서 반환된 인수로 바인딩되어야 합니다.</value>
  </data>
  <data name="ResultArgumentMustBeSpecificType" xml:space="preserve">
    <value>이 작업의 Result OutArgument는 {0}의 OutArgument여야 합니다.</value>
  </data>
  <data name="ResultCannotBeSetOnArgumentExpressions" xml:space="preserve">
    <value>Activity&lt;T&gt;가 인수의 식으로 사용될 경우 Activity&lt;T&gt;의 Result OutArgument를 설정할 수 없습니다.</value>
  </data>
  <data name="ResultMustBeSpecified" xml:space="preserve">
    <value>작업 '{0}'에서 Result 인수를 지정해야 합니다.</value>
  </data>
  <data name="RethrowMustBeAPublicChild" xml:space="preserve">
    <value>재발생 작업 '{0}'은(는) TryCatch 작업의 전용 자식으로 사용할 수 없습니다. 재발생은 TryCatch 작업의 공용 자식에서만 허용됩니다.</value>
  </data>
  <data name="RethrowNotInATryCatch" xml:space="preserve">
    <value>재발생 작업 '{0}'은(는) TryCatch 작업의 Catch 처리기에 대한 자식이어야 합니다.</value>
  </data>
  <data name="RetryingSqlCommandDueToSqlError" xml:space="preserve">
    <value>SQL 오류 {0}번으로 인해 SQL 명령을 재시도하고 있습니다.</value>
  </data>
  <data name="ReturnTypeIncompatible" xml:space="preserve">
    <value>형식이 일치하지 않습니다. '{2}' 형식의 가장 근접한 '{1}' 메서드의 반환 형식 '{0}'이(가) InvokeMethod '{3}'에 제공된 'Result' 인수와 호환되지 않습니다. 형식이 '{4}'인 반환 값이 필요합니다.</value>
  </data>
  <data name="ReturnValueMissing" xml:space="preserve">
    <value>계약 '{2}'의 작업 '{1}'에 대해 '{0}' 형식의 반환 값 매개 변수가 누락되었습니다. </value>
  </data>
  <data name="RootActivityAlreadyAssociatedWithInstance" xml:space="preserve">
    <value>표시 이름이 '{0}'인 작업이 이미 인스턴스와 연관되어 있습니다. 인스턴스와 연관된 후에는 작업의 메타데이터를 조작할 수 없습니다. 이 오류는 루트 작업이 사실상 다른 워크플로에 속하는 워크플로를 실행하려고 했음을 의미할 수도 있습니다.</value>
  </data>
  <data name="RootActivityCannotBeReferenced" xml:space="preserve">
    <value>'{0}' 작업은 루트 작업이 아니며 '{1}' 작업에서 참조할 수 없습니다.</value>
  </data>
  <data name="RootArgumentViolationsFound" xml:space="preserve">
    <value>루트 작업의 인수에 대해 제공된 값이 루트 작업의 요구 사항을 충족하지 않습니다.</value>
  </data>
  <data name="RootArgumentViolationsFoundNoInputs" xml:space="preserve">
    <value>루트 작업의 인수 설정이 잘못되었습니다. 워크플로 정의를 수정하거나 이러한 오류를 해결할 수 있는 입력 값을 제공하십시오.</value>
  </data>
  <data name="RunnableInstancesDetectionError" xml:space="preserve">
    <value>다음 예외로 인해 실행 가능한 인스턴스를 검색하지 못했습니다.</value>
  </data>
  <data name="RuntimeArgumentBindingInvalid" xml:space="preserve">
    <value>RuntimeArgument '{0}'이(가) 이번에는 이름이 '{1}'인 RuntimeArgument에 바인딩된 Argument를 참조합니다. Argument 개체가 둘 이상의 RuntimeArgument 개체에 바인딩되거나 둘 이상의 public Argument 속성에서 공유되지 않는지 확인하십시오.</value>
  </data>
  <data name="RuntimeArgumentChangeBlockDU" xml:space="preserve">
    <value>해당 RuntimeArguments가 변경되었기 때문에 작업 '{0}' 내에서는 동적 업데이트가 허용되지 않습니다. 이 작업 내에서 동적 업데이트를 사용하도록 설정하려면 RuntimeArguments를 추가하거나, 제거하거나, 다시 정렬할 수 없습니다. 또한 해당 Name, Type 및 Direction도 변경할 수 없습니다.</value>
  </data>
  <data name="RuntimeArgumentNotCreated" xml:space="preserve">
    <value>RuntimeArgument 인스턴스가 아직 만들어지지 않았습니다.</value>
  </data>
  <data name="RuntimeArgumentNotOpen" xml:space="preserve">
    <value>'{0}' 인수를 사용할 수 없습니다. 이 인수가 작업에 선언되어 있는지 확인하십시오.</value>
  </data>
  <data name="RuntimeDelegateArgumentDirectionIncorrect" xml:space="preserve">
    <value>RuntimeDelegateArgument의 방향은 바인딩된 DelegateArgument의 방향과 일치해야 합니다.</value>
  </data>
  <data name="RuntimeDelegateArgumentTypeIncorrect" xml:space="preserve">
    <value>RuntimeDelegateArgument의 형식은 바인딩된 DelegateArgument의 형식과 일치해야 합니다.</value>
  </data>
  <data name="RuntimeOperationInProgress" xml:space="preserve">
    <value>런타임 작업이 이미 진행 중입니다. WorkflowInstance에 액세스하려면 호출자에 의해 동기화되어야 합니다.</value>
  </data>
  <data name="RuntimeRunning" xml:space="preserve">
    <value>워크플로 런타임에서 현재 워크플로가 실행 중이며, 작업은 워크플로가 일시 중지된 동안에만 수행될 수 있습니다. WorkflowInstance에 액세스하려면 호출자에 의해 동기화되어야 합니다.</value>
  </data>
  <data name="RuntimeTransactionAlreadyExists" xml:space="preserve">
    <value>런타임이 트랜잭션으로 이미 구성되었습니다. 한 번에 하나의 트랜잭션만 허용됩니다.</value>
  </data>
  <data name="RuntimeTransactionComplete" xml:space="preserve">
    <value>런타임 트랜잭션이 '{0}' 상태로 완료되었습니다.</value>
  </data>
  <data name="RuntimeTransactionCompletionRequested" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'이(가) 런타임 트랜잭션 완료를 예약했습니다.</value>
  </data>
  <data name="RuntimeTransactionHandleNotRegisteredAsExecutionProperty" xml:space="preserve">
    <value>'{0}' 메서드는 해당하는 RuntimeTransactionHandle 개체가 실행 속성으로 등록된 경우에만 호출할 수 있습니다.</value>
  </data>
  <data name="RuntimeTransactionIsSuppressed" xml:space="preserve">
    <value>런타임 트랜잭션이 표시되지 않은 경우 이 작업은 올바르지 않습니다. SuppressTransaction 속성이 현재 환경의 RuntimeTransactionHandle에 대해 설정되었기 때문에 런타임 트랜잭션이 표시되지 않습니다.</value>
  </data>
  <data name="RuntimeTransactionSet" xml:space="preserve">
    <value>런타임 트랜잭션이 작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'(으)로 설정되었습니다. 작업 '{3}', DisplayName: '{4}', InstanceId: '{5}'(으)로 실행이 격리되었습니다.</value>
  </data>
  <data name="SameUserStateUsedForMultipleInvokes" xml:space="preserve">
    <value>같은 사용자 상태 인스턴스는 현재 작업 호출에 사용할 수 없습니다.</value>
  </data>
  <data name="SavingActivityToXamlNotSupported" xml:space="preserve">
    <value>DynamicActivity 또는 Activity.Implementation을 XAML에 저장할 수 없습니다. 매개 변수가 있는 워크플로를 작성하여 XAML에 저장하려는 경우 ActivityBuilder 클래스를 사용하십시오.</value>
  </data>
  <data name="SavingFuncToXamlNotSupported" xml:space="preserve">
    <value>일반 Func&lt;T&gt;를 XAML로 저장은 지원되지 않습니다. 개체를 직렬화 가능한 Func로 변환하려면 객체를 XAML로 직렬화한 다음 ActivityXamlServices.CreateFactory를 호출하십시오.</value>
  </data>
  <data name="ScheduleBookmarkWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 BookmarkWorkItem이 예약되었습니다. BookmarkName: {3}, BookmarkScope: {4}.</value>
  </data>
  <data name="ScheduleCancelActivityWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 CancelActivityWorkItem이 예약되었습니다.</value>
  </data>
  <data name="ScheduleCompletionWorkItem" xml:space="preserve">
    <value>부모 작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 CompletionWorkItem이 예약되었습니다. 작업 '{3}', DisplayName: '{4}', InstanceId: '{5}'이(가) 완료되었습니다.</value>
  </data>
  <data name="ScheduleExecuteActivityWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 ExecuteActivityWorkItem이 예약되었습니다.</value>
  </data>
  <data name="ScheduleFaultWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 FaultWorkItem이 예약되었습니다. 작업 '{3}', DisplayName: '{4}', InstanceId: '{5}'에서 예외가 전파되었습니다.</value>
  </data>
  <data name="ScheduleRuntimeWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 런타임 작업 항목이 예약되었습니다.</value>
  </data>
  <data name="ScheduleTransactionContextWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 TransactionContextWorkItem이 예약되었습니다.</value>
  </data>
  <data name="SchemaContextFromBeforeInitializeComponentXBTExtensionCannotBeGeneric" xml:space="preserve">
    <value>BeforeInitializeComponent XAML 빌드 작업 확장({0})으로 생성된 XAML Helper 클래스 이름은 제네릭일 수 없습니다. 리소스는 BeforeInitializeComponent XAML 빌드 작업 확장으로 생성될 수 없습니다. 프로젝트를 다시 빌드해보십시오.</value>
  </data>
  <data name="SchemaContextFromBeforeInitializeComponentXBTExtensionNotFound" xml:space="preserve">
    <value>BeforeInitializeComponent XAML 빌드 작업 확장({0})으로 생성된 XAML Helper 클래스 이름을 찾을 수 없습니다. 프로젝트를 다시 빌드해보십시오.</value>
  </data>
  <data name="SeekNotSupported" xml:space="preserve">
    <value>이 스트림에서는 검색이 지원되지 않습니다.</value>
  </data>
  <data name="SendActivityCorrelationHandleNotFound" xml:space="preserve">
    <value>'{0}'(이)라는 보내기 작업과 연결된 올바른 상관 관계 핸들을 찾을 수 없습니다.</value>
  </data>
  <data name="SendMessageChannelCacheMiss" xml:space="preserve">
    <value>SendMessageChannelCache 누락</value>
  </data>
  <data name="SendMessageNeedsToPairWithReceiveMessageForTwoWayContract" xml:space="preserve">
    <value>Send 작업은 요청/회신 작업 '{0}'(으)로 구성되어 있지만 연결할 ReceiveReply 작업이 없습니다. Send와 ReceiveReply를 연결하고 CorrelationHandle을 사용하여 상관 관계를 지정하십시오.</value>
  </data>
  <data name="SendNotSupported" xml:space="preserve">
    <value>보내기가 지원되지 않습니다.</value>
  </data>
  <data name="SendParametersContentDoesNotSupportMessage" xml:space="preserve">
    <value>DisplayName='{0}'인 활동에 Message 또는 MessageContract인 '{1}' 인수가 있습니다. SendParametersContent는 Message 또는 MessageContract를 지원하지 않습니다. Message 또는 MessageContract 기반 콘텐츠에는 콘텐츠 속성을 SendMessageContent로 지정해야 합니다.</value>
  </data>
  <data name="SendReceiveExtensionNotFound" xml:space="preserve">
    <value>SendReceiveExtension을 찾을 수 없습니다. 워크플로를 호스팅하는 응용 프로그램에서 확장 구현을 제공하는지 확인하십시오.</value>
  </data>
  <data name="SendRepliesHaveSameFaultTypeDifferentAction" xml:space="preserve">
    <value>두 SendReply 활동의 오류 형식은 동일하지만 동작이 다릅니다.</value>
  </data>
  <data name="SendReplyRequestCannotBeNull" xml:space="preserve">
    <value>'{0}' 활동의 Request 속성은 null일 수 없습니다. 이 요청/회신 쌍에 속하는 Receive 활동으로 설정해야 합니다.</value>
  </data>
  <data name="SendWithUninitializedCorrelatesWith" xml:space="preserve">
    <value>작업 이름이 '{0}'인 작업에 초기화되지 않은 CorrelatesWith 핸들이 있습니다.</value>
  </data>
  <data name="SequenceDuplicateReferences" xml:space="preserve">
    <value>동일한 가져온 자식에 대한 두 개 이상의 참조가 포함된 경우 시퀀스에서 동적 업데이트가 지원되지 않습니다.</value>
  </data>
  <data name="ServiceEndpointAdded" xml:space="preserve">
    <value>주소 '{0}', 바인딩 '{1}' 및 계약 '{2}'에 대해 서비스 끝점이 추가되었습니다.</value>
  </data>
  <data name="ServiceHostExtensionAborted" xml:space="preserve">
    <value>서비스 호스트 또는 해당 확장 중 하나가 중단되었기 때문에 작업을 완료할 수 없습니다.</value>
  </data>
  <data name="ServiceHostExtensionImmutable" xml:space="preserve">
    <value>서비스 호스트가 열리기 전에만 허용되는 서비스 호스트 확장을 사용하려는 작업이 시도되었습니다.</value>
  </data>
  <data name="ServiceInstanceTerminated" xml:space="preserve">
    <value>식별자가 '{0}'인 서비스 인스턴스가 종료되었습니다.</value>
  </data>
  <data name="ServiceInstanceUnloaded" xml:space="preserve">
    <value>식별자가 '{0}'인 서비스 인스턴스가 언로드되었습니다.</value>
  </data>
  <data name="ServiceMetadataBehaviorNotFoundForServiceMetadataEndpoint" xml:space="preserve">
    <value>{0} 서비스로 구현된 계약 목록에서 이름이 'IMetadataExchange'인 계약을 찾을 수 없습니다. 구성 파일 또는 WorkflowServiceHost에 직접 ServiceMetadataBehavior를 추가하여 이 계약을 지원하도록 하십시오.</value>
  </data>
  <data name="SetupOrCleanupWorkflowThreadThrew" xml:space="preserve">
    <value>워크플로 스레드를 설정하거나 정리하는 동안 IExecutionProperty에서 예외가 발생했습니다. 자세한 내용은 내부 예외를 참조하십시오.</value>
  </data>
  <data name="SFxTaskNotStarted" xml:space="preserve">
    <value>지정된 Task 인스턴스가 아직 시작되지 않았습니다. Task 인스턴스는 작업에서 반환되기 전에 시작되어야 합니다.</value>
  </data>
  <data name="ShipAssertExceptionMessage" xml:space="preserve">
    <value>예기치 않은 오류가 발생했습니다. 이 오류는 응용 프로그램에서 처리할 수 없습니다. 오류와 관련된 다음 메시지가 진단용으로 제공됩니다. {0}.</value>
  </data>
  <data name="SimpleStateMustHaveOneTransition" xml:space="preserve">
    <value>'{0}' 상태에는 적어도 1개의 전환이 있어야 합니다.</value>
  </data>
  <data name="SpecialMethodNotFound" xml:space="preserve">
    <value>형식이 '{1}'인 특별한 메서드 '{0}'을(를) 찾을 수 없습니다.</value>
  </data>
  <data name="SqlExceptionCaught" xml:space="preserve">
    <value>SQL 예외 {0}번 메시지 {1}을(를) catch했습니다.</value>
  </data>
  <data name="StartBookmarkWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 BookmarkWorkItem의 실행을 시작합니다. BookmarkName: {3}, BookmarkScope: {4}.</value>
  </data>
  <data name="StartCancelActivityWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 CancelActivityWorkItem의 실행을 시작합니다.</value>
  </data>
  <data name="StartCompletionWorkItem" xml:space="preserve">
    <value>부모 작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 CompletionWorkItem의 실행을 시작합니다. 작업 '{3}', DisplayName: '{4}', InstanceId: '{5}'이(가) 완료되었습니다.</value>
  </data>
  <data name="StartExecuteActivityWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 ExecuteActivityWorkItem의 실행을 시작합니다.</value>
  </data>
  <data name="StartFaultWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 FaultWorkItem의 실행을 시작합니다. 작업 '{3}', DisplayName: '{4}', InstanceId: '{5}'에서 예외가 전파되었습니다.</value>
  </data>
  <data name="StartRuntimeWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 런타임 작업 항목의 실행을 시작합니다.</value>
  </data>
  <data name="StartSignpostEvent" xml:space="preserve">
    <value>작업 경계입니다.</value>
  </data>
  <data name="StartSqlCommandExecute" xml:space="preserve">
    <value>SQL 명령 실행 시작: {0}</value>
  </data>
  <data name="StartTransactionContextWorkItem" xml:space="preserve">
    <value>작업 '{0}', DisplayName: '{1}', InstanceId: '{2}'에 대해 TransactionContextWorkItem의 실행을 시작합니다.</value>
  </data>
  <data name="StateCannotBeAddedTwice" xml:space="preserve">
    <value>'{0}' 상태를 상태 시스템에 두 번 추가할 수 없습니다. 상태 시스템의 모든 상태는 고유해야 합니다.</value>
  </data>
  <data name="StateCannotBeSerialized" xml:space="preserve">
    <value>실패한 동적 업데이트가 포함되었기 때문에 인스턴스 '{0}'을(를) 실행하거나 유지할 수 없습니다. 인스턴스를 실행하려면 지속성 저장소에서 새 복사본을 다시 로드하십시오.</value>
  </data>
  <data name="StateMachineMustHaveInitialState" xml:space="preserve">
    <value>StateMachine '{0}'에 초기 상태가 있어야 합니다.</value>
  </data>
  <data name="StateNotBelongToAnyParent" xml:space="preserve">
    <value>전환 '{0}'의 대상 상태 '{1}'은(는) 상태 시스템에 속해 있어야 합니다.</value>
  </data>
  <data name="StopSignpostEvent" xml:space="preserve">
    <value>작업 경계입니다.</value>
  </data>
  <data name="StoreReportedConflictingLockTokens" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. instanceOwnerId 값은 같고 lockToken 값은 다르게 하여 BindInstanceOwner를 두 번 호출했습니다. 한 인스턴스 소유자에 대해 항상 동일한 lockToken을 사용하는 지속성 공급자를 사용하십시오.</value>
  </data>
  <data name="StoreViolationNoInstanceBound" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. LoadWorkflowByInstanceKeyCommand, LoadWorkflowCommand 또는 TryLoadRunnableWorkflowCommand를 처리하는 동안 InstanceHandle을 인스턴스에 바인딩하고 InstanceState를 설정하지 못했습니다.</value>
  </data>
  <data name="SubexpressionResultWasNotVisible" xml:space="preserve">
    <value>'{0}' 형식 개체의 하위 식으로 이 범위에서는 보이지 않는 위치 참조를 얻었습니다.</value>
  </data>
  <data name="SubexpressionResultWasNull" xml:space="preserve">
    <value>'{0}' 형식 개체의 하위 식으로 Null 값을 얻었습니다.</value>
  </data>
  <data name="SwitchCaseKeyTypesMustMatchExpressionType" xml:space="preserve">
    <value>Switch '{0}' case에 '{2}' 식 형식과 호환되지 않는 {1} 키가 있습니다.</value>
  </data>
  <data name="SwitchCaseNotFound" xml:space="preserve">
    <value>Switch 작업 '{0}'에서 Expression 결과와 일치하는 Case 작업을 찾을 수 없습니다.</value>
  </data>
  <data name="SwitchCaseNullWithValueType" xml:space="preserve">
    <value>null Case 키가 존재하지만 Switch 식의 값 형식이 '{0}'입니다. 값 형식은 null일 수 없습니다.</value>
  </data>
  <data name="SwitchCaseTypeMismatch" xml:space="preserve">
    <value>Case 키 '{0}'이(가) '{1}' 형식이 아니므로 형식이 'InArgument&lt;{1}&gt;'인 Switch 식으로 생성된 값과 일치하지 않을 수 있습니다.</value>
  </data>
  <data name="SymbolNamesMustBeUnique" xml:space="preserve">
    <value>이름이 '{0}'인 변수(RuntimeArgument 또는 DelegateArgument)가 이미 있습니다. 이름은 환경 범위 내에서 고유해야 합니다.</value>
  </data>
  <data name="SymbolResolverAlreadyExists" xml:space="preserve">
    <value>워크플로 인스턴스는 단일 SymbolResolver로만 구성할 수 있습니다. WorkflowInstanceExtensionManager에 SymbolResolver가 이미 있습니다.</value>
  </data>
  <data name="SymbolResolverDoesNotHaveSymbol" xml:space="preserve">
    <value>형식이 '{1}'인 기호 '{0}'을(를) 이 인스턴스에 대한 SymbolResolver 확장에서 찾을 수 없습니다.</value>
  </data>
  <data name="SymbolResolverMustBeSingleton" xml:space="preserve">
    <value>SymbolResolver는 인스턴스별 확장으로 사용할 수 없습니다. WorkflowInstanceExtensionManager에 SymbolResolver를 추가하려면 singletonObject 오버로드를 사용하십시오.</value>
  </data>
  <data name="TargetContractCannotBeOneWayWithTransactionFlow" xml:space="preserve">
    <value>잘못된 계약 정의: 계약 '{1}'의 작업 '{0}'에서 단방향 작업의 TransactionFlowOption이 Mandatory로 설정되어 있습니다.</value>
  </data>
  <data name="TargetTypeAndTargetObjectAreMutuallyExclusive" xml:space="preserve">
    <value>TargetType 및 TargetObject는 {0} '{1}'에서 함께 사용할 수 없습니다.</value>
  </data>
  <data name="TargetTypeCannotBeEnum" xml:space="preserve">
    <value>{0} '{1}'의 피연산자 형식은 열거 형식일 수 없습니다.</value>
  </data>
  <data name="TargetTypeIsValueType" xml:space="preserve">
    <value>피연산자 형식이 값 형식입니다. '{0}' '{1}'의 필드를 수정해도 효과가 없습니다.</value>
  </data>
  <data name="TaskTimedOutError" xml:space="preserve">
    <value>작업이 {0} 이후에 시간 초과되었습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</value>
  </data>
  <data name="TextExpressionCompilerActivityNameRequired" xml:space="preserve">
    <value>TextExpressionCompilerSettings.ActivityName을 제공해야 합니다.</value>
  </data>
  <data name="TextExpressionCompilerActivityNamespaceRequired" xml:space="preserve">
    <value>TextExpressionCompilerSettings.ActivityNamespace를 제공해야 합니다.</value>
  </data>
  <data name="TextExpressionCompilerActivityRequired" xml:space="preserve">
    <value>TextExpressionCompilerSettings.Activity를 제공해야 합니다.</value>
  </data>
  <data name="TextExpressionCompilerAddGeneratedFileRequired" xml:space="preserve">
    <value>TextExpressionCompilerSettings.AddGeneratedFile을 제공해야 합니다.</value>
  </data>
  <data name="TextExpressionCompilerLanguageRequired" xml:space="preserve">
    <value>TextExpressionCompilerSettings.Language를 제공해야 합니다.</value>
  </data>
  <data name="TextExpressionCompilerNoCodebase" xml:space="preserve">
    <value>이름 '{0}'(으)로 로드된 어셈블리에 CodeBase 값이 없습니다. 컴파일하려면 CodeBase가 필요합니다.</value>
  </data>
  <data name="TextExpressionCompilerOutputPathRequired" xml:space="preserve">
    <value>TextExpressionCompilerSettings.OutputPath를 제공해야 합니다.</value>
  </data>
  <data name="TextExpressionCompilerUnableToLoadAssembly" xml:space="preserve">
    <value>어셈블리 '{0}'을(를) 로드할 수 없습니다.</value>
  </data>
  <data name="TextExpressionMetadataRequiresCompilation" xml:space="preserve">
    <value>식 작업 형식 '{0}'을(를) 실행하려면 컴파일해야 합니다. 워크플로가 컴파일되었는지 확인하십시오.</value>
  </data>
  <data name="ThreadNeutralSemaphoreAborted" xml:space="preserve">
    <value>ThreadNeutralSemaphore가 중단되었습니다.</value>
  </data>
  <data name="ThrowingEtwException" xml:space="preserve">
    <value>예외가 발생하는 중입니다. 원본: {0}. 예외 정보: {1}</value>
  </data>
  <data name="ThrowingEtwExceptionVerbose" xml:space="preserve">
    <value>예외가 발생하는 중입니다. 원본: {0}. 예외 정보: {1}</value>
  </data>
  <data name="ThrowingException" xml:space="preserve">
    <value>예외가 발생하는 중입니다. 원본 {0}. 예외 정보: {1}</value>
  </data>
  <data name="ThrowingExceptionVerbose" xml:space="preserve">
    <value>예외가 발생하는 중입니다. 원본: {0}. 예외 정보: {1}</value>
  </data>
  <data name="TimedOutWaitingForLockResolution" xml:space="preserve">
    <value>지속성 공급자가 정해진 시간 제한 내에 잠금을 다시 얻지 못했습니다. 같은 InstanceOwner가 소유한 여러 InstanceHandle에서 동시에 실행 중인 명령 패턴에 교착 상태가 발생했을 수 있습니다. 여러 InstanceOwner를 사용하거나 인스턴스를 잠글 가능성이 없는 명령에 대해 InstancePersistenceCommand.AutomaticallyAcquiringLock이 false를 반환하도록 하여 상태를 완화할 수 있습니다.</value>
  </data>
  <data name="TimeoutInputQueueDequeue" xml:space="preserve">
    <value>{0} 후에 Dequeue 작업 시간이 초과되었습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</value>
  </data>
  <data name="TimeoutMustBeNonNegative" xml:space="preserve">
    <value>{0} 인수는 음수가 아닌 시간 제한 값이어야 합니다. 제공된 값은 {1}입니다.</value>
  </data>
  <data name="TimeoutMustBePositive" xml:space="preserve">
    <value>{0} 인수는 양의 시간 제한 값이어야 합니다. 제공된 값은 {1}입니다.</value>
  </data>
  <data name="TimeoutOnOperation" xml:space="preserve">
    <value>할당된 시간 제한({0}) 내에 작업이 완료되지 않았습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</value>
  </data>
  <data name="TimeoutOnSqlOperation" xml:space="preserve">
    <value>할당된 시간 제한인 {0} 내에 작업을 완료하지 못했습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</value>
  </data>
  <data name="TimeoutOpeningSqlConnection" xml:space="preserve">
    <value>SQL 연결을 여는 동안 시간이 초과되었습니다. 할당된 시간 제한인 {0} 내에 작업을 완료하지 못했습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</value>
  </data>
  <data name="TimerExtensionAlreadyAttached" xml:space="preserve">
    <value>이 TimerExtension이 워크플로 인스턴스에 이미 연결되었습니다.</value>
  </data>
  <data name="TimerExtensionRequiresWorkflowInstance" xml:space="preserve">
    <value>TimerExtension은 워크플로 인스턴스에 연결된 상태에서만 사용할 수 있습니다.</value>
  </data>
  <data name="TooManyViolationsForExceptionMessage" xml:space="preserve">
    <value>&lt;잘림&gt; 예외 메시지가 너무 커서 잘렸습니다. 모든 위반 사항을 보려면 ActivityValidationServices를 사용하십시오.</value>
  </data>
  <data name="TraceCodeEventLogCritical" xml:space="preserve">
    <value>EventLog에 기록합니다.</value>
  </data>
  <data name="TraceCodeEventLogError" xml:space="preserve">
    <value>EventLog에 기록합니다.</value>
  </data>
  <data name="TraceCodeEventLogInfo" xml:space="preserve">
    <value>EventLog에 기록합니다.</value>
  </data>
  <data name="TraceCodeEventLogVerbose" xml:space="preserve">
    <value>EventLog에 기록합니다.</value>
  </data>
  <data name="TraceCodeEventLogWarning" xml:space="preserve">
    <value>EventLog에 기록합니다.</value>
  </data>
  <data name="TraceCorrelationKeys" xml:space="preserve">
    <value>부모 범위 '{2}'에서 '{1}' 값을 사용하여 상관 관계 키 '{0}'을(를) 계산했습니다.</value>
  </data>
  <data name="TrackingDataExtracted" xml:space="preserve">
    <value>추적 데이터 {0}이(가) {1} 작업에서 추출되었습니다.</value>
  </data>
  <data name="TrackingProfileNotFound" xml:space="preserve">
    <value>ActivityDefinitionId '{1}'에 대한 TrackingProfile '{0}'을(를) 찾을 수 없습니다. 구성 파일에 TrackingProfile이 없거나 ActivityDefinitionId가 일치하지 않습니다.</value>
  </data>
  <data name="TrackingRecordDropped" xml:space="preserve">
    <value>추적 레코드 {0}의 크기가 {1} 공급자의 ETW 세션에서 허용된 최대값을 초과합니다.</value>
  </data>
  <data name="TrackingRecordRaised" xml:space="preserve">
    <value>추적 레코드 {0}이(가) {1}(으)로 증가했습니다.</value>
  </data>
  <data name="TrackingRecordTruncated" xml:space="preserve">
    <value>잘린 추적 레코드 {0}이(가) 공급자가 {1}인 ETW 세션에 기록되었습니다. 변수/주석/사용자 데이터가 제거되었습니다.</value>
  </data>
  <data name="TrackingRelatedWorkflowAbort" xml:space="preserve">
    <value>인스턴스를 중단시키는 추적 참석자를 호출하는 동안 오류가 발생했습니다. 자세한 내용은 내부 예외를 참조하십시오.</value>
  </data>
  <data name="TrackingValueNotSerializable" xml:space="preserve">
    <value>추출된 인수/변수 '{0}'은(는) 직렬화할 수 없습니다.</value>
  </data>
  <data name="TransactedReceiveScopeEndCommitFailed" xml:space="preserve">
    <value>ID = '{0}'인 CommittableTransaction에 대한 EndCommit 호출에서 다음 메시지와 함께 TransactionException이 발생했습니다. '{1}'.</value>
  </data>
  <data name="TransactedReceiveScopeMustHaveValidReceive" xml:space="preserve">
    <value>TransactedReceiveScope '{0}'의 Request 속성은 올바른 Receive 작업으로 설정되어야 합니다.</value>
  </data>
  <data name="TransactedReceiveScopeRequiresReceive" xml:space="preserve">
    <value>TransactedReceiveScope '{0}'을(를) 사용하려면 먼저 ReceiveActivity 속성을 설정해야 합니다.</value>
  </data>
  <data name="TransactionHandleAlreadyHasTransaction" xml:space="preserve">
    <value>TransactionHandle에 트랜잭션이 이미 있습니다. 새 트랜잭션을 구성할 수 없습니다.</value>
  </data>
  <data name="TransactionInDoubtNonHost" xml:space="preserve">
    <value>InstanceStore.Execute 또는 BeginExecute가 호출되었을 때 앰비언트 트랜잭션은 없었지만 명령 처리에 내부 트랜잭션이 사용되었습니다. 내부 트랜잭션이 InDoubt 상태가 되었습니다.</value>
  </data>
  <data name="TransactionPersistenceTimeout" xml:space="preserve">
    <value>다른 트랜잭션에서 인스턴스를 잠가서 시간이 초과되었습니다.</value>
  </data>
  <data name="TransactionRolledBackNonHost" xml:space="preserve">
    <value>InstanceStore.Execute 또는 BeginExecute가 호출되었을 때 앰비언트 트랜잭션은 없었지만 명령 처리에 내부 트랜잭션이 사용되었습니다. 내부 트랜잭션이 중단되었습니다.</value>
  </data>
  <data name="TransitionCannotBeAddedTwice" xml:space="preserve">
    <value>'{0}' 전환은 '{2}' 상태에 추가되어 있으므로 '{1}' 상태에 추가할 수 없습니다.</value>
  </data>
  <data name="TransitionTargetCannotBeNull" xml:space="preserve">
    <value>'{1}' 상태의 '{0}' 전환에 대한 'To' 속성은 null이 아니어야 합니다.</value>
  </data>
  <data name="TriggerOrConditionChangedDuringTransitioning" xml:space="preserve">
    <value>실행 중인 전환의 Trigger 또는 Condition 작업이 변경된 경우 StateMachine은 동적 업데이트를 지원하지 않습니다.</value>
  </data>
  <data name="TriggerOrConditionIsReferenced" xml:space="preserve">
    <value>Trigger 또는 Condition이 가져온 자식에 대한 참조인 경우 StateMachine은 동적 업데이트를 지원하지 않습니다.</value>
  </data>
  <data name="TryCatchExceptionDuringCancelation" xml:space="preserve">
    <value>취소하는 동안 TryCatch 작업 '{0}'의 자식 작업에서 예외가 발생했습니다.</value>
  </data>
  <data name="TryCatchExceptionFromCatchOrFinally" xml:space="preserve">
    <value>TryCatch 작업 '{0}'에 연결된 Catch 또는 Finally 작업에서 예외가 발생했습니다.</value>
  </data>
  <data name="TryCatchExceptionFromTry" xml:space="preserve">
    <value>TryCatch 작업 '{0}'에서 '{1}' 형식의 예외를 catch했습니다.</value>
  </data>
  <data name="TryCatchInvalidStateForUpdate" xml:space="preserve">
    <value>'{0}' 형식의 예외가 catch되었지만 일치하는 catch 블록이 제거되었기 때문에 TryCatch 내에서 업데이트할 수 없습니다.</value>
  </data>
  <data name="TryCommandCannotExecuteSubCommandsAndReduce" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 InstancePersistenceContext.Execute(또는 BeginExecute)를 사용하여 중첩된 명령을 실행한 후에 TryCommand(또는 EndTryCommand)에서 false를 반환했습니다. 지속성 공급자가 명령을 인식하고 실행하는 경우 true를 반환해야 합니다.</value>
  </data>
  <data name="TryLoadRequiresOwner" xml:space="preserve">
    <value>WorkflowApplication.LoadRunnableInstance 작업에는 명시적으로 생성된 InstanceOwner가 필요합니다. 이 메서드를 사용하려면 워크플로 호스트 형식을 사용하는 인스턴스 소유자를 만들어 InstanceStore의 DefaultInstanceOwner로 설정하십시오.</value>
  </data>
  <data name="TryLoadRequiresWorkflowType" xml:space="preserve">
    <value>저장소에 실행 가능한 인스턴스를 찾아 로드하려면 요청한 InstanceOwner를 만들 때 워크플로 호스트 형식을 지정해야 합니다. 이렇게 하려면 명령을 실행할 때 키-값 쌍을 CreateWorkflowOwnerCommand.InstanceOwnerMetadata 속성 모음에 추가하십시오. 키는 해당 문서에 제공된 WorkflowHostType 키입니다. 값은 XName이어야 하며 로드되는 인스턴스의 값과 일치해야 합니다.</value>
  </data>
  <data name="TryRegisterRequestContextFailed" xml:space="preserve">
    <value>상관 관계 처리기의 일부 컨텍스트가 올바르게 사용되지 않았습니다. 런타임에서 처리기가 올바르게 초기화되었고 워크플로에서 Send 이후 Receive 또는 ReceiveReply 작업이 수행되는지 확인하십시오.</value>
  </data>
  <data name="TwoReceiveParametersWithSameNameButDifferentParameterCount" xml:space="preserve">
    <value>ServiceContractName 및 OperationName '{0}'이(가) 같은 두 ReceiveParametersContent 개체의 매개 변수 개수가 다릅니다.</value>
  </data>
  <data name="TwoReceiveParametersWithSameNameButDifferentParameterName" xml:space="preserve">
    <value>ServiceContractName 및 OperationName '{0}'이(가) 같은 두 ReceiveParametersContent 개체의 매개 변수 이름이 다릅니다.</value>
  </data>
  <data name="TwoReceiveParametersWithSameNameButDifferentParameterType" xml:space="preserve">
    <value>ServiceContractName 및 OperationName '{0}'이(가) 같은 두 ReceiveParametersContent 개체의 매개 변수 형식이 다릅니다.</value>
  </data>
  <data name="TwoReceivesWithSameNameButDifferentAction" xml:space="preserve">
    <value>ServiceContractName 및 OperationName '{0}'이(가) 같은 두 Receive 개체의 동작이 다릅니다.</value>
  </data>
  <data name="TwoReceivesWithSameNameButDifferentIsOneWay" xml:space="preserve">
    <value>ServiceContractName 및 OperationName'{0}'이(가) 같은 두 Receive 개체의 IsOneWay 값이 다릅니다.</value>
  </data>
  <data name="TwoReceivesWithSameNameButDifferentTxProperties" xml:space="preserve">
    <value>ServiceContractName과 OperationName('{0}')이 동일한 두 Receive 개체의 트랜잭션 속성이 서로 다릅니다.</value>
  </data>
  <data name="TwoReceivesWithSameNameButDifferentValueType" xml:space="preserve">
    <value>ServiceContractName 및 OperationName '{0}'이(가) 같은 두 Receive 개체의 ValueType이 다릅니다.</value>
  </data>
  <data name="TwoSendRepliesWithSameNameButDifferentAction" xml:space="preserve">
    <value>ServiceContractName 및 OperationName '{0}'이(가) 같은 두 SendReply 개체의 동작이 다릅니다.</value>
  </data>
  <data name="TwoSendRepliesWithSameNameButDifferentValueType" xml:space="preserve">
    <value>ServiceContractName 및 OperationName '{0}'이(가) 같은 두 SendReply 개체의 ValueType이 다릅니다.</value>
  </data>
  <data name="TwoSendReplyParametersWithSameNameButDifferentParameterCount" xml:space="preserve">
    <value>ServiceContractName 및 OperationName '{0}'이(가) 같은 두 SendParametersContent 개체의 매개 변수 개수가 다릅니다.</value>
  </data>
  <data name="TwoSendReplyParametersWithSameNameButDifferentParameterName" xml:space="preserve">
    <value>ServiceContractName 및 OperationName '{0}'이(가) 같은 두 SendParameters 개체의 매개 변수 이름이 다릅니다.</value>
  </data>
  <data name="TwoSendReplyParametersWithSameNameButDifferentParameterType" xml:space="preserve">
    <value>ServiceContractName 및 OperationName '{0}'이(가) 같은 두 SendParameters 개체의 매개 변수 형식이 다릅니다.</value>
  </data>
  <data name="TwoWayIsImplementedAsOneWay" xml:space="preserve">
    <value>계약 '{1}'의 작업 '{0}'이(가) 양방향으로 지정되어 있지만 SendReply가 누락되었습니다. 작업에 대해 SendReply 작업을 추가하십시오.</value>
  </data>
  <data name="TypeConverterHelperCacheAddFailed" xml:space="preserve">
    <value>'{0}' 형식의 TypeConverterHelper를 도우미의 내부 캐시에 추가하지 못했습니다.</value>
  </data>
  <data name="TypeMismatchForAssign" xml:space="preserve">
    <value>Assign 작업 '{2}'에서 '{0}' 형식을 '{1}' 형식에 할당할 수 없습니다.</value>
  </data>
  <data name="TypeMustbeValueType" xml:space="preserve">
    <value>'{0}' 형식은 값 형식이어야 합니다.</value>
  </data>
  <data name="TypeNotAssignableTo" xml:space="preserve">
    <value>{0}은(는) {1}에 할당할 수 없습니다.</value>
  </data>
  <data name="UnableToDeserializeHttpResponseContent" xml:space="preserve">
    <value>'{0}' 형식의 ResponseContent를 역직렬화할 수 없습니다.</value>
  </data>
  <data name="UnableToLocateCompiledLocationContext" xml:space="preserve">
    <value>컴파일된 위치 '{0}'의 ICompiledExpressionRoot를 찾을 수 없습니다. 이 식이 포함된 작업에 대한 정의가 컴파일되었는지 확인하십시오.</value>
  </data>
  <data name="UnableToOpenAndRegisterStore" xml:space="preserve">
    <value>InstanceStore를 초기화할 수 없습니다.</value>
  </data>
  <data name="UnconditionalTransitionShouldNotShareNullTriggersWithOthers" xml:space="preserve">
    <value>'{1}' 상태의 트리거 없는 전환 '{0}'에 조건이 포함되어야 합니다. 상태에는 트리거가 없는 비조건부 전환이 하나만 있을 수 있습니다.</value>
  </data>
  <data name="UnconditionalTransitionShouldNotShareTriggersWithOthers" xml:space="preserve">
    <value>'{1}' 상태의 '{0}' 전환이 비조건부 전환입니다. 이 전환은 다른 전환과 동일한 트리거 '{2}'을(를) 공유할 수 없습니다.</value>
  </data>
  <data name="UnexpectedArgumentCount" xml:space="preserve">
    <value>필요한 수는 '{2}'인데 '{0}' 컬렉션에 지정된 인수 개수는 '{1}'입니다. </value>
  </data>
  <data name="UnexpectedExpressionNodeType" xml:space="preserve">
    <value>'{0}' 형식의 식 노드가 필요한데 '{1}' 형식의 식 노드가 사용되었습니다.</value>
  </data>
  <data name="UnhandledException" xml:space="preserve">
    <value>처리되지 않은 예외가 발생했습니다. 예외 정보: {0}</value>
  </data>
  <data name="UninitializedCannotHaveData" xml:space="preserve">
    <value>사용 중인 InstanceStore의 지속성 공급자 구현이 잘못되었습니다. 이 구현에서 인스턴스 데이터가 포함되고 InstanceState.Uninitialized로 설정된 인스턴스를 로드한다고 보고했습니다. 초기화되지 않은 인스턴스는 인스턴스 데이터를 포함할 수 없습니다.</value>
  </data>
  <data name="UnInitializedRuntimeTransactionHandle" xml:space="preserve">
    <value>지정된 RuntimeTransactionHandle이 올바르게 초기화되지 않았습니다.</value>
  </data>
  <data name="UnknownCompressionOption" xml:space="preserve">
    <value>요청한 압축 옵션 {0}은(는) 올바른 옵션이 아닙니다.</value>
  </data>
  <data name="UnknownDatabaseVersion" xml:space="preserve">
    <value>System.Activities.DurableInstancing.SqlWorkflowInstanceStoreVersionTable에서 행을 찾을 수 없기 때문에 데이터베이스의 버전을 확인할 수 없습니다. 이 테이블은 테이블이 만들어졌거나 업그레이드된 프레임워크의 버전에 해당하는 단일 행이 포함되어야 합니다.</value>
  </data>
  <data name="UnknownExpressionCompilationError" xml:space="preserve">
    <value>"{0}" 식을 처리하는 동안 알 수 없는 오류가 발생했습니다. 식 텍스트를 처리하면 예외가 발생하지 않지만 실행 가능한 식도 만들지 않습니다.</value>
  </data>
  <data name="UnknownLanguage" xml:space="preserve">
    <value>'{0}'을(를) 식의 언어로 사용할 수 없습니다.</value>
  </data>
  <data name="UnknownSprocResult" xml:space="preserve">
    <value>저장 프로시저에서 알 수 없는 실행 결과 {0}을(를) 반환했습니다.</value>
  </data>
  <data name="UnlockInstanceException" xml:space="preserve">
    <value>인스턴스 잠금을 해제하는 동안 {0} 예외가 발생했습니다.</value>
  </data>
  <data name="UnmatchedNoPersistExit" xml:space="preserve">
    <value>NoPersistHandle에 일치하지 않는 Exit이 있습니다. Exit은 각각의 들어가는 동작에 대해 한 번만 호출할 수 있습니다.</value>
  </data>
  <data name="UnopenedActivitiesCannotBeExecuted" xml:space="preserve">
    <value>열려 있는 작업만 실행할 수 있습니다. 작업 '{0}'은(는) 열려 있지 않습니다.</value>
  </data>
  <data name="UnsupportedExpressionType" xml:space="preserve">
    <value>'{0}' 형식의 식은 지원되지 않습니다.</value>
  </data>
  <data name="UnsupportedLocationReferenceValue" xml:space="preserve">
    <value>LocationReference 값은 변수 Runtimeargument 또는 DelegateArgument여야 합니다.</value>
  </data>
  <data name="UnsupportedMemberExpressionWithType" xml:space="preserve">
    <value>'{0}' 형식의 멤버를 검색하는 MemberExpression은 지원되지 않습니다.</value>
  </data>
  <data name="UnsupportedReferenceExpressionType" xml:space="preserve">
    <value>'{0}' 형식의 식은 LValue에 지원되지 않습니다.</value>
  </data>
  <data name="UnusedInputArguments" xml:space="preserve">
    <value>입력 사전에서 가져온 키 {0}이(가) 인수에 매핑되지 않으며 제거해야 합니다. 인수 이름이 대/소문자를 구분하는지 확인하십시오.</value>
  </data>
  <data name="UnwrappedMessageNotSupported" xml:space="preserve">
    <value>래핑 해제된 메시지는 MessageContracts를 사용해서만 지원됩니다. 구현된 계약 '{1}'의 작업 '{0}'에 대해 MessageContract 형식을 사용하십시오.</value>
  </data>
  <data name="UpdateDefinitionNotFound" xml:space="preserve">
    <value>WorkflowIdentity '{0}'이(가) 호스팅된 WorkflowServices와 일치하지 않습니다.</value>
  </data>
  <data name="UpdateMapBuilderRequiredProperty" xml:space="preserve">
    <value>DynamicUpdateMapBuilder에 대한 속성 '{0}'을(를) 설정해야 합니다.</value>
  </data>
  <data name="UpdateMapNotFound" xml:space="preserve">
    <value>WorkflowIdentity '{0}'을(를) '{1}'(으)로 업데이트하기 위해 사용할 수 있는 DynamicUpdateMap이 없습니다.</value>
  </data>
  <data name="UpdateSymbolsMustMatch" xml:space="preserve">
    <value>원본 워크플로와 업데이트된 워크플로는 외부 기호의 개수, 이름, 형식 및 순서가 동일해야 합니다.</value>
  </data>
  <data name="UriBaseMustBeSpecified" xml:space="preserve">
    <value>작업 '{0}'에서 UriBase 인수를 지정해야 합니다.</value>
  </data>
  <data name="UseInstanceStoreInsteadOfPersistenceProvider" xml:space="preserve">
    <value>System.ServiceModel.Activities.WorkflowServiceHost가 System.ServiceModel.Persistence.PersistenceProviderBehavior와 호환되지 않습니다. PersistenceProviderBehavior 또는 파생된 클래스(예: SqlPersistenceProviderBehavior)를 제거해야 합니다. WorkflowServiceHost로 지속성을 설정하려면 System.Runtime.DurableInstancing.InstanceStore를 설치하는 동작을 대신 사용해야 합니다(예: SqlInstanceStoreBehavior).</value>
  </data>
  <data name="ValidateUnlockInstance" xml:space="preserve">
    <value>인스턴스 지속성 시스템은 잘못된 InstancePersistenceCommand를 처리할 수 없습니다. CompleteInstance 속성이 true로 설정된 경우 이 명령을 실행하려면 UnlockInstance 속성을 true로 설정해야 합니다.</value>
  </data>
  <data name="ValidationContextCannotBeNull" xml:space="preserve">
    <value>이름이 '{1}'인 {0}의 ToValidateContext 인수가 null로 확인되었습니다. null이 아닌 유효성 검사 컨텍스트 개체를 제공해야 합니다.</value>
  </data>
  <data name="ValidationErrorPrefixForHiddenActivity" xml:space="preserve">
    <value>'{0}' 작업의 전용 구현에 다음과 같은 유효성 검사 오류가 있습니다.   </value>
  </data>
  <data name="ValidationErrorPrefixForPublicActivityWithHiddenParent" xml:space="preserve">
    <value>'{0}' 작업의 전용 구현 중 '{1}' 작업에 다음과 같은 유효성 검사 오류가 있습니다.   </value>
  </data>
  <data name="ValueArgumentTypeNotDerivedFromValueType" xml:space="preserve">
    <value>메시지의 ArgumentType이 OperationName='{1}'인 '{0}' 작업의 DeclaredMessageType에서 파생된 형식이 아닙니다.</value>
  </data>
  <data name="ValueCannotBeNegative" xml:space="preserve">
    <value>'{0}'은(는) 0보다 크거나 같아야 합니다.</value>
  </data>
  <data name="ValueCannotBeNull" xml:space="preserve">
    <value>Content 속성은 OperationName='{1}'인 '{0}' 활동에서 설정해야 합니다.</value>
  </data>
  <data name="ValueCollectionUpdatesNotAllowed" xml:space="preserve">
    <value>사전에서 파생된 값 컬렉션은 변경할 수 없습니다.</value>
  </data>
  <data name="ValueMustBeAssignableToType" xml:space="preserve">
    <value>제공된 값은 제공된 형식에 할당할 수 있어야 합니다.</value>
  </data>
  <data name="ValueMustBeNonNegative" xml:space="preserve">
    <value>값은 음수가 아니어야 합니다.</value>
  </data>
  <data name="ValueTooLarge" xml:space="preserve">
    <value>Int32.MaxValue보다 큰 '{0}'은(는) 허용되지 않습니다. 시간 제한을 사용하지 않으려면 TimeSpan.MaxValue를 지정하십시오.</value>
  </data>
  <data name="VariableAlreadyInUseOnActivity" xml:space="preserve">
    <value>'{0}' 변수는 작업 '{2}'에서 이미 사용 중이므로 작업 '{1}'에서 사용할 수 없습니다.</value>
  </data>
  <data name="VariableCannotBePopulatedInLocationEnvironment" xml:space="preserve">
    <value>{0} 변수는 LocationEnvironment에 채울 수 없습니다.</value>
  </data>
  <data name="VariableDoesNotExist" xml:space="preserve">
    <value>'{0}' 변수가 이 환경에 없습니다.</value>
  </data>
  <data name="VariableExpressionTypeMismatch" xml:space="preserve">
    <value>'{0}' 변수의 기본값에 '{1}' 형식이 필요한데 결과 형식이 '{2}'인 작업이 제공되었습니다.</value>
  </data>
  <data name="VariableIsReadOnly" xml:space="preserve">
    <value>'{0}' 변수는 읽기 전용이므로 수정할 수 없습니다.</value>
  </data>
  <data name="VariableMustBeSet" xml:space="preserve">
    <value>CacheMetadata을 호출하기 전에 변수를 설정해야 합니다.</value>
  </data>
  <data name="VariableNameNotAnIdentifier" xml:space="preserve">
    <value>변수 이름 '{0}'이(가) 올바른 식별자를 나타내지 않으므로 해당 이름을 직렬화할 수 없습니다.</value>
  </data>
  <data name="VariableNotOpen" xml:space="preserve">
    <value>형식이 '{1}'인 '{0}' 변수를 사용할 수 없습니다. 해당 변수가 Activity 또는 SymbolResolver에 선언되었는지 확인하십시오.</value>
  </data>
  <data name="VariableNotVisible" xml:space="preserve">
    <value>참조된 Variable 개체(이름 = '{0}')가 이 범위에서 표시되지 않습니다. 이 범위에서 표시되는 같은 이름의 다른 위치 참조가 있을 수 있지만 동일 위치를 참조하지는 않습니다.</value>
  </data>
  <data name="VariableOnlyAccessibleAtScopeOfDeclaration" xml:space="preserve">
    <value>'{0}' 작업은 '{1}' 작업의 범위에서 선언되었으므로 이 변수에 액세스할 수 없습니다. 작업은 자체 구현 변수에만 액세스할 수 있습니다.</value>
  </data>
  <data name="VariableOrArgumentAdditionToReferencedEnvironmentNoDUSupported" xml:space="preserve">
    <value>보정 처리기 또는 확인 처리기에서 참조할 수 있는 이미 완료된 작업에 변수 또는 인수를 추가하는 것은 지원되지 않습니다.</value>
  </data>
  <data name="VariableOrArgumentDoesNotExist" xml:space="preserve">
    <value>변수 또는 인수 '{0}'이(가) 이 환경에 없습니다.</value>
  </data>
  <data name="VariableShouldBeOpen" xml:space="preserve">
    <value>'{0}' 변수를 사용하려면 먼저 작업에 포함되어 있어야 합니다.</value>
  </data>
  <data name="VariableTypeInvalid" xml:space="preserve">
    <value>'{0}' 변수의 '{2}' 형식은 호환되지 않으므로 '{1}' 형식의 식에서 해당 변수를 사용할 수 없습니다.</value>
  </data>
  <data name="VariableTypeNotMatchLocationType" xml:space="preserve">
    <value>변수 형식 '{0}'이(가) Location 형식 '{1}'과(와) 일치하지 않습니다.</value>
  </data>
  <data name="ExpressionTamperedSinceLastCompiled" xml:space="preserve">
    <value>식 텍스트 또는 이 텍스트에 표시된 LocationReferenceEnvironment가 캐시된 이후에 변경되어 GetExpressionTree에서 식 트리를 가져오지 못했습니다. 컴파일 오류 메시지: {0}.</value>
  </data>
  <data name="WaitAlreadyInProgress" xml:space="preserve">
    <value>InstanceHandle에 한번에 처리되지 않은 WaitForEvents 또는 BeginWaitForEvents 작업이 하나 이상 진행 중일 수 있습니다. 두 번째 작업이 시도되었습니다. 이전 작업이 완료되면 WaitForEvents/BeginWaitForEvents를 호출하십시오.</value>
  </data>
  <data name="WaitForEventsTimedOut" xml:space="preserve">
    <value>{0} 후에 WaitForEvents 또는 BeginWaitForEvents 작업 시간이 초과되었습니다. 이 작업에 할당된 시간이 보다 긴 시간 제한의 일부일 수 있습니다.</value>
  </data>
  <data name="WDCDisposed" xml:space="preserve">
    <value>WorkflowDataContext는 가져온 작업 범위 내에서만 액세스할 수 있습니다.</value>
  </data>
  <data name="WfMessageReceived" xml:space="preserve">
    <value>워크플로가 메시지를 수신함</value>
  </data>
  <data name="WfMessageSent" xml:space="preserve">
    <value>워크플로에서 메시지가 전송됨</value>
  </data>
  <data name="WhileRequiresCondition" xml:space="preserve">
    <value>While 작업 '{0}'을(를) 사용하려면 먼저 조건을 설정해야 합니다.</value>
  </data>
  <data name="WindowsGroupNotFound" xml:space="preserve">
    <value>Windows 그룹 '{0}'을(를) 찾을 수 없습니다.</value>
  </data>
  <data name="WorkflowAbortedReason" xml:space="preserve">
    <value>{0} InnerException 메시지: {1}</value>
  </data>
  <data name="WorkflowActivityResume" xml:space="preserve">
    <value>WorkflowInstance Id: '{0}' E2E 작업</value>
  </data>
  <data name="WorkflowActivityStart" xml:space="preserve">
    <value>WorkflowInstance Id: '{0}' E2E 작업</value>
  </data>
  <data name="WorkflowActivityStop" xml:space="preserve">
    <value>WorkflowInstance Id: '{0}' E2E 작업</value>
  </data>
  <data name="WorkflowActivitySuspend" xml:space="preserve">
    <value>WorkflowInstance Id: '{0}' E2E 작업</value>
  </data>
  <data name="WorkflowApplicationAborted" xml:space="preserve">
    <value>WorkflowApplication {0}이(가) 중단되었기 때문에 작업을 수행할 수 없습니다.</value>
  </data>
  <data name="WorkflowApplicationAlreadyHasId" xml:space="preserve">
    <value>'Id' 속성을 읽었기 때문에 WorkflowApplication에 대해 인스턴스 ID가 생성되었습니다. ID가 생성된 후에는 인스턴스를 로드하는 데 WorkflowApplication을 사용할 수 없습니다.</value>
  </data>
  <data name="WorkflowApplicationCompleted" xml:space="preserve">
    <value>WorkflowInstance Id: '{0}'이(가) Closed 상태로 완료되었습니다.</value>
  </data>
  <data name="WorkflowApplicationIdled" xml:space="preserve">
    <value>WorkflowApplication ID: '{0}'이(가) 유휴 상태로 되었습니다.</value>
  </data>
  <data name="WorkflowApplicationInstanceAbandoned" xml:space="preserve">
    <value>이 WorkflowApplicationInstance는 이미 중단되었거나 중단 중인 상태입니다. 추가 작업을 수행할 수 없습니다.</value>
  </data>
  <data name="WorkflowApplicationInstanceLoaded" xml:space="preserve">
    <value>이 WorkflowApplicationInstance는 이미 WorkflowApplication과 연결되어 있습니다. 인스턴스를 제어하려면 해당 WorkflowApplication을 사용하십시오.</value>
  </data>
  <data name="WorkflowApplicationPersistableIdle" xml:space="preserve">
    <value>WorkflowApplication ID: '{0}'이(가) 유휴 상태로 지속됩니다. 다음 동작이 수행됩니다. {1}.</value>
  </data>
  <data name="WorkflowApplicationPersisted" xml:space="preserve">
    <value>WorkflowApplication ID: '{0}'이(가) 지속 상태가 되었습니다.</value>
  </data>
  <data name="WorkflowApplicationTerminated" xml:space="preserve">
    <value>WorkflowApplication ID: '{0}'이(가) 종료되었습니다. 예외가 발생하여 오류 상태로 완료되었습니다.</value>
  </data>
  <data name="WorkflowApplicationUnhandledException" xml:space="preserve">
    <value>WorkflowInstance ID: '{0}'에서 처리되지 않은 예외가 발생했습니다. 이 예외는 작업 '{1}', DisplayName: '{2}'에서 시작되었습니다. 다음 작업이 수행됩니다. {3}.</value>
  </data>
  <data name="WorkflowApplicationUnloaded" xml:space="preserve">
    <value>WorkflowInstance Id: '{0}'이(가) 언로드되었습니다.</value>
  </data>
  <data name="WorkflowBehaviorWithNonWorkflowHost" xml:space="preserve">
    <value>'{0}' 동작은 WorkflowServiceHost에 적용해야 합니다.</value>
  </data>
  <data name="WorkflowCompletionAsyncResultCannotBeNull" xml:space="preserve">
    <value>OnBeginWorkflowCompleted에서 반환된 AsyncResult는 null일 수 없습니다.</value>
  </data>
  <data name="WorkflowControlEndpointDefaultBaseUriNotSupportedInPartialTrust" xml:space="preserve">
    <value>WorkflowControlEndpoint.DefaultBaseUri의 기본값은 부분 신뢰에서 지원되지 않습니다. 구성 또는 기본이 아닌 생성자를 사용하여 WorkflowControlEndpoint에 대한 바인딩 및 주소를 지정하십시오.</value>
  </data>
  <data name="WorkflowIdentityNullHostId" xml:space="preserve">
    <value>WorkflowIdentity('{0}')로 유지된 인스턴스를 WorkflowIdentity가 지정되지 않은 호스트에 로드할 수 없습니다.</value>
  </data>
  <data name="WorkflowIdentityNullStateId" xml:space="preserve">
    <value>WorkflowIdentity 없이 유지된 인스턴스를 WorkflowIdentity('{0}')가 지정된 호스트에 로드할 수 없습니다. 다른 정의를 사용하여 인스턴스를 로드하거나 동적 업데이트를 사용하여 업데이트할 수 있습니다.</value>
  </data>
  <data name="WorkflowIdentityStateIdHostIdMismatch" xml:space="preserve">
    <value>로드된 인스턴스의 WorkflowIdentity('{0}')가 제공된 워크플로 정의의 WorkflowIdentity('{1}')와 일치하지 않습니다. 다른 정의를 사용하여 인스턴스를 로드하거나 동적 업데이트를 사용하여 업데이트할 수 있습니다.</value>
  </data>
  <data name="WorkflowInstanceAborted" xml:space="preserve">
    <value>WorkflowInstance '{0}'이(가) 중단되었으므로 작업을 수행할 수 없습니다.</value>
  </data>
  <data name="WorkflowInstanceAbortedRecordWithId" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceAbortedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}</value>
  </data>
  <data name="WorkflowInstanceCanceled" xml:space="preserve">
    <value>WorkflowInstance Id: '{0}'이(가) Canceled 상태로 완료되었습니다.</value>
  </data>
  <data name="WorkflowInstanceCompleted" xml:space="preserve">
    <value>WorkflowInstance '{0}'이(가) 완료되었으므로 작업을 수행할 수 없습니다.</value>
  </data>
  <data name="WorkflowInstanceIsReadOnly" xml:space="preserve">
    <value>실행이 시작된 후에는 WorkflowInstance '{0}'을(를) 수정할 수 없습니다.</value>
  </data>
  <data name="WorkflowInstanceNotFoundInStore" xml:space="preserve">
    <value>인스턴스 저장소에서 '{0}' 인스턴스를 찾았지만, 인스턴스에 워크플로가 들어 있지 않습니다.</value>
  </data>
  <data name="WorkflowInstanceRecordWithId" xml:space="preserve">
    <value>TrackRecord= WorkflowInstanceRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, State = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}</value>
  </data>
  <data name="WorkflowInstanceSuspendedRecord" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceSuspendedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}</value>
  </data>
  <data name="WorkflowInstanceSuspendedRecordWithId" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceSuspendedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}</value>
  </data>
  <data name="WorkflowInstanceTerminated" xml:space="preserve">
    <value>WorkflowInstance '{0}'이(가) 종료되었으므로 작업을 수행할 수 없습니다.</value>
  </data>
  <data name="WorkflowInstanceTerminatedRecord" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceTerminatedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}</value>
  </data>
  <data name="WorkflowInstanceTerminatedRecordWithId" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceTerminatedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}</value>
  </data>
  <data name="WorkflowInstanceUnhandledExceptionRecordWithId" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceUnhandledExceptionRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, SourceName = {4}, SourceId = {5}, SourceInstanceId = {6}, SourceTypeName={7}, Exception={8}, Annotations= {9}, ProfileName = {10}, WorkflowDefinitionIdentity = {11}</value>
  </data>
  <data name="WorkflowInstanceUnloaded" xml:space="preserve">
    <value>WorkflowInstance '{0}'이(가) 언로드되었으므로 작업을 수행할 수 없습니다.</value>
  </data>
  <data name="WorkflowInstanceUnlocked" xml:space="preserve">
    <value>WorkflowInstance {0}이(가) 잠금 해제되었으므로 작업을 수행할 수 없습니다.</value>
  </data>
  <data name="WorkflowInstanceUpdatedRecord" xml:space="preserve">
    <value>TrackRecord= WorkflowInstanceUpdatedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, State = {4}, OriginalDefinitionIdentity = {5}, UpdatedDefinitionIdentity = {6}, Annotations = {7}, ProfileName = {8}</value>
  </data>
  <data name="WorkflowInstanceUpdateFailed" xml:space="preserve">
    <value>WorkflowInstance '{0}'을(를) ID '{1}'(으)로 업데이트할 수 없습니다. 추적 출력에서 업데이트할 수 없는 실행 중인 작업 목록을 검토하십시오.</value>
  </data>
  <data name="WorkflowMustBeHosted" xml:space="preserve">
    <value>Receive 작업이 WorkflowServiceHost 내에 호스팅되어 있는지 확인하십시오.</value>
  </data>
  <data name="WorkflowServiceDefinitionIdentityNotMatched" xml:space="preserve">
    <value>로드된 인스턴스의 WorkflowIdentity('{0}')가 호스팅된 WorkflowServices와 일치하지 않습니다.</value>
  </data>
  <data name="WorkflowServiceHostCannotAddOrRemoveServiceDefinitionAfterOpen" xml:space="preserve">
    <value>WorkflowServiceHost가 열리거나 실패하거나 중단되거나 닫힌 후에는 WorkflowService 정의를 추가하거나 제거할 수 없습니다.</value>
  </data>
  <data name="WorkflowTerminatedExceptionDefaultMessage" xml:space="preserve">
    <value>워크플로가 Terminate 작업에 의해 종료되었습니다.</value>
  </data>
  <data name="WorkItemAbortedInstance" xml:space="preserve">
    <value>현재 작업 항목을 처리하는 동안 발생한 오류로 인해 워크플로가 중단되었습니다. 자세한 내용은 내부 예외를 참조하십시오.</value>
  </data>
  <data name="WrapperNotSupportedInMessageContract" xml:space="preserve">
    <value>사용자 지정 래퍼 이름 및 네임스페이스는 MessageContracts를 사용해서만 지원됩니다. 구현된 계약 '{1}'의 작업 '{0}'에 대해 MessageContract 형식을 사용하십시오.</value>
  </data>
  <data name="WriteAccessToReadOnlyPublicReference" xml:space="preserve">
    <value>작업 '{0}'이(가) ArgumentDirection.In으로 선언되었기 때문에 이 공용 위치에 쓸 수 없습니다. 읽기 및 쓰기를 모두 허용하려면 ArgumentDirection.InOut으로 참조를 선언하십시오.</value>
  </data>
  <data name="WriteonlyPropertyCannotBeRead" xml:space="preserve">
    <value>get 접근자에 액세스할 수 없으므로 이 컨텍스트에서 속성 또는 인덱서 '{0}.{1}'을(를) 사용할 수 없습니다.</value>
  </data>
  <data name="WrongArgumentType" xml:space="preserve">
    <value>인수 형식이 잘못되었습니다. 인수는 '{0}' 형식이지만 '{1}'에 할당할 수 있어야 합니다.</value>
  </data>
  <data name="WrongCacheMetadataForCodeActivity" xml:space="preserve">
    <value>ActivityMetadata 매개 변수를 사용하는 CacheMetadata 메서드는 CodeActivity 또는 AsyncCodeActivity에서 호출하지 않아야 합니다. 이러한 클래스에 대한 올바른 CacheMetadata는 CodeActivityMetadata 매개 변수를 사용합니다.</value>
  </data>
  <data name="WrongCacheMetadataForNativeActivity" xml:space="preserve">
    <value>ActivityMetadata 매개 변수를 사용하는 CacheMetadata 메서드는 NativeActivity에서 호출하지 않아야 합니다. NativeActivity에 대한 올바른 CacheMetadata는 NativeActivityMetadata 매개 변수를 사용합니다.</value>
  </data>
  <data name="WrongEnvironmentCount" xml:space="preserve">
    <value>작업 '{0}'에는 인수 '{1}'개, 공용 변수 '{2}'개, 전용 변수 '{3}'개 및 런타임 대리자 인수 '{4}'개가 포함되어야 합니다. 실제: 인수 '{5}'개, 공용 변수 '{6}'개, 전용 변수 '{7}'개, 런타임 대리자 인수 '{8}'개입니다.</value>
  </data>
  <data name="WrongMemberCount" xml:space="preserve">
    <value>소유자가 '{0}'인 IdSpace에 '{1}'개 멤버가 있지만 '{2}'개가 필요합니다.</value>
  </data>
  <data name="WrongNumberOfArgumentsForActivityDelegate" xml:space="preserve">
    <value>ActivityDelegate 인수가 일치하지 않습니다. 작업 구성을 확인하여 선언된 ActivityDelegate와 동기화되었는지 확인하십시오.</value>
  </data>
  <data name="WrongOnCreateDynamicUpdateMapForNativeActivity" xml:space="preserve">
    <value>UpdateMapMetadata 매개 변수를 사용하는 OnCreateDynamicUpdateMap은 NativeActivity에서 호출해서는 안됩니다. NativeActivity의 올바른 OnCreateDynamicUpdateMap에는 NativeActivityUpdateMapMetadata 매개 변수가 사용됩니다.</value>
  </data>
  <data name="WrongOriginalEnvironmentCount" xml:space="preserve">
    <value>작업 '{0}'의 원래 환경에는 인수 '{1}'개, 공용 변수 '{2}'개, 전용 변수 '{3}'개, 런타임 대리자 인수 '{4}'개의 총 '{5}'개가 포함되어야 합니다. 실제 총 위치 수는 '{6}'개입니다.</value>
  </data>
  <data name="XamlBuildTaskResourceNotFound" xml:space="preserve">
    <value>XAML 빌드 작업({0})으로 생성되어야 하는 XAML 리소스를 찾을 수 없습니다. 프로젝트를 다시 빌드해보십시오.</value>
  </data>
  <data name="XamlElementExpected" xml:space="preserve">
    <value>요소 표현이 필요합니다.</value>
  </data>
  <data name="XamlElementExpectedAt" xml:space="preserve">
    <value>줄({0}, {1})에 요소 표현이 필요합니다.</value>
  </data>
</root>