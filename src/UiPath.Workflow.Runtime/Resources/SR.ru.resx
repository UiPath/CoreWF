<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AbortingDueToDynamicUpdateFailure" xml:space="preserve">
    <value>WorkflowApplication было прервано из-за сбоя попытки обновления экземпляра.</value>
  </data>
  <data name="AbortingDueToInstanceTimeout" xml:space="preserve">
    <value>Работа экземпляра рабочего процесса прервана, так как время его выполнения истекло.</value>
  </data>
  <data name="AbortingDueToLoadFailure" xml:space="preserve">
    <value>Работа WorkflowApplication прервана, поскольку операция Load или LoadRunnableInstance вызвала исключение. Создайте новый объект WorkflowApplication, чтобы загрузить другой экземпляр рабочего процесса.</value>
  </data>
  <data name="AbortingDueToVersionMismatch" xml:space="preserve">
    <value>Работа WorkflowApplication прервана, поскольку операция Load или LoadRunnableInstance вызвала исключение VersionMismatchException.</value>
  </data>
  <data name="AbortInstanceOnTransactionFailureDoesNotMatch" xml:space="preserve">
    <value>Значение свойства AbortInstanceOnTransactionFailure действия TransactionScope "{0}", вложенного в действие TransactedReceiveScope "{1}", не должно быть равным false.</value>
  </data>
  <data name="ActionItemCallbackInvoked" xml:space="preserve">
    <value>Вызван обратный вызов планировщика потока ввода-вывода.</value>
  </data>
  <data name="ActionItemIsAlreadyScheduled" xml:space="preserve">
    <value>Элементу ActionItem уже было назначено время для выполнения, которое еще не было завершено.</value>
  </data>
  <data name="ActionItemScheduled" xml:space="preserve">
    <value>Вызван обратный вызов планировщика потока ввода-вывода.</value>
  </data>
  <data name="ActivityBlockingUpdate" xml:space="preserve">
    <value>Действие "{0}": {1}</value>
  </data>
  <data name="ActivityCannotBeReferenced" xml:space="preserve">
    <value>Действие "{1}" не может ссылать на действие "{0}", поскольку действие "{0}" уже упоминается в другом месте потока операций, и эта ссылка невидима для действия "{1}".  Чтобы действие "{0}" было видимым для действия "{1}", оно должно быть потомком или импортируемым потомком (но не потомком реализации) действия "{2}".  Действие "{0}" первоначально упоминалось в действии "{3}", а действие "{1}" входит в реализацию действия "{2}".</value>
  </data>
  <data name="ActivityCannotBeReferencedWithoutTarget" xml:space="preserve">
    <value>Действие "{1}" не может ссылаться на действие "{0}", так как первое не входит в реализацию другого действия. На действие может ссылаться реализация только такого действия, которое относится к нему как к дочернему или импортируемому. Действие "{0}" объявляется действием "{2}".</value>
  </data>
  <data name="ActivityCannotReferenceItself" xml:space="preserve">
    <value>Действие с отображаемым именем "{0}" пытается ссылаться само на себя. Действие не может быть собственным родителем.</value>
  </data>
  <data name="ActivityCompleted" xml:space="preserve">
    <value>Действие "{0}" (отображаемое имя "{1}", ИД экземпляра "{2}") закончилось в состоянии "{3}".</value>
  </data>
  <data name="ActivityDefinitionCannotBeShared" xml:space="preserve">
    <value>Возможно, объект определения действия "{0}" используется совместно несколькими узлами в рабочем процессе. Многократное использование объекта определения действия в рабочем процессе является ошибкой.</value>
  </data>
  <data name="ActivityDelegateAlreadyOpened" xml:space="preserve">
    <value>Делегат ActivityDelegate "{0}" уже является дочерним для действия "{1}" и не может стать дочерним для действия "{2}".  Делегат может быть возвращен как дочерний только один раз.</value>
  </data>
  <data name="ActivityDelegateCannotBeReferenced" xml:space="preserve">
    <value>Действие "{1}" не может ссылаться на делегат действия с обработчиком "{0}", так как первое не входит в реализацию действия "{2}". На делегат действия может ссылаться реализация только такого действия, которое относится к нему как к дочернему или импортируемому. Делегат действия с обработчиком "{0}" объявляется действием "{3}".</value>
  </data>
  <data name="ActivityDelegateCannotBeReferencedNoHandler" xml:space="preserve">
    <value>Действие "{0}" не может ссылаться на делегат действия без обработчика, так как первое не входит в реализацию действия "{1}". На делегат действия может ссылаться реализация только такого действия, которое относится к нему как к дочернему или импортируемому. Делегат действия без обработчика объявляется действием "{2}".</value>
  </data>
  <data name="ActivityDelegateCannotBeReferencedWithoutTarget" xml:space="preserve">
    <value>Действие "{1}" не может ссылаться на делегат действия с обработчиком "{0}", так как первое не входит в реализацию другого действия. На делегат действия может ссылаться реализация только такого действия, которое относится к нему как к дочернему или импортируемому. Делегат действия с обработчиком "{0}" объявляется действием "{2}".</value>
  </data>
  <data name="ActivityDelegateCannotBeReferencedWithoutTargetNoHandler" xml:space="preserve">
    <value>Действие "{0}" не может ссылаться на делегат действия без обработчика, так как первое не входит в реализацию другого действия. На делегат действия может ссылаться реализация только такого действия, которое относится к нему как к дочернему или импортируемому. Делегат действия без обработчика объявляется действием "{1}".</value>
  </data>
  <data name="ActivityDelegateHandlersMustBeDeclarations" xml:space="preserve">
    <value>Обработчик для ActivityDelegate, ActivityAction или ActivityFunc не должен быть ссылкой на уже имеющееся в дереве действие. На действие обработчика "{0}" делегата, родителем которого является "{1}", уже ссылается "{2}".</value>
  </data>
  <data name="ActivityDelegateNotOpened" xml:space="preserve">
    <value>Делегат ActivityDelegate "{0}" не находится в открытом состоянии.</value>
  </data>
  <data name="ActivityDelegateOwnerEnvironmentMissing" xml:space="preserve">
    <value>Среда расположения для действия "{0}", объявляющего делегат действия "{1}", не обнаружена.</value>
  </data>
  <data name="ActivityDelegateOwnerMissing" xml:space="preserve">
    <value>Для делегата ActivityDelegate "{0}" необходимо указать элемент рабочего процесса владельца.</value>
  </data>
  <data name="ActivityDelegateOwnerNotInParentScope" xml:space="preserve">
    <value>Элемент Activity, объявляющий делегат ActivityDelegate "{0}", не найден в родительской иерархии текущего выполняемого действия "{1}".</value>
  </data>
  <data name="ActivityFailedToOpenBefore" xml:space="preserve">
    <value>Это действие невозможно открыть, так как ранее при его открытии произошла ошибка.</value>
  </data>
  <data name="ActivityHasNoImplementation" xml:space="preserve">
    <value>Действие "{0}" имеет карту реализации, но не имеет реализации.</value>
  </data>
  <data name="ActivityInstanceFixupFailed" xml:space="preserve">
    <value>Не удалось загрузить рабочий процесс. Данное дерево действий несовместимо с этим экземпляром.</value>
  </data>
  <data name="ActivityIsNotRoot" xml:space="preserve">
    <value>Этот аргумент должен быть корнем определения рабочего процесса.</value>
  </data>
  <data name="ActivityIsUncached" xml:space="preserve">
    <value>Этот метод может быть вызван только после вызова метода CacheMetadata для определения потока операций.</value>
  </data>
  <data name="ActivityMapIsCorrupt" xml:space="preserve">
    <value>Сопоставление из программы действия в экземпляр повреждено в сохраненном экземпляре.</value>
  </data>
  <data name="ActivityNotFound" xml:space="preserve">
    <value>Действие "{0}" не найдено.</value>
  </data>
  <data name="ActivityNotICompiledExpressionRoot" xml:space="preserve">
    <value>Для определения идентификатора выражения требуется действие ICompiledExpressionRoot. Убедитесь, что текущее определение скомпилировано.</value>
  </data>
  <data name="ActivityNotPartOfThisTree" xml:space="preserve">
    <value>Предоставленное действие не было частью данного определения рабочего процесса во время обработки его метаданных. Проблемное действие с именем "{0}" было предоставлено действием с именем "{1}".</value>
  </data>
  <data name="ActivityPropertyMustBeSet" xml:space="preserve">
    <value>"{0}" является обязательным свойством действия "{1}".</value>
  </data>
  <data name="ActivityPropertyNotSet" xml:space="preserve">
    <value>Свойство "{0}" операции "{1}" имеет значение null, и она не будет выполнять никаких действий.</value>
  </data>
  <data name="ActivityPropertyRequiresName" xml:space="preserve">
    <value>Свойство "Name" является обязательным для всех свойств ActivityProperty в действии DynamicActivity "{0}".</value>
  </data>
  <data name="ActivityPropertyRequiresType" xml:space="preserve">
    <value>Свойство "Type" является обязательным для всех свойств ActivityProperty в действии DynamicActivity "{0}".</value>
  </data>
  <data name="ActivityScheduled" xml:space="preserve">
    <value>Родительское действие "{0}" (отображаемое имя "{1}", ИД экземпляра "{2}") запланировало дочернее действие "{3}" (отображаемое имя "{4}", ИД экземпляра "{5}").</value>
  </data>
  <data name="ActivityTypeMismatch" xml:space="preserve">
    <value>Действие "{0}" не принадлежит к типу "{1}". При загрузке этого экземпляра необходимо убедиться, что действие с именем "{0}" реализует тип "{1}".</value>
  </data>
  <data name="ActivityXamlServiceLineString" xml:space="preserve">
    <value>Линия</value>
  </data>
  <data name="ActivityXamlServicesCompilationFailed" xml:space="preserve">
    <value>Число сбоев в процессе компиляции: {0}Полные результаты содержатся в свойстве Data этого исключения. Исправьте ошибку в источнике и повторите попытку загрузки.</value>
  </data>
  <data name="ActivityXamlServicesRequiresActivity" xml:space="preserve">
    <value>Действие ActivityXamlServices.Load поддерживает только типы на базе действий. Был предоставлен недопустимый тип ({0}).</value>
  </data>
  <data name="AddedIdleArgumentBlockDU" xml:space="preserve">
    <value>Выражение для добавленного аргумента "{0}" содержит действие "{1}", которое может бездействовать во время выполнения. Чтобы включить динамическое обновление в этом действии, используйте выражение аргумента, которое гарантированно не может быть в бездействии.</value>
  </data>
  <data name="AddedIdleExpressionBlockDU" xml:space="preserve">
    <value>Добавлена переменная по умолчанию или выражение аргумента, которые могут находиться в бездействии во время выполнения.</value>
  </data>
  <data name="AddedIdleVariableDefaultBlockDU" xml:space="preserve">
    <value>Выражение по умолчанию для добавленной переменной "{0}" содержит действие "{1}", которое может бездействовать во время выполнения. Чтобы включить динамическое обновление в этом действии, используйте выражение переменной по умолчанию, которое гарантированно не может быть в бездействии.</value>
  </data>
  <data name="AddMatchActivityNewAndOldParentMismatch" xml:space="preserve">
    <value>Не удается сопоставить новое действие "{0}" со старым действием "{1}", так как их объявители не совпадают. Новое действие объявлено объявителем "{2}", а старое действие объявлено объявителем "{3}".</value>
  </data>
  <data name="AddMatchActivityNewParentMismatch" xml:space="preserve">
    <value>Действие "{0}" не может добавить соответствие для действия "{1}", так как не является его объявителем. Сопоставленное действие объявлено объявителем "{2}".</value>
  </data>
  <data name="AddMatchActivityPrivateChild" xml:space="preserve">
    <value>Не удается добавить соответствие для действия "{0}", так как оно является закрытым потомком. Соответствия могут добавляться только для открытых потомков.</value>
  </data>
  <data name="AddMatchVariableNewAndOldParentMismatch" xml:space="preserve">
    <value>Не удается сопоставить новую переменную "{0}" со старой переменной "{1}", так как их владельцы не совпадают. Новой переменной владеет "{2}", а старой переменной владеет "{3}".</value>
  </data>
  <data name="AddMatchVariableNewParentMismatch" xml:space="preserve">
    <value>Действие "{0}" не может добавить соответствие для переменной "{1}", так как не является ее владельцем. Владельцем соответствующей переменной является "{2}".</value>
  </data>
  <data name="AddMatchVariablePrivateChild" xml:space="preserve">
    <value>Не удается добавить соответствие для переменной "{0}", так как она является закрытой. Соответствия могут добавляться только для открытых переменных.</value>
  </data>
  <data name="AddMatchVariableSignatureMismatch" xml:space="preserve">
    <value>Действие "{0}" не может добавить соответствие переменной, так как сигнатуры этих переменных не совпадают. Сигнатуры, включая имя, тип и модификаторы, должны совпадать. Имя, тип и модификаторы новой переменной: {1}, {2} и {3} соответственно. Имя, тип и модификаторы старой переменной: {4}, {5} и {6} соответственно.</value>
  </data>
  <data name="AddValidationErrorMustBeCalledFromConstraint" xml:space="preserve">
    <value>Метод AddValidationError может вызываться только из поддерева операции {0}.</value>
  </data>
  <data name="AECDisposed" xml:space="preserve">
    <value>К контексту ActivityContext можно обратиться только из области функции, в которую он был передан.</value>
  </data>
  <data name="AECForPropertiesHasBeenDisposed" xml:space="preserve">
    <value>Контекст ActivityContext, создавший данный объект ExecutionProperties, уже удален. К свойствам можно обращаться только из выполняющегося рабочего элемента действия.</value>
  </data>
  <data name="AlreadyBoundToInstance" xml:space="preserve">
    <value>Системе сохранения экземпляров не удалось обработать недопустимую команду InstancePersistenceCommand.  Команде требуется несвязанный дескриптор, однако дескриптор InstanceHandle уже привязан к экземпляру.</value>
  </data>
  <data name="AlreadyBoundToOwner" xml:space="preserve">
    <value>Системе сохранения экземпляров не удалось обработать недопустимую команду InstancePersistenceCommand.  Команде требуется несвязанный дескриптор, однако дескриптор InstanceHandle уже привязан к владельцу экземпляра.</value>
  </data>
  <data name="AlreadySetupNoPersist" xml:space="preserve">
    <value>Этот элемент рабочего процесса уже настроил несохраняемый блок.  Только один несохраняемый блок может быть настроен элементом рабочего процесса.</value>
  </data>
  <data name="AmbiguousVBVariableReference" xml:space="preserve">
    <value>"{0}" является неоднозначной ссылкой на переменную.  Идентификаторы VisualBasic нечувствительны к регистру.</value>
  </data>
  <data name="AppDomainUnload" xml:space="preserve">
    <value>Выгрузка домена приложения. AppDomain.FriendlyName {0}, ProcessName {1}, ProcessId {2}.</value>
  </data>
  <data name="ArgumentAlreadyInitialized" xml:space="preserve">
    <value>Ожидалось, что аргумент "{0}" действия "{1}" будет добавлен динамическим обновлением, но он уже инициализирован.</value>
  </data>
  <data name="ArgumentAlreadyInUse" xml:space="preserve">
    <value>Аргумент "{0}" используется действием "{1}", поэтому он не может использоваться действием "{2}".</value>
  </data>
  <data name="ArgumentCannotHaveNullOrVoidType" xml:space="preserve">
    <value>Действие с параметром DisplayName="{0}" содержит аргумент с именем "{1}", у которого тип null или void.</value>
  </data>
  <data name="ArgumentDirectionMismatch" xml:space="preserve">
    <value>Аргумент, предоставленный для RuntimeArgument "{0}", не может быть привязан из-за несовпадения направления.  Аргумент RuntimeArgument объявляет направление {1}, а данный аргумент имеет направление {2}.</value>
  </data>
  <data name="ArgumentDoesNotExist" xml:space="preserve">
    <value>В этой коллекции не существует аргумента с именем "{0}".</value>
  </data>
  <data name="ArgumentDoesNotExistInEnvironment" xml:space="preserve">
    <value>Аргумент "{0}" не существует в текущей области среды.</value>
  </data>
  <data name="ArgumentIsAddedMoreThanOnce" xml:space="preserve">
    <value>Аргумент "{0}" добавлен в действие "{1}" больше одного раза.</value>
  </data>
  <data name="ArgumentLocationExpressionTypeMismatch" xml:space="preserve">
    <value>Выражение должно иметь тип "{0}", а передан тип "{1}".</value>
  </data>
  <data name="ArgumentMustbePropertyofWorkflowElement" xml:space="preserve">
    <value>Аргумент должен быть одним из свойств класса WorkflowElement.</value>
  </data>
  <data name="ArgumentNameRequired" xml:space="preserve">
    <value>Необходимо задать имя аргумента ArgumentReference или ArgumentValue.</value>
  </data>
  <data name="ArgumentNotFound" xml:space="preserve">
    <value>Не удалось найти аргумент с именем "{0}" для действия, являющегося владельцем этих закрытых дочерних действий.  Параметры ArgumentReference и ArgumentValue должны использоваться только в теле определения действия.</value>
  </data>
  <data name="ArgumentNotInTree" xml:space="preserve">
    <value>Нельзя использовать аргумент типа "{0}". Убедитесь, что он объявлен в действии.</value>
  </data>
  <data name="ArgumentNullOrEmpty" xml:space="preserve">
    <value>Аргумент {0} имеет значение null или является пустым.</value>
  </data>
  <data name="ArgumentNumberRequiresTheSameAsParameterNumber" xml:space="preserve">
    <value>Число аргументов и число параметров типа "{0}" должны совпадать.</value>
  </data>
  <data name="ArgumentRequired" xml:space="preserve">
    <value>Требуется содержимое аргумента в коллекции "{0}" аргументов "{1}".</value>
  </data>
  <data name="ArgumentTypeCannotBeNull" xml:space="preserve">
    <value>Типом аргумента не может быть null.</value>
  </data>
  <data name="ArgumentTypeMismatch" xml:space="preserve">
    <value>Не удается привязать аргумент, указанный для RuntimeArgument "{0}", из-за несоответствия типов.  Аргумент RuntimeArgument объявляет тип {1}, а аргумент имеет тип {2}.  Типы должны совпадать.</value>
  </data>
  <data name="ArgumentTypeMustBeCompatible" xml:space="preserve">
    <value>Тип аргумента должен быть совместим с типом данного параметра ArgumentReference или ArgumentValue.  Аргумент "{0}" имеет тип {1}, а ожидаемый тип - {2}.</value>
  </data>
  <data name="ArgumentValueExpressionTypeMismatch" xml:space="preserve">
    <value>Аргументу требуется тип ResultType "{0}", а предоставлено действие с типом результата "{1}".</value>
  </data>
  <data name="ArgumentViolationsFound" xml:space="preserve">
    <value>Обнаружены нарушения в действии "{0}". Были обнаружены следующие нарушения:    {1}</value>
  </data>
  <data name="AssemblyReferenceIsImmutable" xml:space="preserve">
    <value>Встроенные, используемые по умолчанию AssemblyReferences нельзя изменить.</value>
  </data>
  <data name="AsyncCallbackThrewException" xml:space="preserve">
    <value>Асинхронный обратный вызов сформировал исключение.</value>
  </data>
  <data name="AsyncEventArgsCompletedTwice" xml:space="preserve">
    <value>Реализация "{0}" интерфейса AsyncEventArgs пытается выполнить одну операцию несколько раз. Возможно, это вызвано неверной реализацией интерфейса AsyncEventArgs или другого кода расширяемости, вызывающего событие AsyncCallback несколько раз.</value>
  </data>
  <data name="AsyncEventArgsCompletionPending" xml:space="preserve">
    <value>Реализация "{0}" интерфейса AsyncEventArgs пытается задать состояние ожидания несколько раз, не завершая ожидающей операции. Возможно, это вызвано неверной реализацией интерфейса AsyncEventArgs или другого кода расширяемости, вызывающего событие Set() несколько раз.</value>
  </data>
  <data name="AsyncMethodsMustAllBeStaticOrInstance" xml:space="preserve">
    <value>Все асинхронные методы должны быть статическими методами или методами экземпляров.</value>
  </data>
  <data name="AsyncMethodsMustFromSameType" xml:space="preserve">
    <value>Асинхронные методы должны быть одного типа.</value>
  </data>
  <data name="AsyncResultAlreadyEnded" xml:space="preserve">
    <value>Метод End нельзя вызывать дважды для AsyncResult.</value>
  </data>
  <data name="AsyncResultCompletedTwice" xml:space="preserve">
    <value>Реализация "{0}" интерфейса IAsyncResult пытается выполнить одну операцию несколько раз. Возможно, это вызвано неверной реализацией интерфейса IAsyncResult или другого кода расширяемости в приложении - например, интерфейс IAsyncResult возвращает неверные значения CompletedSynchronously или несколько раз вызывает AsyncCallback.</value>
  </data>
  <data name="AsyncTransactionException" xml:space="preserve">
    <value>В области TransactionScope, используемой для включения транзакции в асинхронную операцию, произошло исключение.</value>
  </data>
  <data name="BadCopyToArray" xml:space="preserve">
    <value>Не удалось скопировать элементы словаря в указанный массив. Это может быть вызвано одной или несколькими следующими ошибками: массив имеет слишком много измерений; индекс находится после конца массива, в массиве недостаточно места.</value>
  </data>
  <data name="BadWorkflowIdentityFormat" xml:space="preserve">
    <value>Недопустимый формат WorkflowIdentity. Идентификатор WorkflowIdentity должен иметь формат "имя; Version=версия; Package=пакет". Указание версии и пакета необязательно.</value>
  </data>
  <data name="BeforeInitializeComponentXBTExtensionResourceNotFound" xml:space="preserve">
    <value>Предполагалось, что ресурс будет создан расширением построения задания XAML BeforeInitializeComponent. Этот ресурс не найден. Перестройте проект.</value>
  </data>
  <data name="BeginExecuteMustNotReturnANullAsyncResult" xml:space="preserve">
    <value>AsyncCodeActivity.BeginExecute не должен возвращать значение NULL для IAsyncResult.</value>
  </data>
  <data name="BeginExecuteMustUseProvidedStateAsAsyncResultState" xml:space="preserve">
    <value>Действие AsyncCodeActivity.BeginExecute должно возвращать интерфейс IAsyncResult, где IAsyncResult.AsyncState — это объект состояния, предоставляемый средой выполнения.</value>
  </data>
  <data name="BinaryExpressionActivityRequiresArgument" xml:space="preserve">
    <value>{0} необходимо задать до начала использования {1} действия "{2}".</value>
  </data>
  <data name="BindLockRequiresCommandFlag" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод BindAcquiredLock, BindReclaimedLock, BeginBindReclaimedLock или CreateBindReclaimedLockException в недействительное время. Эти методы могут вызываться только во время обработки команды, которая может получить блокировку экземпляра. Переключитесь в допустимый поставщик сохраняемости или переопределите реализацию InstancePersistenceCommand так, чтобы возвращать значение true из AutomaticallyAcquiringLock.</value>
  </data>
  <data name="BindReclaimedLockException" xml:space="preserve">
    <value>Это исключение не является ошибкой, и его не следует обрабатывать.  Он может вызываться в реализации InstanceStore.TryCommand, BeginTryCommand или EndTryCommand в поставщике сохраняемости, чтобы указать на попытку восстановления блокировки для версии, указанной в вызове InstancePersistenceContext.CreateBindReclaimedLockException.</value>
  </data>
  <data name="BindReclaimSucceeded" xml:space="preserve">
    <value>Реализация InstanceStore в поставщике сохраняемости успешно отменила команду. Потерянная блокировка была восстановлена, и команда отменена посредством InstancePersistenceContext.CreateBindReclaimedLockException.</value>
  </data>
  <data name="BlockedUpdateInsideActivityUpdateByUserError" xml:space="preserve">
    <value>Автор обновление запретил обновление внутри этого выполняющегося действия.</value>
  </data>
  <data name="BlockedUpdateInsideActivityUpdateError" xml:space="preserve">
    <value>Динамическое обновление для данного действия заблокировано.</value>
  </data>
  <data name="BodyCannotBeNull" xml:space="preserve">
    <value>Значение Body в описании письма не может быть равно null. Задайте правильное значение для OperationDescription.MessageDescription.Body.</value>
  </data>
  <data name="BookmarkAlreadyExists" xml:space="preserve">
    <value>Закладка с именем "{0}" уже существует.</value>
  </data>
  <data name="BookmarkNotFoundGeneric" xml:space="preserve">
    <value>Не удалось найти запрошенную закладку.</value>
  </data>
  <data name="BookmarkNotRegistered" xml:space="preserve">
    <value>Закладка {0} в данный момент не зарегистрирована в расширении компенсации.</value>
  </data>
  <data name="BookmarkScopeAlreadyInitialized" xml:space="preserve">
    <value>Невозможно инициализировать область закладок, так как она уже инициализирована.</value>
  </data>
  <data name="BookmarkScopeHasBookmarks" xml:space="preserve">
    <value>Регистрация указанной области закладок не может быть отменена, так как она содержит неразмещенные закладки.</value>
  </data>
  <data name="BookmarkScopeInitialized" xml:space="preserve">
    <value>Объект BookmarkScope с идентификатором TemporaryId: "{0}" инициализирован идентификатором "{1}".</value>
  </data>
  <data name="BookmarkScopeNotFound" xml:space="preserve">
    <value>Не удается найти область закладок с идентификатором "{0}".</value>
  </data>
  <data name="BookmarkScopeNotRegisteredForInitialize" xml:space="preserve">
    <value>Указанную область закладок невозможно инициализировать, так как она не зарегистрирована.</value>
  </data>
  <data name="BookmarkScopeNotRegisteredForUnregister" xml:space="preserve">
    <value>Регистрация указанной области закладок не может быть отменена, так как она не зарегистрирована.  </value>
  </data>
  <data name="BookmarkScopesRequireKeys" xml:space="preserve">
    <value>Для областей закладок требуется узел, который поддерживает управление ключами.  Используемый узел не поддерживает управление ключами.  Если используются объекты WorkflowApplication или WorkflowInvoker, рассмотрите вместо этого использование WorkflowServiceHost.</value>
  </data>
  <data name="BookmarkScopeWithIdAlreadyExists" xml:space="preserve">
    <value>Указанная область закладок не может быть инициализирована с идентификатором "{0}", так как уже существует область закладок с таким идентификатором.</value>
  </data>
  <data name="BookmarksOnlyResumableWhileIdle" xml:space="preserve">
    <value>Действие TryScheduleBookmarkResumption можно вызвать только во время простоя среды выполнения.</value>
  </data>
  <data name="BufferAllocationFailed" xml:space="preserve">
    <value>Не удалось выделить буфер управляемой памяти размером {0} байт. Возможно, не хватает доступной памяти.</value>
  </data>
  <data name="BufferedOutputStreamQuotaExceeded" xml:space="preserve">
    <value>Превышена квота на размер для этого потока ({0}).</value>
  </data>
  <data name="BufferedReceiveBehaviorMultipleUse" xml:space="preserve">
    <value>Экземпляр BufferedReceiveServiceBehavior не может быть добавлен в класс WorkflowServiceHost, так как он уже добавлен в другой экземпляр класса WorkflowServiceHost. Создавайте новый экземпляр BufferedReceiveServiceBehavior для каждого нового класса WorkflowServiceHost.</value>
  </data>
  <data name="BufferedReceiveBehaviorUsedWithoutProperty" xml:space="preserve">
    <value>Значение BufferedReceiveServiceBehavior должно использоваться с определением потока операций, поддерживающим обработку BufferedReceive. Чтобы включить обработку BufferedReceive, вызовите метод WorkflowService.AllowBufferedReceive.</value>
  </data>
  <data name="BufferedReceiveRequiresReceiveContext" xml:space="preserve">
    <value>Операция с именем "{0}" должна быть включена, чтобы использовать режим ManualAcknowledgement метода ReceiveContext, когда используется BufferedReceiveServiceBehavior.</value>
  </data>
  <data name="BufferIsNotRightSizeForBufferManager" xml:space="preserve">
    <value>Этот буфер нельзя вернуть диспетчеру буферов из-за неверного размера.</value>
  </data>
  <data name="BufferOutOfOrderMessageNoBookmark" xml:space="preserve">
    <value>Операция "{1}" в экземпляре службы "{0}" не может быть выполнена сейчас. Следующая попытка будет предпринята, когда экземпляр службы будет готов к обработке именно этой операции.</value>
  </data>
  <data name="BufferOutOfOrderMessageNoInstance" xml:space="preserve">
    <value>Операция "{0}" не может быть выполнена сейчас. Следующая попытка будет предпринята, когда экземпляр службы будет готов к обработке именно этой операции.</value>
  </data>
  <data name="BufferPoolAllocation" xml:space="preserve">
    <value>Выделение {0} байт пулом.</value>
  </data>
  <data name="BufferPoolChangeQuota" xml:space="preserve">
    <value>BufferPool размером {0}, изменение квоты на {1}.</value>
  </data>
  <data name="BusyCountTraceFormatString" xml:space="preserve">
    <value>Идентификатор экземпляра потока операций {0}</value>
  </data>
  <data name="CacheRootMetadataStart" xml:space="preserve">
    <value>CacheRootMetadata запущено для действия "{0}"</value>
  </data>
  <data name="CacheRootMetadataStop" xml:space="preserve">
    <value>CacheRootMetadata остановлено для действия {0}.</value>
  </data>
  <data name="CacheSettingsLocked" xml:space="preserve">
    <value>Параметры кэша неизменяемы, так как расширение уже добавлено в экземпляр рабочего процесса или в коллекцию расширений узлов.</value>
  </data>
  <data name="CallbackExceptionFromHostAbort" xml:space="preserve">
    <value>Вызов OnRequestAbort для WorkflowInstance "{0}" привел к вызову исключения, которое признано неустранимым. Подробные сведения см. во внутреннем исключении.</value>
  </data>
  <data name="CallbackExceptionFromHostGetExtension" xml:space="preserve">
    <value>Вызов OnGetExtension для WorkflowInstance "{0}" привел к вызову исключения, которое признано неустранимым. Подробные сведения см. во внутреннем исключении.</value>
  </data>
  <data name="CancellationHandlerFatalException" xml:space="preserve">
    <value>Обработчик отмены "{0}" создал необработанное исключение. Возможно, процесс отмены находится в несовместимом состоянии, рабочий процесс был прерван.</value>
  </data>
  <data name="CanInduceIdleActivityInArgumentExpression" xml:space="preserve">
    <value>Аргумент "{0}" действия "{1}" привязан к выражению, содержащему действие "{2}". Действие "{2}" может привести выражение в состояние простоя во время оценки. Если выражения аргументов действия "{1}" изменяют общее состояние, то простой во время оценки может привести к непредвиденным значениям аргументов.</value>
  </data>
  <data name="CanInduceIdleNotSpecified" xml:space="preserve">
    <value>Операция "{0}" недопустима. Операция NativeActivity создала производные асинхронные операции, вызывая один из перегруженных методов CreateBookmark, определенных в System.Activities. NativeActivityContext должен переопределить свойство CanInduceIdle и возвратить true.</value>
  </data>
  <data name="CannotAcquireLockDefault" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано, поскольку экземпляр заблокирован другим владельцем. Эта ошибка обычно происходит из-за того, что экземпляр загружается на другом узле.</value>
  </data>
  <data name="CannotAcquireLockSpecific" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано, поскольку экземпляр "{0}" заблокирован другим владельцем. Эта ошибка обычно происходит из-за того, что экземпляр загружается на другом узле.</value>
  </data>
  <data name="CannotAcquireLockSpecificWithOwner" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано, поскольку экземпляр "{0}" заблокирован другим владельцем. Эта ошибка обычно происходит из-за того, что экземпляр загружается на другом узле. Владелец экземпляра или узел, удерживающий блокировку экземпляра, имеет идентификатор "{1}".</value>
  </data>
  <data name="CannotAddHandlesUpdateError" xml:space="preserve">
    <value>Действие добавило новую переменную, тип которой является производным от класса Handle.</value>
  </data>
  <data name="CannotAddOrRemoveWithChildren" xml:space="preserve">
    <value>Действие не может добавить или удалить свойства выполнения рабочего процесса пока выполняются его дочерние действия.</value>
  </data>
  <data name="CannotCallAbortInstanceFromWorkflowThread" xml:space="preserve">
    <value>Действие AbortInstance не может быть вызвано из потока рабочего процесса, так как это может привести к несогласованному состоянию.</value>
  </data>
  <data name="CannotChangeAbortInstanceFlagAfterPropertyRegistration" xml:space="preserve">
    <value>Значение флага AbortInstanceOnTransactionFailure не может быть изменено после выполнения соответствующего классу RuntimeTransactionHandle действия IPropertyRegistrationCallback.Register.</value>
  </data>
  <data name="CannotChangeMatchesInImplementation" xml:space="preserve">
    <value>Новые соответствия невозможно добавлять в закрытые реализации рабочего процесса, для которых строится карта обновления.</value>
  </data>
  <data name="CannotCompleteRuntimeOwnedTransaction" xml:space="preserve">
    <value>Текущая транзакция была настроена средой выполнения и может быть завершена только этой средой.  Транзакция, настроенная средой выполнения, обычно является результатом вызова API в методе WorkflowInvoker во время существования включающей транзакции.</value>
  </data>
  <data name="CannotCompleteWithKeys" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о завершении экземпляра, когда с ним связаны активные ключи. Перед завершением экземпляра необходимо завершить все ключи, связанные с ним.</value>
  </data>
  <data name="CannotConvertObject" xml:space="preserve">
    <value>Не удается преобразовать объект "{0}" в тип "{1}".</value>
  </data>
  <data name="CannotCreateContextWithNullId" xml:space="preserve">
    <value>В аргументе instanceId метода InstanceStore.CreateInstanceHandle нельзя указывать нулевые идентификаторы, например Guid.Empty.</value>
  </data>
  <data name="CannotCreateMessageFault" xml:space="preserve">
    <value>Не удается создать MessageFault.</value>
  </data>
  <data name="CannotCreateOwnerWithoutIdentity" xml:space="preserve">
    <value>Не удалось создать владельца экземпляра по умолчанию без WorkflowIdentity. Чтобы создать владельца, укажите идентификатор определения или выберите WorkflowIdentityFilter.Any.</value>
  </data>
  <data name="CanNotDefineNullForAPromotion" xml:space="preserve">
    <value>Коллекция продвижения {0} содержит значение NULL для имени продвижения {1}.</value>
  </data>
  <data name="CannotDereferenceNull" xml:space="preserve">
    <value>Не удается создать левостороннее значение из заданного выражения со свойством "{0}", так как значением целевого объекта является null.</value>
  </data>
  <data name="CannotEnlistMultipleTransactions" xml:space="preserve">
    <value>Уже существует транзакция, участвующая в рабочем процессе. Одновременное участие нескольких транзакций недопустимо.</value>
  </data>
  <data name="CanNotFindSymbolResolverInWorkflowInstanceExtensions" xml:space="preserve">
    <value>Не удалось обнаружить символьный разрешитель в коллекции расширений экземпляра рабочего процесса.</value>
  </data>
  <data name="CannotGenerateSchemaForXmlSerializable" xml:space="preserve">
    <value>"{0}" являются внутренними данными среды выполнения, они не поддерживают формирование схемы.</value>
  </data>
  <data name="CannotGetValueOfOutArgument" xml:space="preserve">
    <value>Невозможно получить значение строго выходного аргумента.</value>
  </data>
  <data name="CannotInvokeBindingFromNonBinding" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она пытается выполнить команду, которая может получить блокировку при обработке команды, которая не получает блокировку. Это исключение может вызываться, если метод InstancePersistenceContext.Execute или InstancePersistenceContext.BeginExecute вызывается с командой, для которой InstancePersistenceCommand.AutomaticallyAcquiringLock возвращает значение true, при обработке команды, для которой возвращается значение false. Используйте поставщик сохраняемости, который работает иначе, или переопределите AutomaticallyAcquiringLock в одной из команд, чтобы возвращать нужное значение.</value>
  </data>
  <data name="CannotInvokeOpenedActivity" xml:space="preserve">
    <value>Это действие не может быть вызвано, так как оно не было открыто перегруженным методом Invoke, принимающим интерфейс IDictionary строки и объект.</value>
  </data>
  <data name="CannotInvokeTransactionalFromNonTransactional" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она пытается выполнить транзакционную команду при обработке нетранзакционной команды. Это исключение может вызываться, если метод InstancePersistenceContext.Execute или InstancePersistenceContext.BeginExecute вызывается с командой, для которой InstancePersistenceCommand.IsTransactionEnlistmentOptional возвращает значение false, при обработке команды, для которой возвращается значение true. Используйте поставщик сохраняемости, который работает иначе, или переопределите IsTransactionEnlistmentOptional в одной из команд, чтобы возвращать нужное значение.</value>
  </data>
  <data name="CannotModifyCatchAfterOpen" xml:space="preserve">
    <value>Это действие Catch уже открыто и не может быть изменено. Действия Catch могут быть изменены только во время разработки.</value>
  </data>
  <data name="CannotMoveChildAcrossDifferentFlowNodeTypes" xml:space="preserve">
    <value>Блок-схема не поддерживает динамическое обновление, если дочернее действие перемещено из одного типа FlowNode в другой тип FlowNode.</value>
  </data>
  <data name="CannotNestTransactedReceiveScopeWhenAmbientHandleIsSuppressed" xml:space="preserve">
    <value>Транзакция среды выполнения подавлена. Выполнение действия TransactedReceiveScope "{0}" при подавлении транзакции среды выполнения не поддерживается.</value>
  </data>
  <data name="CannotNestTransactionScopeWhenAmbientHandleIsSuppressed" xml:space="preserve">
    <value>Транзакция среды выполнения в данный момент подавляется. Выполнение действия TransactedScope "{0}" при подавлении транзакции среды выполнения не поддерживается.</value>
  </data>
  <data name="CannotPerformOperationFromHandlerThread" xml:space="preserve">
    <value>Операции WorkflowApplication не могут быть выполнены из обработчиков событий.</value>
  </data>
  <data name="CannotPerformOperationOnHandle" xml:space="preserve">
    <value>Операция не может быть выполнена для переменных подтипов Handle.</value>
  </data>
  <data name="CannotPersistInsideIsolation" xml:space="preserve">
    <value>Действия материализации (Persist) не могут содержаться в блоках изоляции.</value>
  </data>
  <data name="CannotPersistInsideNoPersist" xml:space="preserve">
    <value>Действия материализации (Persist) не могут содержаться в несохраняемых блоках.</value>
  </data>
  <data name="CannotPersistWhileDetached" xml:space="preserve">
    <value>Экземпляр не может быть сохранен, так как он не является владельцем блокировки.  Предыдущий вызов действия Persist со значением разблокировки true отвечал за разблокировку.</value>
  </data>
  <data name="CannotPromoteAsSqlVariant" xml:space="preserve">
    <value>Тип данных "{0}" для свойства с повышенным уровнем "{1}" не поддерживается в SQL. Измените тип данных на поддерживаемый или повышайте свойство в виде двоичного значения.</value>
  </data>
  <data name="CannotPromoteXNameTwiceInPromotion" xml:space="preserve">
    <value>Элемент XName "{0}" продвигается несколько раз при продвижении "{1}". Повторные XName в рамках одного продвижения не разрешаются.</value>
  </data>
  <data name="CannotPropagateExceptionWhileCanceling" xml:space="preserve">
    <value>При отмене действия "{0}" с идентификатором {1} возникло или распространилось исключение.</value>
  </data>
  <data name="CannotRemoveExecutingActivityUpdateError" xml:space="preserve">
    <value>Не удается удалить действие "{0}: {1}", так как оно в настоящий момент выполняется.</value>
  </data>
  <data name="CannotReplaceTransaction" xml:space="preserve">
    <value>Внешняя транзакция (System.Transactions.Transaction.Current) не соответствует транзакции, используемой в данном эпизоде выполнения.  На протяжении всего эпизода выполнения можно использовать только одну транзакцию.</value>
  </data>
  <data name="CannotResetPropertyInDataContext" xml:space="preserve">
    <value>Значение свойства в контексте WorkflowDataContext невозможно сбросить.</value>
  </data>
  <data name="CannotSaveOriginalValueForActivity" xml:space="preserve">
    <value>Действие может сохранять исходные значения только для открытых или импортированных потомков или для обработчиков делегатов.</value>
  </data>
  <data name="CannotSaveOriginalValueForNewActivity" xml:space="preserve">
    <value>Не удается сохранить исходное значение для действия "{0}", так как оно не существовало в исходном определении рабочего процесса.</value>
  </data>
  <data name="CannotSaveOriginalValuesForReferencedChildren" xml:space="preserve">
    <value>Это действие неправильно обрабатывает обновления, если находится внутри реализации действия. Оно попыталось сохранить исходные значения для ссылок на импортированных потомков.</value>
  </data>
  <data name="CannotScheduleChildrenWhileEnteringIsolation" xml:space="preserve">
    <value>Дочерние действия невозможно запланировать при настройке блока изоляции. Дождитесь вызова OnEntered BookmarkCallback перед планированием дочерних действий.</value>
  </data>
  <data name="CannotSerializeExpression" xml:space="preserve">
    <value>Не удалось сериализовать выражение типа "{0}".</value>
  </data>
  <data name="CannotSerializeVariableExpression" xml:space="preserve">
    <value>Не удалось сериализовать выражение, так как подвыражения доступа к переменной сформированы неправильно или не распознаны.</value>
  </data>
  <data name="CannotSetRuntimeTransactionInNoPersist" xml:space="preserve">
    <value>В среде выполнения невозможно задать транзакцию действием, содержащимся в несохраняемой области.  Сохранение запрещено действием-предком.</value>
  </data>
  <data name="CannotSetupIsolationInsideIsolation" xml:space="preserve">
    <value>Невозможно настроить блок изоляции, так как он будет содержаться в другом блоке изоляции.  Блоки изоляции не могут быть вложенными.</value>
  </data>
  <data name="CannotSetupIsolationInsideNoPersist" xml:space="preserve">
    <value>Невозможно настроить блок изоляции, так как он будет содержаться в несохраняемом блоке.</value>
  </data>
  <data name="CannotSetupIsolationWithChildren" xml:space="preserve">
    <value>Блок изоляции не может быть настроен, если существуют выполняющиеся дочерние действия.</value>
  </data>
  <data name="CannotSetValueOfInArgument" xml:space="preserve">
    <value>Невозможно присвоить значения входящим аргументам.</value>
  </data>
  <data name="CannotSetValueToLocation" xml:space="preserve">
    <value>В значении типа "{0}" нельзя установить расположение с именем "{1}", поскольку оно имеет тип "{2}".</value>
  </data>
  <data name="CannotSpecifyBothConnectionStringAndName" xml:space="preserve">
    <value>Нельзя одновременно задавать свойства connectionString и connectionStringName.</value>
  </data>
  <data name="CannotSuppressAlreadyRegisteredHandle" xml:space="preserve">
    <value>Не удается изменить значение свойства SuppressTransaction в уже зарегистрированном классе RuntimeTransactionHandle.</value>
  </data>
  <data name="CannotUnregisterDefaultBookmarkScope" xml:space="preserve">
    <value>Невозможно удалить область закладок, так как она является областью закладок по умолчанию для экземпляра.</value>
  </data>
  <data name="CannotUnregisterNullBookmarkScope" xml:space="preserve">
    <value>Невозможно отменить регистрацию области закладок со значением null.</value>
  </data>
  <data name="CannotUpdateEnvironmentInTheMiddleOfResolvingArguments" xml:space="preserve">
    <value>Аргументы или переменные нельзя добавлять, удалять или перегруппировывать, если экземпляр находится в процессе разрешения аргументов.</value>
  </data>
  <data name="CannotUpdateEnvironmentInTheMiddleOfResolvingVariables" xml:space="preserve">
    <value>Аргументы или переменные нельзя добавлять, удалять или перегруппировывать, если экземпляр находится в процессе разрешения переменных.</value>
  </data>
  <data name="CannotUpdateLoadedInstance" xml:space="preserve">
    <value>Не удалось обновить экземпляр WorkflowInstance "{0}", так как он уже загружен. Перед обновлением экземпляра его необходимо приостановить.</value>
  </data>
  <data name="CannotUseAddServiceEndpointOverloadForWorkflowServices" xml:space="preserve">
    <value>Класс WorkflowServiceHost не поддерживает добавление конечных точек приложений с использованием перегруженной версии AddServiceEndpoint ServiceEndpoint endpoint).  Используйте одну из перегруженных версий "XName serviceContractName" или "string implementedContract", чтобы добавить конечные точки приложений в класс WorkflowServiceHost.</value>
  </data>
  <data name="CannotUseInputsWithLoad" xml:space="preserve">
    <value>Входные данные рабочего процесса не могут использоваться с операциями Load и LoadRunnableInstance, поскольку они предоставляются только для новых экземпляров.</value>
  </data>
  <data name="CannotValidateNullObject" xml:space="preserve">
    <value>Аргумент ToValidate действия {0} с именем "{1}" разрешен в пустое значение.  Переданный объект не должен быть пустым.</value>
  </data>
  <data name="CannotWaitForIdleSynchronously" xml:space="preserve">
    <value>Операция закончилась с ошибкой, так как была вызвана из обработчика, когда рабочий процесс не находился в состоянии простоя.  Для выполнения операции требуется, чтобы рабочий процесс находился в состоянии простоя, и рабочий процесс не может ее выполнить, если она находится в обработчике событий.</value>
  </data>
  <data name="CanOnlyAbortDirectChildren" xml:space="preserve">
    <value>Действие может прерывать только свои прямые дочерние действия.</value>
  </data>
  <data name="CanOnlyCancelDirectChildren" xml:space="preserve">
    <value>Действие может отменять только свои прямые дочерние действия.</value>
  </data>
  <data name="CanOnlyGetOwnedArguments" xml:space="preserve">
    <value>Действие может получать расположение только тех аргументов, владельцем которых является.  Действие "{0}" пытается получить расположение аргумента "{1}", владельцем которого является действие "{2}".</value>
  </data>
  <data name="CanOnlyScheduleDirectChildren" xml:space="preserve">
    <value>Действие может планировать только своих непосредственных потомков. Действие "{0}" пытается запланировать действие "{1}", которое является потомком действия "{2}".</value>
  </data>
  <data name="CantFindTimerExtension" xml:space="preserve">
    <value>Расширение TimerExtension должно быть добавлено в коллекцию расширений.</value>
  </data>
  <data name="CatchOrFinallyExpected" xml:space="preserve">
    <value>Действию TryCatch "{0}" требуется аргумент Catch или Finally.</value>
  </data>
  <data name="ChangeConditionalTransitionToUnconditionalBlockDU" xml:space="preserve">
    <value>StateMachine не поддерживает динамическое обновление, если условный переход становится безусловным после обновления.</value>
  </data>
  <data name="ChangeTransitionTypeDuringTransitioningBlockDU" xml:space="preserve">
    <value>StateMachine не поддерживает динамическое обновление, если состояние меняется, а текущий переход стал условным.</value>
  </data>
  <data name="ChangingTriggerOrUseOriginalConditionActionBlockDU" xml:space="preserve">
    <value>StateMachine не поддерживает динамическое обновление, если триггер существующего перехода изменен, или действие Condition или Action переназначено новому переходу.</value>
  </data>
  <data name="CleanupInProgress" xml:space="preserve">
    <value>Блокировка SqlWorkflowInstanceStore не может обработать команду, поскольку в настоящее время выполняется очистка хранилища. Дождитесь окончания очистки и повторите попытку.</value>
  </data>
  <data name="CollectionActivityRequiresCollection" xml:space="preserve">
    <value>Свойство "Collection" элемента "{0}" не инициализировано.</value>
  </data>
  <data name="ColumnNumberTooLarge" xml:space="preserve">
    <value>Указанный номер столбца для действия {0} слишком велик и не поддерживается системой частичной проверки</value>
  </data>
  <data name="CommandExecutionCannotOverlap" xml:space="preserve">
    <value>Для одного InstanceHandle в каждый момент времени может выполниться только одна команда. Не вызывайте метод Execute или BeginExecute для InstanceStore, пока не завершится предыдущая команда, выполняющаяся для этого InstanceHandle.</value>
  </data>
  <data name="CompensableActivityAlreadyConfirmedOrCompensated" xml:space="preserve">
    <value>Действие CompensableActivity, указанное маркером CompensationToken "Target", уже подтверждено или компенсировано.</value>
  </data>
  <data name="CompensableActivityInsideTransactedReceiveScope" xml:space="preserve">
    <value>Действие CompensableActivity нельзя вложить в область TransactedReceiveScope.</value>
  </data>
  <data name="CompensableActivityInsideTransactionScopeActivity" xml:space="preserve">
    <value>Действие CompensableActivity не может быть вложено в действие TransactionScope.</value>
  </data>
  <data name="CompensateWithNoTargetConstraint" xml:space="preserve">
    <value>Использование действия Compensate без указания аргумента Target допускается только в обработчиках Compensation, Confirmation или Cancellation.</value>
  </data>
  <data name="CompensateWithoutCompensableActivity" xml:space="preserve">
    <value>Действие компенсации "{0}" может быть использовано, только если действие CompensableActivity в рабочем процессе уже выполнено.</value>
  </data>
  <data name="CompensationHandlerFatalException" xml:space="preserve">
    <value>Необработанное исключение создано обработчиком компенсации, принадежащим "{0}". Работа по компенсации может быть в несогласованном состоянии, рабочий процесс прерван.</value>
  </data>
  <data name="CompensationState" xml:space="preserve">
    <value>CompensableActivity "{0}" находится в состоянии "{1}".</value>
  </data>
  <data name="CompiledExpressionIdNotFound" xml:space="preserve">
    <value>Не удалось найти идентификатор выражения для "{0}". Убедитесь, что текущее определение скомпилировано.</value>
  </data>
  <data name="CompiledExpressionsActivityException" xml:space="preserve">
    <value>TextExpressionCompiler: Исключение типа "{0}" возникло при обработке действия "{1}": "{2}".</value>
  </data>
  <data name="CompiledExpressionsCacheMetadataException" xml:space="preserve">
    <value>CacheMetadata для действия "{0}" вызвало "{1}".</value>
  </data>
  <data name="CompiledExpressionsDuplicateName" xml:space="preserve">
    <value>"{0}" является неоднозначной ссылкой на переменную. Переименуйте идентификатор.</value>
  </data>
  <data name="CompiledExpressionsIgnoringInvalidIdentifierVariable" xml:space="preserve">
    <value>TextExpressionCompiler: Пропуск переменной "{0}". Идентификатор не является допустимым для текущего языка.</value>
  </data>
  <data name="CompiledExpressionsIgnoringUnnamedVariable" xml:space="preserve">
    <value>TextExpressionCompiler: Пропуск переменной без имени.</value>
  </data>
  <data name="CompiledExpressionsNoCompiledRoot" xml:space="preserve">
    <value>Не удалось найти экземпляр действия, соответствующий действию "{0}". Перекомпилируйте рабочий процесс.</value>
  </data>
  <data name="CompiledLocationNoDefaultConstructor" xml:space="preserve">
    <value>Скомпилированные выражения требуют наличия конструктора по умолчанию в локальном корне. Добавьте конструктор по умолчанию для типа "{0}".</value>
  </data>
  <data name="CompiledLocationReferenceGetLocation" xml:space="preserve">
    <value>CompiledLocationReference никогда не следует использовать для доступа к расположению.</value>
  </data>
  <data name="CompilerError" xml:space="preserve">
    <value>Обнаружены ошибки компилятора.</value>
  </data>
  <data name="CompilerErrorSpecificExpression" xml:space="preserve">
    <value>Обнаружены ошибки компилятора при обработке выражения "{0}".{1}</value>
  </data>
  <data name="CompileVbExpressionStart" xml:space="preserve">
    <value>Компиляция выражения VB "{0}"</value>
  </data>
  <data name="CompileVbExpressionStop" xml:space="preserve">
    <value>Компиляция выражения VB завершена.</value>
  </data>
  <data name="CompleteBookmarkWorkItem" xml:space="preserve">
    <value>Выполнение элемента BookmarkWorkItem для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}". BookmarkName: {3}, BookmarkScope: {4}.</value>
  </data>
  <data name="CompleteCancelActivityWorkItem" xml:space="preserve">
    <value>Выполнение элемента CancelActivityWorkItem для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}".</value>
  </data>
  <data name="CompleteCompletionWorkItem" xml:space="preserve">
    <value>Выполнение элемента CompletionWorkItem для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}". Выполнение элемента Activity "{3}" завершено, DisplayName: "{4}", InstanceId: "{5}".</value>
  </data>
  <data name="CompletedMustNotHaveAssociatedKeys" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о загрузке экземпляра, который находится в состоянии InstanceState.Completed и для которого не завершены связанные ключи.</value>
  </data>
  <data name="CompleteExecuteActivityWorkItem" xml:space="preserve">
    <value>Выполнение элемента ExecuteActivityWorkItem для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}".</value>
  </data>
  <data name="CompleteFaultWorkItem" xml:space="preserve">
    <value>Выполнение элемента FaultWorkItem для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}". В элементе Activity "{3}" произошло исключение, DisplayName: "{4}", InstanceId: "{5}".</value>
  </data>
  <data name="CompleteRuntimeWorkItem" xml:space="preserve">
    <value>Выполнение рабочего элемента среды выполнения для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}".</value>
  </data>
  <data name="CompleteTransactionContextWorkItem" xml:space="preserve">
    <value>Выполнение элемента TransactionContextWorkItem для элемента Activity "{0}" завершено, DisplayName: "{1}", InstanceId: "{2}".</value>
  </data>
  <data name="CompletionConditionSetButNoBody" xml:space="preserve">
    <value>Недопустима ситуация, когда в объекте ParallelForEach значение свойства CompletionCondition равно null, а значение свойства Body не равно null. Необходимо предусмотреть присвоение свойству Body объекта ParallelForEach "{0}" действия с пустой последовательностью (Sequence).</value>
  </data>
  <data name="ConfirmationHandlerFatalException" xml:space="preserve">
    <value>Необработанное исключение создано обработчиком подтверждений, принадежащим "{0}". Работа по подтверждению может быть в несогласованном состоянии, рабочий процесс прерван.</value>
  </data>
  <data name="ConfirmWithNoTargetConstraint" xml:space="preserve">
    <value>Использование действия Confirm без указания аргумента Target допускается только в обработчиках Compensation, Confirmation или Cancellation.</value>
  </data>
  <data name="ConfirmWithoutCompensableActivity" xml:space="preserve">
    <value>Действие подтверждения "{0}" может быть использовано, только если действие CompensableActivity в рабочем процессе уже выполнено.</value>
  </data>
  <data name="ConflictingValueName" xml:space="preserve">
    <value>Имя свойства "{0}" (XName) для значения, предоставленного в метод DurableInstanceManager.AddInstanceOwnerValues, конфликтует с именем уже добавленного значения. Убедитесь, что имена всех значений, передаваемых в метод AddInstanceOwnerValues, уникальны. Данная ошибка может происходить по причине конфликта настроенных поведений служб.</value>
  </data>
  <data name="ConnectionStringNameWrong" xml:space="preserve">
    <value>Не удалось найти строку соединения для соединения "{0}".</value>
  </data>
  <data name="ConstructorInfoNotFound" xml:space="preserve">
    <value>Данные соответствующего конструктора не обнаружены в типе "{0}".</value>
  </data>
  <data name="ConstVariableCannotBeSet" xml:space="preserve">
    <value>Это расположение отмечено как константа, поэтому его значение невозможно изменить.</value>
  </data>
  <data name="ContextAlreadyBoundToInstance" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод BindInstance, чтобы задать идентификатор экземпляра InstanceHandle, который уже привязан к экземпляру. Дескриптор InstanceHandle в течение времени своего существования может привязываться только к одному экземпляру.</value>
  </data>
  <data name="ContextAlreadyBoundToLock" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод BindAcquiredLock, чтобы задать версию заблокированного экземпляра InstanceHandle, который уже привязан к блокировке. Дескриптор InstanceHandle в течение времени своего существования может привязываться только к одной блокировке.</value>
  </data>
  <data name="ContextAlreadyBoundToOwner" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод BindOwner, чтобы задать владельца InstanceHandle, который уже привязан к владельцу. Дескриптор InstanceHandle в течение времени своего существования может привязываться только к одному владельцу.</value>
  </data>
  <data name="ContextMismatchInContextAndCallBackContext" xml:space="preserve">
    <value>CorrelationCallbackContext и CorrelationContext заданы, однако указанные в них контексты не совпадают.</value>
  </data>
  <data name="ContextMustBeBoundToInstance" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод BindAcquiredLock, BindReclaimedLock, BeginBindReclaimedLock или CreateBindReclaimedLockException, чтобы привязать InstanceHandle к версии блокировки экземпляра, однако InstanceHandle не привязан к экземпляру. Перед привязкой дескриптора InstanceHandle к блокировке его нужно привязать к экземпляру.</value>
  </data>
  <data name="ContextMustBeBoundToOwner" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод BindAcquiredLock, BindReclaimedLock, BeginBindReclaimedLock или CreateBindReclaimedLockException, чтобы привязать InstanceHandle к версии блокировки экземпляра, однако InstanceHandle не привязан к владельцу. Перед привязкой дескриптора InstanceHandle к блокировке его нужно привязать к владельцу.</value>
  </data>
  <data name="ContextNotFromThisStore" xml:space="preserve">
    <value>Аргумент handle, передаваемый методам InstanceStore.Execute и InstanceStore.BeginExecute, должен быть создан путем вызова метода CreateInstanceHandle для этого же экземпляра InstanceStore.</value>
  </data>
  <data name="ContractInferenceValidationForTransactionFlowBehavior" xml:space="preserve">
    <value>Поведению TransactionFlow операции необходимо присвоить значение Allowed.</value>
  </data>
  <data name="ContractNotFoundInAddServiceEndpoint" xml:space="preserve">
    <value>Не удается добавить конечную точку, поскольку не удается найти описание контракта ContractDescription с параметрами Name="{0}" и Namespace="{1}".</value>
  </data>
  <data name="ControllerInvalidBeforeInitialize" xml:space="preserve">
    <value>WorkflowInstance.Controller доступен только после вызова Initialize.</value>
  </data>
  <data name="ConvertVariableToValueExpressionFailed" xml:space="preserve">
    <value>Не удается преобразовать переменную типа "{0}" в действие типа "{1}".</value>
  </data>
  <data name="CopyToIndexOutOfRange" xml:space="preserve">
    <value>Индекс массива должен быть положительным.</value>
  </data>
  <data name="CopyToNotEnoughSpaceInArray" xml:space="preserve">
    <value>У предоставленного массива недостаточно емкости для хранения значений.</value>
  </data>
  <data name="CopyToRankMustBeOne" xml:space="preserve">
    <value>Предоставленный массив имеет несколько измерений. Ранг массива должен быть равен единице, чтобы его можно было использовать с методом CopyTo.</value>
  </data>
  <data name="CorrelatedContextRequiredForAnonymousSend" xml:space="preserve">
    <value>Действие Send либо должно быть настроено с помощью конечной точки, либо скоррелировано с ранее установленным с помощью свойства CorrelatesWith контекстом.</value>
  </data>
  <data name="CorrelationHandleInUse" xml:space="preserve">
    <value>Дескриптор CorrelationHandle уже используется в экземпляре BookmarkScope "{0}", поэтому его нельзя использовать в экземпляре BookmarkScope "{1}".</value>
  </data>
  <data name="CorrelationResponseContextShouldNotBeNull" xml:space="preserve">
    <value>Контекст CorrelationResponse не должен быть равен null. Значение null может означать, что дескриптор корреляции настроен неправильно.</value>
  </data>
  <data name="CouldNotResolveNamespacePrefix" xml:space="preserve">
    <value>Не удается разрешить префикс пространства имен "{0}".</value>
  </data>
  <data name="CreateBookmark" xml:space="preserve">
    <value>Для элемента Activity "{0}" создана закладка Bookmark, DisplayName: "{1}", InstanceId: "{2}".  BookmarkName: {3}, BookmarkScope: {4}.</value>
  </data>
  <data name="CreateBookmarkScope" xml:space="preserve">
    <value>Создан объект BookmarkScope: {0}.</value>
  </data>
  <data name="CreateBookmarkScopeFailed" xml:space="preserve">
    <value>Данный класс BookmarkScopeHandle уже сопоставлен BookmarkScope.</value>
  </data>
  <data name="CreateWorkflowServiceHostStart" xml:space="preserve">
    <value>Запуск CreateWorkflowServiceHost</value>
  </data>
  <data name="CreateWorkflowServiceHostStop" xml:space="preserve">
    <value>Остановка CreateWorkflowServiceHost</value>
  </data>
  <data name="CSharpExpressionsMustBeCompiled" xml:space="preserve">
    <value>Выражения CSharp должны компилироваться.</value>
  </data>
  <data name="CurrentOperationCannotCreateInstance" xml:space="preserve">
    <value>Отсутствует контекст, связанный с входящим сообщением для службы, а текущая операция не снабжена атрибутом "CanCreateInstance = true". Для взаимодействия с этой службой проверьте, поддерживает ли входящая привязка протокол контекста и был ли инициализирован допустимый контекст.</value>
  </data>
  <data name="DanglingReceive" xml:space="preserve">
    <value>В потоке операций отсутствует операция Receive, парная с операцией SendReply. Убедитесь, что каждой операции SendReply соответствует операция Receive, присутствующая в потоке операций.</value>
  </data>
  <data name="DatabaseUpgradeRequiredForCommand" xml:space="preserve">
    <value>Хранилище SqlWorkflowInstanceStore содержит версию базы данных "{0}". Команда InstancePersistenceCommand "{1}" не может быть запущена для этой версии базы данных. Обновите базу данных до "{2}".</value>
  </data>
  <data name="DebugInfoCannotEvaluateExpression" xml:space="preserve">
    <value>Невозможно вычислить выражение "{0}" в текущем контексте.</value>
  </data>
  <data name="DebugInfoExceptionCaught" xml:space="preserve">
    <value>При вычислении {0} возникло исключение {1}.</value>
  </data>
  <data name="DebugInfoNotSkipArgumentResolution" xml:space="preserve">
    <value>*** значение не SkipArgumentResolution ***</value>
  </data>
  <data name="DebugInfoTryGetValueFailed" xml:space="preserve">
    <value>*** действие TryGetValue завершилось с ошибкой ***</value>
  </data>
  <data name="DebugInstrumentationFailed" xml:space="preserve">
    <value>Инструментирование отладчика завершилось с ошибкой.  Причина: {0}.</value>
  </data>
  <data name="DebugSymbolChecksumValueInvalid" xml:space="preserve">
    <value>Контрольная сумма, указанная в качестве отладочного символа, не прошла частичную проверку.</value>
  </data>
  <data name="DefaultAbortReason" xml:space="preserve">
    <value>Рабочий процесс прерван.</value>
  </data>
  <data name="DefaultCancelationRequiresCancelHasBeenRequested" xml:space="preserve">
    <value>Логика отмены по умолчанию требует, чтобы параметр HasCancelBeenRequested имел значение true.  Метод Cancel действия NativeActivity должен вызываться только средой выполнения.</value>
  </data>
  <data name="DefaultCreateOnlyReason" xml:space="preserve">
    <value>Поток операций создан со значением true для свойства WorkflowCreationContext.CreateOnly.</value>
  </data>
  <data name="DefaultInvalidWorkflowExceptionMessage" xml:space="preserve">
    <value>Недопустимая структура определения рабочего процесса. Используйте класс ActivityValidationServices, чтобы просмотреть все нарушения.</value>
  </data>
  <data name="DefaultSuspendReason" xml:space="preserve">
    <value>Рабочий процесс был приостановлен через контрольную конечную точку.</value>
  </data>
  <data name="DefaultTerminationReason" xml:space="preserve">
    <value>Рабочему процессу был отправлен запрос на завершение.</value>
  </data>
  <data name="DefaultWorkflowApplicationExceptionMessage" xml:space="preserve">
    <value>Операция не может быть выполнена, поскольку она не разрешена в текущем состоянии класса WorkflowApplication.</value>
  </data>
  <data name="DelegateArgumentAlreadyInUseOnActivity" xml:space="preserve">
    <value>Объект DelegateArgument "{0}" не может быть использован в действии "{1}", так как он уже используется действием "{2}".</value>
  </data>
  <data name="DelegateArgumentChangeBlockDU" xml:space="preserve">
    <value>Это действие является обработчиком ActivityDelegate, аргументы которого изменились.</value>
  </data>
  <data name="DelegateArgumentDoesNotExist" xml:space="preserve">
    <value>Объект DelegateArgument "{0} не существует в данной среде.</value>
  </data>
  <data name="DelegateArgumentMustBeReferenced" xml:space="preserve">
    <value>Объект DelegateArgument "{0}" перед использованием должен быть включен в класс ActivityDelegate действия.</value>
  </data>
  <data name="DelegateArgumentMustBeSet" xml:space="preserve">
    <value>Объект DelegateArgument должен быть задан до вызова метода CacheMetadata.</value>
  </data>
  <data name="DelegateArgumentNotVisible" xml:space="preserve">
    <value>Объект DelegateArgument ("{0}"), на который производится ссылка, невидим в данной области.</value>
  </data>
  <data name="DelegateArgumentTypeInvalid" xml:space="preserve">
    <value>DelegateArgument "{0}" нельзя использовать в выражении типа "{1}", поскольку он относится к несовместимому типу "{2}".</value>
  </data>
  <data name="DelegateHandlersCannotBeScheduledDirectly" xml:space="preserve">
    <value>Действие "{0}" попыталось напрямую запланировать действие-обработчик "{1}" ActivityDelegate.  Обработчики ActivityDelegate невозможно запланировать напрямую.  Вместо этого следует запланировать выполнение самого делегата ActivityDelegate.</value>
  </data>
  <data name="DelegateInArgumentTypeMismatch" xml:space="preserve">
    <value>Недействительный тип аргумента для входа делегата с именем "{0}".  Вход делегата имеет тип "{1}, а аргумент имеет тип "{2}".  Тип аргумента должен приводиться к типу входа делегата.</value>
  </data>
  <data name="DelegateOutArgumentTypeMismatch" xml:space="preserve">
    <value>Недействительный тип аргумента для выхода делегата с именем "{0}".  Выход делегата имеет тип "{1}, а аргумент имеет тип "{2}".  Тип выхода делегата должен приводиться к типу аргумента.</value>
  </data>
  <data name="DelegateParameterCannotBeModifiedAfterOpen" xml:space="preserve">
    <value>Параметр ActivityDelegateParameter "{0}" нельзя изменять. Делегат ActivityDelegate, который его использует, заблокирован. Делегат ActivityDelegate блокируется при вызове метода Invoke для элемента WorkflowElement, который является его владельцем, или при создании из него экземпляра WorkflowInstance.</value>
  </data>
  <data name="DelegateParameterDirectionalityMismatch" xml:space="preserve">
    <value>Направленностью параметра делегата действия "{0}" в словаре DelegateParameters является "{1}". Ожидаемой направленностью является "{2}".</value>
  </data>
  <data name="DictionaryIsReadOnly" xml:space="preserve">
    <value>Этот словарь доступен только для чтения и не может быть изменен.</value>
  </data>
  <data name="DifferentContractsSameConfigName" xml:space="preserve">
    <value>У двух различных контрактов совпадает имя ConfigurationName.</value>
  </data>
  <data name="DifferentWorkflowServiceNameNotSupported" xml:space="preserve">
    <value>Имя WorkflowService {0} в дополнительных версиях не соответствует имени {1} WorkflowService по умолчанию.</value>
  </data>
  <data name="DirectLambdaParameterReference" xml:space="preserve">
    <value>Невозможно сериализовать выражения с прямыми ссылками на лямбда-параметр.  Возможно, ссылка на переменную сформирована неправильно.</value>
  </data>
  <data name="DirectoryAborted" xml:space="preserve">
    <value>Работа каталога загруженных экземпляров прекращена. Выполняется непредвиденное завершение работы службы.</value>
  </data>
  <data name="DispatchOperationInInvalidState" xml:space="preserve">
    <value>Поведению WorkflowOperationBehavior не удается применить поведение диспетчера, поскольку экземпляр операции DispatchOperation находится в недопустимом состоянии.</value>
  </data>
  <data name="DoNotCompleteTryCommandWithPendingReclaim" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она завершила обработку запроса TryCommand, пока была активна попытка восстановления блокировки. Используйте поставщик сохраняемости, который не возвращает значение из TryCommand и не вызывает исключение в пределах TryCommand, завершите результат IAsyncResult, возвращенный из BeginTryCommand, перед завершением IAsyncResult, возвращенного из BeginBindReclaimedLock, или завершите работу перед вызовом исключения, возвращенного из CreateBindReclaimedLockException.</value>
  </data>
  <data name="DoNotSupportArrayIndexerOnNonArrayType" xml:space="preserve">
    <value>Индексатор ArrayIndexer не поддерживается в типе {0}, так как он не является типом массива.</value>
  </data>
  <data name="DoNotSupportArrayIndexerReferenceWithDifferentArrayTypeAndResultType" xml:space="preserve">
    <value>Класс ArrayIndexer в качестве LValue с типом массива {0} и типом результата {1} не поддерживается, поскольку они не одинаковы.</value>
  </data>
  <data name="DoNotSupportArrayIndexerValueWithIncompatibleArrayTypeAndResultType" xml:space="preserve">
    <value>Класс ArrayIndexer в качестве правостороннего значения с типом элемента массива {0} и типом результата {1} не поддерживается, так как {0} не совместимо с {1}.</value>
  </data>
  <data name="DoNotSupportArrayIndexerWithDifferentArrayTypeAndResultType" xml:space="preserve">
    <value>Индексатор ArrayIndexer с типом массива {0} и типом результата {1} не поддерживается, так как они не совпадают.</value>
  </data>
  <data name="DoNotSupportArrayIndexerWithNonIntIndex" xml:space="preserve">
    <value>Индексатор ArrayIndexer с типом индекса {0} не поддерживается, так как не является целочисленным (int).</value>
  </data>
  <data name="DoWhileRequiresCondition" xml:space="preserve">
    <value>Перед использованием действия DoWhile "{0}" необходимо задать условие.</value>
  </data>
  <data name="DUActivityTypeMismatch" xml:space="preserve">
    <value>Это действие в обновленном определении имеет тип "{0}", а в исходном определении - тип "{1}".</value>
  </data>
  <data name="DUActivityTypeMismatchRuntime" xml:space="preserve">
    <value>Тип действия изменяется в процессе обновления.</value>
  </data>
  <data name="DUDisallowIfCannotFindingMatchingCondition" xml:space="preserve">
    <value>StateMachine не поддерживает динамическое обновление, если триггер условного перехода удален, или действие Condition в обновленном определении переназначено из другого свойства.</value>
  </data>
  <data name="DuplexContractsNotSupported" xml:space="preserve">
    <value>Рабочий процесс не поддерживает контракты Duplex. Удалите свойство CallbackContract из атрибута ServiceContractAttribute. </value>
  </data>
  <data name="DuplicateAnnotationName" xml:space="preserve">
    <value>Не удалось добавить заметку с именем "{0}". Проверьте запросы профиля отслеживания на повторяющиеся имена в заметках или переменных среды. </value>
  </data>
  <data name="DuplicateCatchClause" xml:space="preserve">
    <value>Для типа {0} уже существует предложение catch. Для каждого уникального типа исключения CLR может быть добавлено только одно предложение catch.</value>
  </data>
  <data name="DuplicateCorrelationQuery" xml:space="preserve">
    <value>Обнаружен дубликат запроса CorrelationQuery с параметром Where="{0}". Это дубликат не будет использоваться при расчете корреляции.</value>
  </data>
  <data name="DuplicatedContract" xml:space="preserve">
    <value>Несколько реализованных типов контрактов содержат контракт "{0}" и операцию "{1}".</value>
  </data>
  <data name="DuplicateDefinitionIdentity" xml:space="preserve">
    <value>WorkflowService с ({0}) DefinitionIdentity уже существует.</value>
  </data>
  <data name="DuplicateEvaluationOrderValues" xml:space="preserve">
    <value>Действие "{0}" имеет несколько аргументов среды выполнения, для которых порядок оценки имеет значение "{1}". Значения порядка оценки аргументов среды выполнения должны быть уникальными.</value>
  </data>
  <data name="DuplicateImportAttribute" xml:space="preserve">
    <value>Свойство "{0}" операции DynamicActivity "{1}" имеет более одного атрибута ImportAttribute. Для одного свойства разрешается указывать только один атрибут ImportAttribute.</value>
  </data>
  <data name="DuplicateInstanceKeyExists" xml:space="preserve">
    <value>Значение ключа экземпляра "{0}" уже существует. Это могло произойти из-за того, что определено несколько наборов MessageQuerySets, вычисляющих один и тот же CorrelationKey.</value>
  </data>
  <data name="DuplicateInstrumentation" xml:space="preserve">
    <value>Дублировать инструментарий для {0}.  Возможно прерывание выполнения отладчиком в неверном местоположении.</value>
  </data>
  <data name="DuplicateMethodFound" xml:space="preserve">
    <value>Неоднозначное совпадение. Действие "{0}" имеет несколько открытых методов "{1}" с именем "{2}" и совпадающими типами параметров, аргументов универсального типа и ограничений общего типа, передаваемыми в метод InvokeMethod "{3}".</value>
  </data>
  <data name="DuplicateOriginActivityActivity" xml:space="preserve">
    <value>Объект того же происхождения "{0}" используется действиями "{1}" и "{2}".</value>
  </data>
  <data name="DuplicateOriginActivityVariable" xml:space="preserve">
    <value>Объект того же происхождения "{0}" используется действием "{1}" и переменной "{2}".</value>
  </data>
  <data name="DuplicateOriginVariableVariable" xml:space="preserve">
    <value>Объект того же происхождения "{0}" используется переменными "{1}" и "{2}".</value>
  </data>
  <data name="DurationIsNegative" xml:space="preserve">
    <value>Значение аргумента Duration в действии Delay "{0}" отрицательно.</value>
  </data>
  <data name="DUTriggerOrConditionChangedDuringTransitioning" xml:space="preserve">
    <value>StateMachine не поддерживает динамическое обновление, если состояние меняется, а текущий переход был изменен.</value>
  </data>
  <data name="DynamicActivityDuplicatePropertyDetected" xml:space="preserve">
    <value>Свойство с именем "{0}" уже существует в коллекции DynamicActivity.Properties.</value>
  </data>
  <data name="DynamicActivityMultipleExpressionLanguages" xml:space="preserve">
    <value>Указанное определение действия содержит несколько языков действий выражений, требующих компиляции (обнаружено языков: "{0}"). Для одного определения разрешено указывать только один язык, требующий компиляции. Преобразуйте все действия выражений, требующие компиляции, в один язык.</value>
  </data>
  <data name="EmptyCorrelationQueryResults" xml:space="preserve">
    <value>Запрос корреляции выдал пустой результирующий набор. Убедитесь, что запросы корреляции для конечной точки настроены правильно.</value>
  </data>
  <data name="EmptyGuidOnDeserializedInstance" xml:space="preserve">
    <value>Идентификатор десериализованного экземпляра состоит только из нулей (Guid.Empty). Сериализованный экземпляр должен иметь ненулевой идентификатор.</value>
  </data>
  <data name="EmptyIdReturnedFromHost" xml:space="preserve">
    <value>Реализация свойства "Id" узла потока операций типа "{0}" возвратила нулевой идентификатор. Реализация WorkflowInstance должна возвращать идентификатор экземпляра, отличный от Guid.Empty.</value>
  </data>
  <data name="EndpointAddressNotSetInEndpoint" xml:space="preserve">
    <value>Не удалось получить EndpointAddress из конечной точки, файла конфигурации и контекста обратного вызова. Это могло произойти из-за того, что ни в конечной точке, ни в ее конфигурации не задано действие с OperationName="{0}".</value>
  </data>
  <data name="EndpointIncorrectlySet" xml:space="preserve">
    <value>Свойства Endpoint и EndpointConfigurationName задаются в действии "{0}" при помощи параметра OperationName="{1}". За один раз можно задать только одно из них.</value>
  </data>
  <data name="EndpointNotSet" xml:space="preserve">
    <value>Действие "{0}" с параметром OperationName="{1}" должно задавать или конечную точку, или свойство EndpointConfigurationName.</value>
  </data>
  <data name="EndSqlCommandExecute" xml:space="preserve">
    <value>Окончание выполнения команды SQL: {0}</value>
  </data>
  <data name="EnlistedTransactionPropertiesRequireIsolationBlocks" xml:space="preserve">
    <value>Свойство TransactionProperty с параметром enlistWorkflowState, имеющим значение true, должно быть добавлено в блок изоляции.</value>
  </data>
  <data name="EnterNoPersistBlock" xml:space="preserve">
    <value>Выполняется вход в непостоянный блок.</value>
  </data>
  <data name="EnumeratorNotStarted" xml:space="preserve">
    <value>Перечисление не запущено. Вызовите метод MoveNext.</value>
  </data>
  <data name="EnvironmentDisposed" xml:space="preserve">
    <value>Объект LocationEnvironment доступен только из области условия, в которое он был передан.</value>
  </data>
  <data name="ErrorExtractingValuesForLambdaRewrite" xml:space="preserve">
    <value>При попытки извлечения целевого объекта типа "{0}" из выражения вызова метода "{1}" произошла ошибка.  Учтите, что выражение, которое определяет объект типа "{0}", не должно требовать контекст времени выполнения.  Ошибка: {2}</value>
  </data>
  <data name="ErrorsEncounteredWhileProcessingTree" xml:space="preserve">
    <value>При обработке дерева рабочих процессов произошли следующие ошибки:</value>
  </data>
  <data name="ErrorTimeToPersistLessThanZero" xml:space="preserve">
    <value>Значение TimeToPersist должно быть больше или равно TimeSpan.Zero. Для отключения присвойте значение, равное TimeSpan.MaxValue.</value>
  </data>
  <data name="ErrorTimeToUnloadLessThanZero" xml:space="preserve">
    <value>Значение TimeToUnload должно быть больше или равно TimeSpan.Zero. Для отключения присвойте значение, равное TimeSpan.MaxValue.</value>
  </data>
  <data name="EtwAPIMaxStringCountExceeded" xml:space="preserve">
    <value>Количество строковых аргументов, переданных в Etw WriteEvent, превысило максимальный допустимый предел {0}.</value>
  </data>
  <data name="EtwMaxNumberArgumentsExceeded" xml:space="preserve">
    <value>Количество аргументов, переданных в Etw WriteEvent, превысило максимальный допустимый предел {0}.</value>
  </data>
  <data name="EtwRegistrationFailed" xml:space="preserve">
    <value>Ошибка регистрации ETW с кодом ошибки {0}.</value>
  </data>
  <data name="EtwUnhandledException" xml:space="preserve">
    <value>Необработанное исключение. Сведения об исключении: {0}</value>
  </data>
  <data name="ExclusiveHandleRegisterBookmarkScopeFailed" xml:space="preserve">
    <value>Метод RegisterBookmarkScope может быть вызван, только если нет закладок в области соответствующего класса ExclusiveHandle.</value>
  </data>
  <data name="ExclusiveHandleReinitializeFailed" xml:space="preserve">
    <value>Повторная инициализация может быть произведена только при отсутствии закладок, зарегистрированных в классе ExclusiveHandle.</value>
  </data>
  <data name="ExecuteMustBeNested" xml:space="preserve">
    <value>Недопустимая реализация InstanceStore в поставщике сохраняемости. Она пытается одновременно выполнить несколько вложенных команд. Для каждого вызова InstanceStore.TryCommand (или BeginTryCommand) в каждый момент времени разрешается только один вызов метода InstancePersistenceContext.Execute (или BeginExecute). Эта ошибка указывает на недопустимую реализацию поставщика сохраняемости.</value>
  </data>
  <data name="ExecuteWorkItemStart" xml:space="preserve">
    <value>Запуск выполнения рабочего элемента</value>
  </data>
  <data name="ExecuteWorkItemStop" xml:space="preserve">
    <value>Остановка выполнения рабочего элемента</value>
  </data>
  <data name="ExecutionPropertyAlreadyDefined" xml:space="preserve">
    <value>Свойство с именем "{0}" уже было определено в этой области. Чтобы заменить текущее свойство, сначала удалите его, а затем добавьте новое.</value>
  </data>
  <data name="ExitNoPersistBlock" xml:space="preserve">
    <value>Выполняется выход из непостоянного блока.</value>
  </data>
  <data name="ExpressionRequiredForConversion" xml:space="preserve">
    <value>Для преобразования требуется выражение.</value>
  </data>
  <data name="ExtensionsCannotBeModified" xml:space="preserve">
    <value>WorkflowInstanceExtensionsManager нельзя изменять, если он был связан с WorkflowInstance.</value>
  </data>
  <data name="ExtensionsCannotBeSetByIndex" xml:space="preserve">
    <value>Коллекция расширений не поддерживает установку расширений по индексу. Используйте методы Add и Remove.</value>
  </data>
  <data name="ExtensionTypeNotSupported" xml:space="preserve">
    <value>Добавление расширения типа "{0}" не поддерживается WorkflowServiceHost.</value>
  </data>
  <data name="ExternalLocationsGetOnly" xml:space="preserve">
    <value>Расположение, которое вы пытаетесь задать, относится к классу SymbolResolver. Расположения класса SymbolResolver предназначены только для чтения.</value>
  </data>
  <data name="ExtraOverloadGroupPropertiesConfigured" xml:space="preserve">
    <value>Перегруженная группа"{0}" уже настроена. Настройка свойства "{1}" в перегруженной группе "{2}" является ошибкой.</value>
  </data>
  <data name="ExtraParameter" xml:space="preserve">
    <value>Параметр "{0}" не объявлен в операции "{1}" контракта "{2}".</value>
  </data>
  <data name="ExtraReturnValue" xml:space="preserve">
    <value>Действие содержит возвращаемое сообщение, а контракт не содержит возвращаемого значения.</value>
  </data>
  <data name="FailedToCreateSecurityToken" xml:space="preserve">
    <value>Не удалось создать токен безопасности "{0}".</value>
  </data>
  <data name="FailedToGetInstanceIdForControlOperation" xml:space="preserve">
    <value>Не удалось получить идентификатор экземпляра из сообщения для этой операции управления. Это может быть вызвано несовпадением контракта. Убедитесь в том, что контракт клиента совпадает с контрактом конечной точки службы.</value>
  </data>
  <data name="FailedToGetWorkflowIdentityForControlOperation" xml:space="preserve">
    <value>Не удалось получить WorkflowIdentity из сообщения для этой операции управления. Это может быть вызвано несовпадением контрактов. Убедитесь в том, что контракт клиента совпадает с контрактом конечной точки службы.</value>
  </data>
  <data name="FailedToInitializeRequestReplyCorrelationHandle" xml:space="preserve">
    <value>В действии Receive, настроенном с операцией запроса-ответа "{0}", не удалось инициализировать дескриптор RequestReplyCorrelation. В свойстве CorrelationMessageProperty полученного сообщения должен содержаться ключ InstanceKey со значением RequestReplyCorrelation.</value>
  </data>
  <data name="FailedToLoadBindingInControlEndpoint" xml:space="preserve">
    <value>Не удалось загрузить привязку "{0}" с конфигурацией "{1}" для стандартной конечной точки управления "{2}".</value>
  </data>
  <data name="FailFastMessage" xml:space="preserve">
    <value>Произошла неустранимая ошибка. В целях диагностики приводится сообщение на английском языке, связанное с ошибкой: "{0}".</value>
  </data>
  <data name="FaultContextNotFound" xml:space="preserve">
    <value>При повторном создании исключения действию "{0}" не удается найти класс FaultContext, заданный в действии TryCatch. Чтобы решить данную проблему, не изменяйте и не удаляйте класс FaultContext из коллекции свойств исполнения.</value>
  </data>
  <data name="FaultTypeMismatch" xml:space="preserve">
    <value>Указанный тип ошибки "{0}" не существует для операции "{1}" в контракте "{2}".</value>
  </data>
  <data name="FinalStateCannotHaveProperty" xml:space="preserve">
    <value>Конечное состояние "{0}" не должно содержать действие {1}.</value>
  </data>
  <data name="FinalStateCannotHaveTransition" xml:space="preserve">
    <value>Конечное состояние "{0}" не должно содержать никаких исходящих транзиций.</value>
  </data>
  <data name="FirstParameterDoesnotMatchTheReturnValue" xml:space="preserve">
    <value>Первый параметр типа "{0}", указанный в содержимом, не соответствует типу "{1}", указанному для возвращаемого значения операции "{2}" в контракте "{3}".</value>
  </data>
  <data name="FlowchartContainsReferences" xml:space="preserve">
    <value>Блок-схема не поддерживает динамическое обновление, если она содержит ссылки на импортированных потомков.</value>
  </data>
  <data name="FlowchartContainsUnconnectedNodes" xml:space="preserve">
    <value>Прежде чем можно будет использовать блок-схему "{0}", все узлы должны быть подключены, если для ValidateUnconnectedNodes установлено значение True.</value>
  </data>
  <data name="FlowchartEmpty" xml:space="preserve">
    <value>Блок-схема "{0}" была выполнена без узлов.</value>
  </data>
  <data name="FlowchartMissingStartNode" xml:space="preserve">
    <value>Блок-схема "{0}" не имеет начального узла (StartNode).</value>
  </data>
  <data name="FlowchartNextNull" xml:space="preserve">
    <value>Блок-схема "{0}"/FlowStep: узел Next имеет значение null. Выполнение блок-схемы будет завершено.</value>
  </data>
  <data name="FlowchartStart" xml:space="preserve">
    <value>Блок-схема "{0}": запуск запланирован.</value>
  </data>
  <data name="FlowchartSwitchCase" xml:space="preserve">
    <value>Блок-схема "{0}"/FlowSwitch: выбрано действие Case "{1}".</value>
  </data>
  <data name="FlowchartSwitchCaseNotFound" xml:space="preserve">
    <value>Блок-схема "{0}"/FlowSwitch: не удалось найти ни действие Case, ни действие Default Case, соответствующее результату выражения Expression. Выполнение блок-схемы будет завершено.</value>
  </data>
  <data name="FlowchartSwitchDefault" xml:space="preserve">
    <value>Блок-схема "{0}"/FlowSwitch: выбрано действие Default Case.</value>
  </data>
  <data name="FlowDecisionRequiresCondition" xml:space="preserve">
    <value>Перед использованием действия FlowDecision в блок-схеме "{0}" необходимо задать условие.</value>
  </data>
  <data name="FlowedTransactionDifferentFromAmbient" xml:space="preserve">
    <value>Поточная транзакция отличается от внешней транзакции.</value>
  </data>
  <data name="FlowNodeCannotBeShared" xml:space="preserve">
    <value>Узел FlowNode не может использоваться совместно разными блок-схемами. Он уже используется в блок-схеме "{0}" и не может использоваться в блок-схеме "{1}".</value>
  </data>
  <data name="FlowNodeLockedForRuntime" xml:space="preserve">
    <value>Узел FlowNode в блок-схеме"{0}" уже открыт и не может быть изменен. Узел FlowNode можно изменять только во время разработки.</value>
  </data>
  <data name="FlowSwitchRequiresExpression" xml:space="preserve">
    <value>Перед использованием переключателя FlowSwitch в блок-схеме "{0}" необходимо задать выражение.</value>
  </data>
  <data name="ForEachRequiresNonNullValues" xml:space="preserve">
    <value>Перед использованием действия ForEach "{0}" необходимо привязать значения к непустому выражению.</value>
  </data>
  <data name="FoundProcessingError" xml:space="preserve">
    <value>Не удалось выполнить команду: {0}</value>
  </data>
  <data name="GeneratedAndProvidedMapConflict" xml:space="preserve">
    <value>В этом действии имеются конфликтующие изменения. Изменения произведены картой реализации и текущим обновлением. Действие совершило попытку сохранить исходные значения в обе карты.</value>
  </data>
  <data name="GeneratedAndProvidedMapConflictRuntime" xml:space="preserve">
    <value>В этом действии имеются конфликтующие изменения. Изменения произведены обновлением реализации и обновлением более крупного рабочего процесса. Действие совершило попытку сохранить исходные значения в оба обновления.</value>
  </data>
  <data name="GenericInstanceCommand" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand с именем {0} прервано из-за ошибки.</value>
  </data>
  <data name="GenericInstanceCommandNull" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано из-за ошибки.</value>
  </data>
  <data name="GetLocationOnPublicAccessReference" xml:space="preserve">
    <value>Действию "{0}" не удается вызвать метод GetLocation для этой ссылки на открытое местоположение, так как она была создана методом CodeActivityPublicEnvironmentAccessor.TryGetAccessToPublicLocation. Чтобы прочитать или записать значение, используйте методы ActivityContext.GetValue или SetValue. Чтобы получить прямой доступ к местоположению, объявите его с помощью метода CodeActivityPublicEnvironmentAccessor.TryGetReferenceToPublicLocation.</value>
  </data>
  <data name="GetParameterTypeMismatch" xml:space="preserve">
    <value>Параметр по индексу {0} был запрошен в InstancePersistenceAction с именем {1} с использованием неверного аргумента универсального типа. При вызове метода GetParameter&lt;T&gt; тип, указанный в аргументе T, должен соответствовать типу параметра в документации.</value>
  </data>
  <data name="GetRunnableRequiresOwner" xml:space="preserve">
    <value>Перед вызовом этого метода укажите поддерживаемые идентификаторы определения для этого узла рабочего процесса, вызвав метод WorkflowApplication.CreateDefaultInstanceOwner.</value>
  </data>
  <data name="GuidCannotBeEmpty" xml:space="preserve">
    <value>Аргумент должен быть ненулевым идентификатором GUID.</value>
  </data>
  <data name="HandledException" xml:space="preserve">
    <value>Обработка исключения. Сведения об исключении: {0}</value>
  </data>
  <data name="HandledExceptionError" xml:space="preserve">
    <value>Обработка исключения. Сведения об исключении: {0}</value>
  </data>
  <data name="HandledExceptionVerbose" xml:space="preserve">
    <value>Обработка исключения. Сведения об исключении: {0}</value>
  </data>
  <data name="HandledExceptionWarning" xml:space="preserve">
    <value>Обработка исключения. Сведения об исключении: {0}</value>
  </data>
  <data name="HandleFreed" xml:space="preserve">
    <value>Выполнение команд InstancePersistenceCommands было отменено, поскольку дескриптор InstanceHandle был освобожден.</value>
  </data>
  <data name="HandleFreedBeforeInitialized" xml:space="preserve">
    <value>Метод Free нельзя вызывать для дескриптора InstanceHandle во время выполнения для этого дескриптора метода OnNewInstanceHandle.</value>
  </data>
  <data name="HandleFreedInDirectory" xml:space="preserve">
    <value>Выполнение команд InstancePersistenceCommand отменено, поскольку освобожден дескриптор InstanceHandle.</value>
  </data>
  <data name="HandleInitializationContextDisposed" xml:space="preserve">
    <value>К контексту HandleInitializationContext можно обратиться только из области функции, в которую он был передан.</value>
  </data>
  <data name="HandleNotInitialized" xml:space="preserve">
    <value>Дескриптор не инициализирован.  Дескрипторы должны создаваться и инициализироваться средой выполнения, и являются допустимыми только в той области, в которой они объявлены.</value>
  </data>
  <data name="HasExecutingChildrenNoPersist" xml:space="preserve">
    <value>Несохраняемые блоки могут быть настроены только когда нет выполняемых дочерних действий.</value>
  </data>
  <data name="HostIdDoesNotMatchInstance" xml:space="preserve">
    <value>Идентификатор экземпляра, переданный узлом потока операций, {0}, не совпадает с идентификатором, хранящимся в сериализованном экземпляре, {1}. Компьютер не может десериализовать экземпляр с идентификатором, отличным от идентификатора, использованного при его сериализации.</value>
  </data>
  <data name="HostLockExpired" xml:space="preserve">
    <value>Срок действия блокировки SqlWorkflowInstanceStore истек. Это могло произойти из-за того, что SQL Server занят или соединение временно потеряно.</value>
  </data>
  <data name="HostLockNotFound" xml:space="preserve">
    <value>Блокировка SqlWorkflowInstanceStore не существует в базе данных. Это могло произойти из-за того, что SQL Server занят или соединение временно потеряно.</value>
  </data>
  <data name="IdentityControlCharacter" xml:space="preserve">
    <value>WorkflowIdentity.Name и пакет не могут содержать управляющие символы (символы Юникода категории Cc).</value>
  </data>
  <data name="IdentityNameSemicolon" xml:space="preserve">
    <value>WorkflowIdentity.Name не может содержать символ точки с запятой ";".</value>
  </data>
  <data name="IdentityNotSupportedWithActivation" xml:space="preserve">
    <value>SqlWorkflowInstanceStore не поддерживает активацию для InstanceOwners, которые указывают DefinitionIdentities.</value>
  </data>
  <data name="IdentityWhitespace" xml:space="preserve">
    <value>WorkflowIdentity.Name и Package не могут содержать начальные или конечные пробелы (категории символов Юникода Zl, Zp или Zs).</value>
  </data>
  <data name="IdNotFoundInWorkflow" xml:space="preserve">
    <value>Не удается найти в рабочем процессе указанный идентификатор "{0}". Проверьте рабочий процесс на наличие ошибок проверки подлинности, способные создавать поддеревья, которые нельзя просмотреть.</value>
  </data>
  <data name="ImplementationVersionMismatch" xml:space="preserve">
    <value>Параметр ImplementationVersion ("{0}") загруженного экземпляра действия не соответствует параметру ImplementationVersion ("{1}") указанного действия ("{2}"). Экземпляр можно обновить путем применения карты реализации.</value>
  </data>
  <data name="InArgumentBound" xml:space="preserve">
    <value>В аргументе "{0}" элемента Activity "{1}", DisplayName: "{2}", InstanceId: объект "{3}" был связан со следующим значением: {4}.</value>
  </data>
  <data name="IncompatibleArgumentType" xml:space="preserve">
    <value>Этому методу передан аргумент неверного типа. Для этого метода ожидается аргумент типа {0}, однако ему передан аргумент типа {1}.</value>
  </data>
  <data name="IncompatibleTypeForMultidimensionalArrayItemReference" xml:space="preserve">
    <value>Универсальный тип "{0}" несовместим с типом действительного элемента "{1}" операнда Array в MultidimensionalArrayItemReference.</value>
  </data>
  <data name="IncorrectIndexForArgument" xml:space="preserve">
    <value>Неправильный индекс для возвращаемого аргумента в коллекции "{0}". Задана позиция "{1}", тогда как ожидалась позиция "{2}".</value>
  </data>
  <data name="IncorrectValueType" xml:space="preserve">
    <value>Из хранилища экземпляров извлечено значение неверного типа.  Ожидалось значение типа {0}, вместо него обнаружено значение типа {1}.</value>
  </data>
  <data name="IndexOutOfBounds" xml:space="preserve">
    <value>Значение индекса ({0}) равно или больше длины массива ({1}).</value>
  </data>
  <data name="IndicesAreNeeded" xml:space="preserve">
    <value>Для {0} действия "{1}" необходимо задать хотя бы одно значение индекса.</value>
  </data>
  <data name="InferredContractDescription" xml:space="preserve">
    <value>Описание ContractDescription с параметрами Name="{0}" и Namespace="{1}" было выведено из WorkflowService.</value>
  </data>
  <data name="InferredOperationDescription" xml:space="preserve">
    <value>Описание OperationDescription с параметром Name="{0}" в контракте "{1}" было выведено из WorkflowService. IsOneWay={2}.</value>
  </data>
  <data name="InitializationIncomplete" xml:space="preserve">
    <value>Инициализация экземпляра действия не завершена.  Эта ошибка возникает при сбое выражения по умолчанию для переменной или выражения аргумента, и обработчик исключений позволяет продолжить выполнение.</value>
  </data>
  <data name="InitializeCorrelationRequiresWorkflowServiceHost" xml:space="preserve">
    <value>Действие "{0}" необходимо использовать в узле службы WorkflowServiceHost.</value>
  </data>
  <data name="InitialMetadataCannotBeDeleted" xml:space="preserve">
    <value>Значение сохраняемости с именем {0} указывается в качестве исходного значения метаданных и поэтому должно иметь допустимое InstanceValue, отличное от InstanceValue.DeletedValue.</value>
  </data>
  <data name="InitialStateCannotBeFinalState" xml:space="preserve">
    <value>Начальное состояние "{0}" не должно также быть конечным.</value>
  </data>
  <data name="InitialStateNotInStatesCollection" xml:space="preserve">
    <value>Исходное состояние "{0}" должно быть добавлено в коллекцию States конечного автомата.</value>
  </data>
  <data name="InlinedLocationReferenceOnlyAccessibleByOwner" xml:space="preserve">
    <value>Действие "{0}" не имеет доступа к этой ссылке на открытое расположение, поскольку она допустима только для действия "{1}". Ссылку на открытое расположение может использовать только действие, получившее ее.</value>
  </data>
  <data name="InputParametersCountMismatch" xml:space="preserve">
    <value>Количество переданных входных параметров {0} не соответствует ожидаемому количеству {1}.</value>
  </data>
  <data name="InputParametersMissing" xml:space="preserve">
    <value>Ожидаемый входной параметр с именем "{0}" не обнаружен.</value>
  </data>
  <data name="InputParametersTypeMismatch" xml:space="preserve">
    <value>Для параметра с именем "{1}" ожидалось значение входного параметра типа "{0}".</value>
  </data>
  <data name="InstanceCollisionDefault" xml:space="preserve">
    <value>Выполнение команды InstancePersistenceCommand было прервано, так как экземпляр уже был сохранен в хранилище экземпляров.</value>
  </data>
  <data name="InstanceCollisionSpecific" xml:space="preserve">
    <value>Выполнение команды InstancePersistenceCommand было прервано, так как экземпляр "{0}" уже был сохранен в хранилище экземпляров.</value>
  </data>
  <data name="InstanceCompleteDefault" xml:space="preserve">
    <value>Выполнение команды InstancePersistenceCommand было прервано, так как экземпляр уже выполнен.</value>
  </data>
  <data name="InstanceCompleteSpecific" xml:space="preserve">
    <value>Выполнение команды InstancePersistenceCommand было прервано, так как экземпляр "{0}" уже выполнен.</value>
  </data>
  <data name="InstanceHandleConflictDefault" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано, поскольку другой допустимый InstanceHandle удерживает блокировку экземпляра, что указывает на то, что уже загружена неустаревшая копия экземпляра. Следует использовать загруженную копию экземпляра и связанный с ней InstanceHandle либо выгрузить ее.</value>
  </data>
  <data name="InstanceHandleConflictSpecific" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано, поскольку другой допустимый InstanceHandle удерживает блокировку экземпляра "{0}", что указывает на то, что уже загружена неустаревшая копия экземпляра. Следует использовать загруженную копию экземпляра и связанный с ней InstanceHandle либо выгрузить ее.</value>
  </data>
  <data name="InstanceKeyMetadataChangesNotSupported" xml:space="preserve">
    <value>SqlWorkflowInstanceStore не поддерживает изменение метаданных для уже существующих ключей.</value>
  </data>
  <data name="InstanceKeyRequiresValidGuid" xml:space="preserve">
    <value>Ключ InstanceKey нельзя создать со значением, состоящим только из нулей, например Guid.Empty. Чтобы получить InstanceKey, состоящий только из нулей, используйте InstanceKey.InvalidKey.</value>
  </data>
  <data name="InstanceLockedUnderTransaction" xml:space="preserve">
    <value>Не удалось выполнить операцию управления "{0}" над экземпляром службы с идентификатором "{1}". В настоящее время выполняется активная операция транзакционного контроля.</value>
  </data>
  <data name="InstanceLockLostDefault" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand, прервано из-за разблокирования экземпляра. Эта ошибка означает, что копия экземпляра, находящаяся в памяти, устарела и ее необходимо удалить вместе с InstanceHandle.</value>
  </data>
  <data name="InstanceLockLostSpecific" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand, прервано из-за разблокирования экземпляра "{0}". Эта ошибка означает, что копия экземпляра, находящаяся в памяти, устарела и ее необходимо удалить вместе с InstanceHandle.</value>
  </data>
  <data name="InstanceLocksRecoveryError" xml:space="preserve">
    <value>Не удалось восстановить блокировки экземпляров, поскольку обнаружено следующее исключение</value>
  </data>
  <data name="InstanceMethodCallRequiresTargetObject" xml:space="preserve">
    <value>Для вызова метода экземпляра требуется целевой объект.</value>
  </data>
  <data name="InstanceMustBePaused" xml:space="preserve">
    <value>Для выполнения этой операции экземпляр должен быть приостановлен.</value>
  </data>
  <data name="InstanceMustNotBePaused" xml:space="preserve">
    <value>Для выполнения этой операции экземпляр не должен быть приостановлен.</value>
  </data>
  <data name="InstanceMustNotBeSuspended" xml:space="preserve">
    <value>Эту операцию невозможно выполнить, поскольку экземпляр приостановлен.</value>
  </data>
  <data name="InstanceNotReadyDefault" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано, поскольку экземпляр еще не сохранен в хранилище экземпляров.</value>
  </data>
  <data name="InstanceNotReadySpecific" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано, поскольку экземпляр "{0}" еще не сохранен в хранилище экземпляров.</value>
  </data>
  <data name="InstanceOperationRequiresInstance" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о выполнении операции, для которой требуется экземпляр, однако к операции не привязан экземпляр.</value>
  </data>
  <data name="InstanceOperationRequiresLock" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о выполнении операции, для которой требуется удерживать блокировку экземпляра, однако блокировка не удерживается.</value>
  </data>
  <data name="InstanceOperationRequiresNotCompleted" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о выполнении операции, для которой экземпляр должен иметь состояние, отличное от InstanceState.Completed, но экземпляр находится именно в этом состоянии.</value>
  </data>
  <data name="InstanceOperationRequiresNotUninitialized" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о выполнении операции, для которой экземпляр должен иметь состояние, отличное от InstanceState.Uninitialized, но экземпляр находится именно в этом состоянии.</value>
  </data>
  <data name="InstanceOperationRequiresOwner" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о выполнении операции, для которой требуется владелец экземпляра, однако к операции не привязан владелец.</value>
  </data>
  <data name="InstanceOwnerDefault" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано, поскольку регистрация владельца экземпляра стала недействительной. Эта ошибка означает, что находящиеся в памяти копии всех экземпляров, заблокированных данным владельцем, устарели и их необходимо удалить вместе с дескрипторами InstanceHandle. Для устранения этой ошибки обычно лучше всего перезагрузить узел.</value>
  </data>
  <data name="InstanceOwnerSpecific" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано, поскольку регистрация владельца экземпляра с идентификатором "{0}" стала недействительной. Эта ошибка означает, что находящиеся в памяти копии всех экземпляров, заблокированных данным владельцем, устарели и их необходимо удалить вместе с дескрипторами InstanceHandle. Для устранения этой ошибки обычно лучше всего перезагрузить узел.</value>
  </data>
  <data name="InstanceRequired" xml:space="preserve">
    <value>Системе сохранения экземпляров не удалось обработать недопустимую команду InstancePersistenceCommand. Для этой команды требуется экземпляр, однако к дескриптору InstanceHandle не привязан экземпляр.</value>
  </data>
  <data name="InstanceStoreBoundSameVersionTwice" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она дважды сообщила о получении и фиксации одной версии блокировки для одного экземпляра. Каждый раз, когда для экземпляра получается блокировка, версия блокировки должна увеличиваться. В противном случае в качестве версии блокировки всегда следует возвращать значение 0. Если поставщик обнаруживает, что владелец экземпляра пытается заблокировать уже заблокированный экземпляр, то поставщик должен вызвать метод BindReclaimedLock, BeginBindReclaimedLock или CreateBeginBindReclaimedLockException вместо метода BindAcquiredLock.</value>
  </data>
  <data name="InstanceStoreDoesntMatchWorkflowApplication" xml:space="preserve">
    <value>Экземпляр настроен с InstanceStore, который отличается от этого WorkflowApplication.</value>
  </data>
  <data name="InstanceStoreFailed" xml:space="preserve">
    <value>Реализация InstanceStore создало исключение InstancePersistenceException. Исключение InstancePersistenceException является внутренним исключением.</value>
  </data>
  <data name="InstanceStoreHasDefaultOwner" xml:space="preserve">
    <value>Это InstanceStore уже имеет DefaultInstanceOwner.</value>
  </data>
  <data name="InstanceStoreReadOnly" xml:space="preserve">
    <value>SqlWorkflowInstanceStore доступен только для чтения, дальнейшая настройка невозможна. Конфигурация SqlWorkflowInstanceStore должна быть полностью завершена до создания первого InstanceHandle.</value>
  </data>
  <data name="InstanceStoreRequiredToPersist" xml:space="preserve">
    <value>Только приложения WorkflowApplications, которые были настроены с помощью InstanceStore, могут быть сохранены или выгружены.</value>
  </data>
  <data name="InstanceSuspended" xml:space="preserve">
    <value>Экземпляр службы с идентификатором "{1}" находится в настоящий момент в состоянии "Suspended". Не удалось выполнить операцию управления "{0}".</value>
  </data>
  <data name="InsufficientArraySize" xml:space="preserve">
    <value>Размер массива равен {0}, и этого недостаточно для хранения результатов операции.</value>
  </data>
  <data name="InternalCacheMetadataStart" xml:space="preserve">
    <value>InternalCacheMetadata запущено для действия "{0}".</value>
  </data>
  <data name="InternalCacheMetadataStop" xml:space="preserve">
    <value>InternalCacheMetadata остановлено для действия "{0}".</value>
  </data>
  <data name="InternalConstraintException" xml:space="preserve">
    <value>Во внутреннем ограничении возникло исключение при применении ограничения с именем "{0}" к действию типа {1} с именем "{2}".  Исключением было: {3}</value>
  </data>
  <data name="InternalServerError" xml:space="preserve">
    <value>Серверу не удалось обработать запрос из-за внутренней ошибки.  Для получения дополнительных сведений об ошибке либо включите на сервере параметр IncludeExceptionDetailInFaults (или в атрибуте ServiceBehaviorAttribute, или в поведении конфигурации &lt;serviceDebug&gt;), чтобы отправить сведения об исключении обратно клиенту, либо включите трассировку, как описано в документации к пакету SDK для платформы Microsoft .NET Framework 4.0, и изучите журналы трассировки на сервере.</value>
  </data>
  <data name="InvalidActivityIdFormat" xml:space="preserve">
    <value>Переданный идентификатор действия имел недопустимый формат.  Он должен быть списком целочисленных значений, разделенных точками, например "1.12.3", без начальных и конечных точек.</value>
  </data>
  <data name="InvalidActivityToBlockUpdate" xml:space="preserve">
    <value>Действие "{0}" в DynamicUpdateMapBuilder.DisallowUpdateInside не является открытым элементом DynamicUpdateMapBuilder.UpdatedWorkflowDefinition. Убедитесь, что это действие является элементом обновленного определения рабочего процесса. Если это действие было удалено как элемент обновления, не требуется явно блокировать обновление. Обновление автоматически блокируется, если удаленное действие запущено.</value>
  </data>
  <data name="InvalidActivityToBlockUpdateServices" xml:space="preserve">
    <value>Действие "{0}" не является открытым элементом обновленного WorkflowDefinition. Убедитесь, что это действие является элементом обновленного определения рабочего процесса. Если это действие было удалено как элемент обновления, не требуется явно блокировать обновление. Обновление автоматически блокируется, если удаленное действие запущено.</value>
  </data>
  <data name="InvalidArgumentExpression" xml:space="preserve">
    <value>Выражение аргумента номер {0} типа "{1}" недопустимо.</value>
  </data>
  <data name="InvalidAsyncBeginMethodSignature" xml:space="preserve">
    <value>Недопустимая сигнатура асинхронного метода Begin для метода {0} в типе {1}. Метод Begin должен принимать параметр AsyncCallback и объект, в качестве двух последних аргументов, и возвращать параметр IAsyncResult.</value>
  </data>
  <data name="InvalidAsyncCancelMethodSignature" xml:space="preserve">
    <value>Недопустимая сигнатура асинхронного метода Cancel для метода {0} в типе {1}. Метод Cancel не должен принимать аргументы и возвращать значения типа void.</value>
  </data>
  <data name="InvalidAsyncEndMethodSignature" xml:space="preserve">
    <value>Недопустимая сигнатура асинхронного метода End для метода {0} в типе {1}. Метод End должен принимать в качестве последнего аргумента параметр IAsyncResult. </value>
  </data>
  <data name="InvalidAsyncResult" xml:space="preserve">
    <value>Методу "End" передан неверный результат IAsyncResult. Объект IAsyncResult, передаваемый методу "End", должен возвращаться из соответствующего метода "Begin" или передаваться в обратный вызов, указанный для "Begin".</value>
  </data>
  <data name="InvalidAsyncResultImplementation" xml:space="preserve">
    <value>Неверная реализация интерфейса IAsyncResult может возвращать неверные значения свойства CompletedSynchronously или несколько раз вызывать AsyncCallback. Возможно, тип {0} реализован неверно.</value>
  </data>
  <data name="InvalidAsyncResultImplementationGeneric" xml:space="preserve">
    <value>Неверная реализация интерфейса IAsyncResult может возвращать неверные значения свойства CompletedSynchronously или несколько раз вызывать AsyncCallback.</value>
  </data>
  <data name="InvalidCallbackState" xml:space="preserve">
    <value>Объекту состояния обратного вызова должны быть переданы допустимые данные {0}.</value>
  </data>
  <data name="InvalidCompensateActivityUsage" xml:space="preserve">
    <value>Действие компенсации "{0}" с незаданным входным аргументом InArgument "Target" можно использовать только в контексте обработчика компенсации, подтверждения или отмены.</value>
  </data>
  <data name="InvalidCompensationToken" xml:space="preserve">
    <value>Переменная, связываемая с InArgument "Target", имеет значение NULL. InArgument "Target" необходимо задавать с помощью допустимого CompensationToken, полученного из CompensableActivity. В противном случае, если требуется использовать Compensation или Confirmation, не задавайте "Target" InArgument и не используйте действие "{0}" в контексте обработчика компенсации, подтверждения или отмены.</value>
  </data>
  <data name="InvalidConfirmActivityUsage" xml:space="preserve">
    <value>Действие подтверждения "{0}" с unset "Target" InArgument можно использовать только в контексте обработчика компенсации, подтверждения или отмены.</value>
  </data>
  <data name="InvalidDataFromReceiveBookmarkState" xml:space="preserve">
    <value>Не удалось получить допустимый контекст MessageContext при возобновлении вкладки для операции получения "{0}".</value>
  </data>
  <data name="InvalidDataFromSendBookmarkState" xml:space="preserve">
    <value>Не удалось получить допустимое свойство CorrelationMessageProperty при возобновлении вкладки для операции отправки "{0}".</value>
  </data>
  <data name="InvalidDirectionForArgument" xml:space="preserve">
    <value>Для аргумента в коллекции "{0}" в позиции {1} указано неправильное направление. Указано направление "{2}", ожидалось направление "{3}".</value>
  </data>
  <data name="InvalidDynamicActivityProperty" xml:space="preserve">
    <value>Недопустимый дескриптор свойства. Указанный компонент не содержит свойство, соответствующее этому дескриптору ({0}).</value>
  </data>
  <data name="InvalidEvaluationOrderValue" xml:space="preserve">
    <value>Недопустимое значение EvaluationOrder. Значения порядка оценки должны начинаться с нуля, возрастать и быть уникальными. Для обозначения того, что порядок оценки не задан, используйте значение "-1".</value>
  </data>
  <data name="InvalidExecutionCallback" xml:space="preserve">
    <value>"{0}" является недопустимым обратным вызовом выполнения действия. Обратный вызов, используемый "{1}", должен быть методом экземпляра в "{1}".</value>
  </data>
  <data name="InvalidExpressionForLocation" xml:space="preserve">
    <value>Расположение нельзя создать из выражения типа "{0}".</value>
  </data>
  <data name="InvalidExpressionProperty" xml:space="preserve">
    <value>Свойство "Expression" типа "{0}" является недопустимым.</value>
  </data>
  <data name="InvalidFileName" xml:space="preserve">
    <value>Для действия {0} было указано недопустимое имя файла</value>
  </data>
  <data name="InvalidGenericTypeInfo" xml:space="preserve">
    <value>Тип "{0}" содержит некоторые недопустимые данные универсального типа.</value>
  </data>
  <data name="InvalidIdleAction" xml:space="preserve">
    <value>Возвращенное значение PersistableIdleAction выходит за границы диапазона.  Оно должно иметь значение None, Unload или Persist.</value>
  </data>
  <data name="InvalidImplementationAsWorkflowRoot" xml:space="preserve">
    <value>Чтобы карта реализации была непосредственно применена к экземпляру рабочего процесса, корень ее определения не должен иметь открытых/импортированных потомков или открытых/импортированных делегатов.</value>
  </data>
  <data name="InvalidImplementationAsWorkflowRootForRuntimeState" xml:space="preserve">
    <value>Чтобы карта реализации была непосредственно применена к экземпляру рабочего процесса, корень ее определения не должен иметь открытых/импортированных потомков. Экземпляр имеет один или несколько запущенных в настоящее время открытых потомков.</value>
  </data>
  <data name="InvalidImplementationAsWorkflowRootForRuntimeStateBecauseArgumentsChanged" xml:space="preserve">
    <value>Чтобы карта реализации была непосредственно применена к экземпляру рабочего процесса, она должна показывать, что изменений аргументов не производилось. Карта реализации показывает, что аргументы определения действия были изменены.</value>
  </data>
  <data name="InvalidImplementationMap" xml:space="preserve">
    <value>Указанная карта реализации не соответствует определению действия. Убедитесь, что версия действия, на которое ссылается обновленный рабочий процесс, совпадает с версией, указанной в карте реализации.]D;]A;    ]D;]A;Подробные сведения об устранении неполадок: число элементов в карте: "{0}"; число элементов в определении: "{1}".</value>
  </data>
  <data name="InvalidImplementationMapAssociation" xml:space="preserve">
    <value>Карта реализации, указанная для действия "{0}" с помощью DynamicUpdateMapBuilder.LookupImplementationMap, не может быть использована, так как действие не имеет потомков реализации. Убедитесь, что метод SetImplementationMap был вызван для нужного действия.</value>
  </data>
  <data name="InvalidImplementationMapAssociationServices" xml:space="preserve">
    <value>Карта реализации, указанная для действия "{0}" с помощью DynamicUpdateServices.SetImplementationMap, не может быть использована, так как действие не имеет потомков реализации. Убедитесь, что метод SetImplementationMap был вызван для нужного действия.</value>
  </data>
  <data name="InvalidImplementationMapRuntime" xml:space="preserve">
    <value>При построении карты обновления для этого действия была указана неправильная карта реализации.</value>
  </data>
  <data name="InvalidInstanceId" xml:space="preserve">
    <value>Для загрузки экземпляра использован недопустимый идентификатор экземпляра, состоящий только из нулей (Guid.Empty).</value>
  </data>
  <data name="InvalidInstanceState" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о загрузке экземпляра с недопустимым значением InstanceState.</value>
  </data>
  <data name="InvalidKey" xml:space="preserve">
    <value>Для загрузки или создания экземпляра использован недопустимый ключ.</value>
  </data>
  <data name="InvalidKeyArgument" xml:space="preserve">
    <value>В качестве аргумента был передан недопустимый ключ, состоящий из одних нулей, например Guid.Empty.</value>
  </data>
  <data name="InvalidLocationExpression" xml:space="preserve">
    <value>Недопустимое выражение расположения: отсутствуют скобки "[...]5D;".</value>
  </data>
  <data name="InvalidLockRenewalPeriod" xml:space="preserve">
    <value>Предоставленный период обновления блокировки {0} меньше, чем минимальный период обновления блокировки {1}.</value>
  </data>
  <data name="InvalidLockToken" xml:space="preserve">
    <value>Объект instanceVersion, передаваемый в InstancePersistenceContext.BindAcquiredLock, должен иметь положительное значение, если в поставщике сохраняемости реализовано управление версиями блокировки, и нулевое значение - в противном случае.</value>
  </data>
  <data name="InvalidLValueExpression" xml:space="preserve">
    <value>Недопустимое L-значение в выражении.</value>
  </data>
  <data name="InvalidMergeMap" xml:space="preserve">
    <value>Карта на позиции "{0}" (с отсчетом от нуля) для идентификатора действия "{1}" не соответствует предшествующей карте (картам). Убедитесь, что все карты представляют последовательные обновления одного определения рабочего процесса.]D;]A;    ]D;]A;Подробные сведения об устранении неполадок: {2}.</value>
  </data>
  <data name="InvalidMergeMapArgumentCount" xml:space="preserve">
    <value>Ожидаемое число исходных аргументов = "{0}", фактическое число = "{1}".</value>
  </data>
  <data name="InvalidMergeMapArgumentsChanged" xml:space="preserve">
    <value>Непредвиденное изменение в аргументах (название, направление, тип или порядок).</value>
  </data>
  <data name="InvalidMergeMapEnvironmentCount" xml:space="preserve">
    <value>Число ожидавшихся исходных аргументов = "{0}", число открытых переменных = "{1}", число закрытых переменных = "{2}". Число фактических исходных аргументов = "{3}", число открытых переменных = "{4}", число закрытых переменных = "{5}".</value>
  </data>
  <data name="InvalidMergeMapForImplementation" xml:space="preserve">
    <value>Ожидаемый ForImplementation = "{0}", фактический = "{1}".</value>
  </data>
  <data name="InvalidMergeMapMemberCount" xml:space="preserve">
    <value>Ожидаемое число исходных элементов = "{0}", фактическое = "{1}".</value>
  </data>
  <data name="InvalidMetadataValue" xml:space="preserve">
    <value>Указанное значение для свойства метаданных "{0}" должен принадлежать к типу {1}.</value>
  </data>
  <data name="InvalidNullAsyncResult" xml:space="preserve">
    <value>Значение null возвращено из асинхронного метода "Begin" или передано в AsyncCallback. Асинхронные реализации "Begin" должны возвращать объект IAsyncResult, отличный от null, и передавать его в качестве параметра AsyncCallback.</value>
  </data>
  <data name="InvalidOriginalWorkflowDefinitionForImplementationMapCreation" xml:space="preserve">
    <value>Предоставленное построителю карты определение OriginalWorkflowDefinition недопустимо для создания карты реализации, так как оно не имеет потомков реализации.</value>
  </data>
  <data name="InvalidParameterInfo" xml:space="preserve">
    <value>Данные числового параметра ({0}) недопустимы в типе "{1}".</value>
  </data>
  <data name="InvalidPrepareForRuntimeValidationSettings" xml:space="preserve">
    <value>Рабочий процесс не может быть подготовлен для выполнения, если любому из параметров SingleLevel, SkipValidatingRootConfiguration или OnlyUseAdditionalConstraints задано значение ValidationSettings.</value>
  </data>
  <data name="InvalidProperty" xml:space="preserve">
    <value>Свойство ({0}) недопустимо или не определено.</value>
  </data>
  <data name="InvalidPropertyType" xml:space="preserve">
    <value>Не удалось разрешить тип "{0}" свойства "{1}".</value>
  </data>
  <data name="InvalidReceiveStateForDU" xml:space="preserve">
    <value>Операция Receive находится в состоянии, в котором обновление экземпляра не поддерживается. Обновление может быть выполнено, только если операция Receive ожидает сообщения с запросом на стороне сервера.</value>
  </data>
  <data name="InvalidRootMergeMap" xml:space="preserve">
    <value>Карта на позиции "{0}" (с отсчетом от нуля) не соответствует предшествующей карте (картам). Убедитесь, что все карты представляют последовательные обновления одного определения рабочего процесса.]D;]A;    ]D;]A;Подробные сведения об устранении неполадок: {1}</value>
  </data>
  <data name="InvalidRunnableInstancesDetectionPeriod" xml:space="preserve">
    <value>Указанный период обнаружения доступных для выполнения экземпляров {0} меньше минимального допустимого периода {1}.</value>
  </data>
  <data name="InvalidRuntimeState" xml:space="preserve">
    <value>Указанное значение не является допустимым состоянием среды выполнения.</value>
  </data>
  <data name="InvalidSemaphoreExit" xml:space="preserve">
    <value>Метод синхронизации объектов был вызван из несинхронизированного блока кода.</value>
  </data>
  <data name="InvalidServiceImplementation" xml:space="preserve">
    <value>WorkflowServiceHost требует, чтобы объект serviceImplementation относился к Activity или WorkflowService.</value>
  </data>
  <data name="InvalidSourceLocationColumn" xml:space="preserve">
    <value>Номер столбца должен быть больше 0 (1 разряд). Недопустимо: {0} = {1}.</value>
  </data>
  <data name="InvalidSourceLocationLineNumber" xml:space="preserve">
    <value>Номер строки должен быть больше 0 (1 разряд). Недопустимо: {0} = {1}.</value>
  </data>
  <data name="InvalidStateForAsyncCallback" xml:space="preserve">
    <value>Объект IAsyncResult, переданный в асинхронный обратный вызов, имеет недопустимое состояние AsyncState.</value>
  </data>
  <data name="InvalidStateInAsyncResult" xml:space="preserve">
    <value>Указан недопустимый контекст состояния результата выполнения асинхронной операции.</value>
  </data>
  <data name="InvalidTypeConverterUsage" xml:space="preserve">
    <value>Недопустимое использование класса TypeConverter.</value>
  </data>
  <data name="InvalidTypeForArgument" xml:space="preserve">
    <value>Тип, указанный для аргумента в коллекции "{0}" в позиции {1}, не соответствует ожидаемому типу. Указан тип "{2}", ожидаемый тип: "{3}".</value>
  </data>
  <data name="InvalidUnhandledExceptionAction" xml:space="preserve">
    <value>Значение возвращенного UnhandledExceptionAction выходит за пределы диапазона. Допустимы следующие значения: Abort, Cancel или Terminate.</value>
  </data>
  <data name="InvalidUpdatedWorkflowDefinitionForImplementationMapCreation" xml:space="preserve">
    <value>Предоставленное построителю карты определение UpdatedWorkflowDefinition недопустимо для создания карты реализации, так как оно не имеет потомков реализации.</value>
  </data>
  <data name="InvalidUpdateMap" xml:space="preserve">
    <value>Указанная карта не соответствует определению рабочего процесса. Убедитесь, что эта карта подходит для этого определения, а сериализованная карта не была изменена вручную.]D;]A;    ]D;]A;Подробные сведения об устранении неполадок: {0}</value>
  </data>
  <data name="InvalidVisualBasicSettingsValue" xml:space="preserve">
    <value>Свойство Settings имеет недействительное значение. Задайте в качестве значения свойства Settings пустую строку или строку "Ссылки на сборки и импортированные пространства имен сериализованы в качестве пространств имен XML".</value>
  </data>
  <data name="InvalidXamlMember" xml:space="preserve">
    <value>Идентификатор "{0}" недопустим в языке XAML.</value>
  </data>
  <data name="InvokedMethodThrewException" xml:space="preserve">
    <value>Возникло исключение в методе, вызванном операцией "{0}". {1}</value>
  </data>
  <data name="InvokeMethodDoesNotUseAsyncPattern" xml:space="preserve">
    <value>Метод InvokeMethod "{0}": в методе не используется асинхронная модель.</value>
  </data>
  <data name="InvokeMethodIsNotStatic" xml:space="preserve">
    <value>Метод InvokeMethod "{0}": метод не является статическим.</value>
  </data>
  <data name="InvokeMethodIsStatic" xml:space="preserve">
    <value>Метод InvokeMethod "{0}": метод является статическим.</value>
  </data>
  <data name="InvokeMethodUseAsyncPattern" xml:space="preserve">
    <value>Метод InvokeMethod "{0}": в методе используется асинхронная модель "{1}" и "{2}".</value>
  </data>
  <data name="IsolationLevelValidation" xml:space="preserve">
    <value>Значение объекта IsolationLevel вложенного действия TransactionScope должно быть равно значению его родителя.</value>
  </data>
  <data name="ITextExpressionParameterMustBeActivity" xml:space="preserve">
    <value>параметр "выражение" должен иметь тип Activity.</value>
  </data>
  <data name="KeyAlreadyAssociated" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о связывания ключа с экземпляром, с которым уже связан ключ.</value>
  </data>
  <data name="KeyAlreadyCompleted" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о завершении уже завершенного ключа.</value>
  </data>
  <data name="KeyAlreadyUnassociated" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила об отмене связи для ключа, который был связан с текущим экземпляром, но не был завершен.</value>
  </data>
  <data name="KeyCollectionUpdatesNotAllowed" xml:space="preserve">
    <value>Изменение коллекции ключей, полученных из словаря, запрещено.</value>
  </data>
  <data name="KeyCollisionDefault" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано из-за конфликта ключей.</value>
  </data>
  <data name="KeyCollisionSpecific" xml:space="preserve">
    <value>Выполнение команды InstancePersistenceCommand было прервано из-за конфликта ключей. Ключ экземпляра со значением "{1}" не может быть сопоставлен экземпляру "{0}", так как он уже сопоставлен другому экземпляру, "{2}".</value>
  </data>
  <data name="KeyCollisionSpecificKeyOnly" xml:space="preserve">
    <value>Выполнение команды InstancePersistenceCommand было прервано из-за конфликта ключей. Ключ экземпляра со значением "{0}" не может быть сопоставлен экземпляру, так как он уже сопоставлен другому экземпляру.</value>
  </data>
  <data name="KeyCompleteDefault" xml:space="preserve">
    <value>Выполнение команды InstancePersistenceCommand было прервано, так как ключ экземпляра уже завершен.</value>
  </data>
  <data name="KeyCompleteSpecific" xml:space="preserve">
    <value>Выполнение команды InstancePersistenceCommand было прервано, так как ключ экземпляра "{0}" уже завершен.</value>
  </data>
  <data name="KeyNotAssociated" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о завершении или изменении ключа, который не связан с текущим экземпляром.</value>
  </data>
  <data name="KeyNotCompleted" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила об отмене связи для ключа, который еще не завершен.</value>
  </data>
  <data name="KeyNotFoundInDictionary" xml:space="preserve">
    <value>Данный ключ отсутствует в словаре.</value>
  </data>
  <data name="KeyNotReadyDefault" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано, поскольку ключ экземпляра не связан с экземпляром. Возможно, экземпляр или ключ были очищены либо ключ является недопустимым. Ключ может быть недопустимым, если сообщение, из которого он создан, отправлено в неверное время или содержит неверные данные корреляции.</value>
  </data>
  <data name="KeyNotReadySpecific" xml:space="preserve">
    <value>Выполнение InstancePersistenceCommand прервано, поскольку ключ экземпляра "{0}" не связан с экземпляром. Возможно, экземпляр или ключ были очищены либо ключ является недопустимым. Ключ может быть недопустимым, если сообщение, из которого он создан, отправлено в неверное время или содержит неверные данные корреляции.</value>
  </data>
  <data name="LambdaExpressionReturnTypeInvalid" xml:space="preserve">
    <value>Лямбда-выражение не должно возвращать данные типа null или void.</value>
  </data>
  <data name="LambdaExpressionTypeRequired" xml:space="preserve">
    <value>Приведенное выражение должно быть LambdaExpression.</value>
  </data>
  <data name="LambdaNotXamlSerializable" xml:space="preserve">
    <value>Данный рабочий процесс содержит в коде лямбда-выражения. Эти выражения XAML-несериализуемы. Чтобы сделать рабочий процесс XAML-сериализуемым, используйте или VisualBasicValue/VisualBasicReference, или ExpressionServices.Convert(lambda). При этом лямбда-выражения будут преобразованы в действия выражений.</value>
  </data>
  <data name="LineNumberTooLarge" xml:space="preserve">
    <value>Указанный номер строки для действия {0} слишком велик и не поддерживается системой частичной проверки</value>
  </data>
  <data name="LiteralsMustBeValueTypesOrImmutableTypes" xml:space="preserve">
    <value>Литерал поддерживает только типы значений и неизменяемый тип {0}.  Тип {1} не может использоваться в качестве литерала.</value>
  </data>
  <data name="LoadedWriteOnlyValue" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о загрузке InstanceValue с заданным свойством InstanceValueOptions.WriteOnly. Значения, доступные только для записи, не должны загружаться.</value>
  </data>
  <data name="LoadingAborted" xml:space="preserve">
    <value>Загрузка экземпляра прервана.</value>
  </data>
  <data name="LoadingWorkflowApplicationRequiresInstanceStore" xml:space="preserve">
    <value>Для WorkflowApplication необходимо задать допустимый InstanceStore перед вызовом метода Load или LoadRunnableInstance.</value>
  </data>
  <data name="LoadOpAssociateKeysCannotContainLookupKey" xml:space="preserve">
    <value>Если не указан LoadWorkflowByInstanceKeyCommand.AssociateLookupKeyToInstanceId, то необходимо заранее связать LookupInstanceKey с экземпляром. В противном случае команда LoadWorkflowByInstanceKeyCommand завершится ошибкой. Поэтому нельзя указывать LookupInstanceKey в коллекции InstanceKeysToAssociate, если не задан AssociateLookupKeyToInstanceId.</value>
  </data>
  <data name="LoadOpFreeKeyRequiresAcceptUninitialized" xml:space="preserve">
    <value>Если указан LoadByKeyOperation.InstanceIdForFreeKey, свойство AcceptUninitializedInstance должен иметь значение true. Свободный ключ будет связан с неинициализированным экземпляром с заданным идентификатором.</value>
  </data>
  <data name="LoadOpKeyMustBeValid" xml:space="preserve">
    <value>Ключ используется для поиска экземпляра, значения LoadByKeyOperation.LookupKey не должны быть равны нулю, например Guid.Empty.</value>
  </data>
  <data name="LocationExpressionCouldNotBeResolved" xml:space="preserve">
    <value>Не удалось разрешить в переменную или свойство выражение расположения "{0}". Убедитесь, что выражение расположения можно разрешить в переменную или свойство, определенное в иерархии области.</value>
  </data>
  <data name="LocationTypeMismatch" xml:space="preserve">
    <value>Не удается получить расположение с именем "{0}" как тип "{1}", поскольку оно имеет тип "{2}".  Необходимо точное соответствие типов, поскольку расположение предоставляет доступ и для чтения, и для записи.</value>
  </data>
  <data name="LockRetryTimeout" xml:space="preserve">
    <value>Истекло время ожидания при получении блокировки экземпляра.  Не удалось выполнить операцию за выделенное время ожидания {0}. Возможно, время, выделенное на эту операцию, входит в более продолжительное время ожидания.</value>
  </data>
  <data name="LockTimeoutExceptionMessage" xml:space="preserve">
    <value>Не удалось объявить блокировку за выделенное время ожидания {0}. Время, выделенное на эту операцию, может быть составной частью более продолжительного времени ожидания.</value>
  </data>
  <data name="MapEntryNotFound" xml:space="preserve">
    <value>Сущности обновления карты для действия "{0}" не найдено.</value>
  </data>
  <data name="MarkCanceledOnlyCallableIfCancelRequested" xml:space="preserve">
    <value>Метод MarkCanceled могут вызывать только действия, отмена которых запрошена. Перед вызовом этого метода проверьте ActivityInstance.HasCancelBeenRequested.</value>
  </data>
  <data name="MaximumRetriesExceededForSqlCommand" xml:space="preserve">
    <value>Выполнено максимальное количество повторов команды SQL. Дальнейшие попытки выполняться не будут.</value>
  </data>
  <data name="MaxInstancesExceeded" xml:space="preserve">
    <value>Система достигла предела, заданного для ограничителя "MaxConcurrentInstances". Для этого ограничителя был задан предел {0}. Значение ограничителя можно изменить, изменив атрибут "maxConcurrentInstances" в элементе serviceThrottle или изменив свойство "MaxConcurrentInstances" для поведения ServiceThrottlingBehavior.</value>
  </data>
  <data name="MaxPendingMessagesPerChannelExceeded" xml:space="preserve">
    <value>Был достигнут предел регулирования "{0}" для "MaxPendingMessagesPerChannel". Для увеличения этого предела настройте свойство MaxPendingMessagesPerChannel для поведения BufferedReceiveServiceBehavior.</value>
  </data>
  <data name="MaxPendingMessagesPerChannelMustBeGreaterThanZero" xml:space="preserve">
    <value>Предел глушителя должен быть больше нуля. Чтобы отключить, установите значение Int32.MaxValue.</value>
  </data>
  <data name="MayBindLockCommandShouldValidateOwner" xml:space="preserve">
    <value>В команде InstancePersistenceCommand, которая возвращает значение true из AutomaticallyAcquiringLock, также должен переопределяться метод Validate, чтобы вызывать исключение InvalidOperationException, если команда выполняется с дескриптором InstanceHandle, который не привязан к InstanceOwner.</value>
  </data>
  <data name="MemberCannotBeNull" xml:space="preserve">
    <value>"{0}" в {1} действия "{2}" не может принимать значение null.</value>
  </data>
  <data name="MemberIsReadOnly" xml:space="preserve">
    <value>Элемент "{0}" типа "{1}" доступен только для чтения. Он не может иметь тип LValue.</value>
  </data>
  <data name="MemberNotFound" xml:space="preserve">
    <value>Член с именем "{0}" не найден в типе "{1}".</value>
  </data>
  <data name="MemberNotSupportedByActivityXamlServices" xml:space="preserve">
    <value>ActivityXamlServices обнаружен элемент ({0}), который не поддерживается операцией DynamicActivity.</value>
  </data>
  <data name="MessageCannotBeEmpty" xml:space="preserve">
    <value>Содержимое сообщения равно null, что не соответствует операции "{0}" в контракте "{1}".</value>
  </data>
  <data name="MessageContentCannotHaveMoreThanOneParameter" xml:space="preserve">
    <value>Операция "{0}" согласно реализованному контракту "{1}" не может содержать более одного параметра для контракта сообщения.</value>
  </data>
  <data name="MessageHeaderNotSupported" xml:space="preserve">
    <value>Пользовательские заголовки сообщений в MessageDescription не поддерживаются. Используйте тип данных с добавлением MessageContract в операции "{0}", контракт"{1}".</value>
  </data>
  <data name="MessagePropertyIsNotSupported" xml:space="preserve">
    <value>Пользовательские свойства сообщений в MessageDescription не поддерживаются. Используйте тип данных с добавлением MessageContract в операции "{0}", контракт"{1}".</value>
  </data>
  <data name="MessageTypeMismatch" xml:space="preserve">
    <value>Операция Receive указала тип System.ServiceModel.Channels.Message в ReceiveMessageContent, отличающийся от типа сообщения "{0}", указанного в операции "{1}" реализованного контракта "{2}".</value>
  </data>
  <data name="MessageVersionInformationNotFound" xml:space="preserve">
    <value>Не удалось найти сведения о версии сообщения ответа.</value>
  </data>
  <data name="MetadataCannotContainNullKey" xml:space="preserve">
    <value>В именованной коллекции (словаре) значений InstanceValue указано имя NULL. Значение NULL недопустимо в качестве имени InstanceValue.</value>
  </data>
  <data name="MetadataCannotContainNullValue" xml:space="preserve">
    <value>В именованной коллекции (словаре) значений InstanceValue указано значение NULL. Для значения NULL указано имя {0}. Значение NULL недопустимо для InstanceValue. Чтобы указать значение NULL, используйте экземпляр InstanceValue с данными NULL, передав значение NULL в конструктор InstanceValue. Чтобы указать, что именованное значение нужно удалить, используйте InstanceValue.DeletedValue.</value>
  </data>
  <data name="MethodInfoRequired" xml:space="preserve">
    <value>Требуется свойство Method типа "{0}".</value>
  </data>
  <data name="MethodNameRequired" xml:space="preserve">
    <value>Требуется свойство Name типа "{0}".</value>
  </data>
  <data name="MissingArgument" xml:space="preserve">
    <value>Аргумент с именем "{0}" имеет значение NULL в коллекции "{1}".</value>
  </data>
  <data name="MissingBindingInEndpoint" xml:space="preserve">
    <value>У конечной точки с параметрами Name="{0}" и ServiceContract "{1}" отсутствует привязка. Укажите для этой конечной точки привязку.</value>
  </data>
  <data name="MissingBodyInWorkflowService" xml:space="preserve">
    <value>Свойство Body текущего WorkflowService имеет значение NULL. Введите значение свойства Body для этой службы WorkflowService.</value>
  </data>
  <data name="MissingDisplayNameInRootActivity" xml:space="preserve">
    <value>Корневое действие имеет пустое свойство DisplayName. Не устанавливайте свойство DisplayName корневого действия в значение NULL или пустую строку либо укажите Name для WorkflowService.</value>
  </data>
  <data name="MissingKnownTypes" xml:space="preserve">
    <value>Известный тип "{0}" для операции "{1}" контракта "{2}" отсутствует.</value>
  </data>
  <data name="MissingNameProperty" xml:space="preserve">
    <value>У аргумента типа "{0}" отсутствует имя. Для элементов в этой коллекции необходимо указывать свойство Name.</value>
  </data>
  <data name="MissingOperationName" xml:space="preserve">
    <value>Свойство OperationName должно задаваться в действии "{0}".</value>
  </data>
  <data name="MissingParameter" xml:space="preserve">
    <value>Коллекция параметров не содержит параметр "{0}", указанный для операции "{1}" в контракте "{2}".</value>
  </data>
  <data name="MissingServiceContractName" xml:space="preserve">
    <value>Свойство ServiceContractName должно задаваться в действии "{0}" при помощи параметра OperationName="{1}".</value>
  </data>
  <data name="MissingSetAccessorForIndexer" xml:space="preserve">
    <value>Свойство индексатора (Indexer) {0} для типа {1} не предоставляет метод присваивания значения (Setter).</value>
  </data>
  <data name="MissingUriInEndpoint" xml:space="preserve">
    <value>Свойство Uri конечной точки с параметрами Name="{0}" и ServiceContract "{1}" имеет значение null или пусто. Для этой конечной точки должно быть задано свойство URI.</value>
  </data>
  <data name="MisuseOfMessageContent" xml:space="preserve">
    <value>Контракт данных указан для операции "{0}" в контракте "{1}". Используйте ReceiveParameterContent для действия Receive и SendParameterContent для действия SendReply в соответствии с определением контракта.</value>
  </data>
  <data name="MisuseOfParameterContent" xml:space="preserve">
    <value>Тип контракта сообщения указан для операции "{0}" в контракте "{1}". Используйте ReceiveMessageContent для действия Receive и SendMessageContent для действия SendReply в соответствии с определением контракта. </value>
  </data>
  <data name="MovingActivitiesInStateBlockDU" xml:space="preserve">
    <value>StateMachine не поддерживает динамическое обновление, если свойство действия в исходном определении переназначено другому свойству в элементе State или Transition.</value>
  </data>
  <data name="MultiDimensionalArraysNotSupported" xml:space="preserve">
    <value>Многомерные массивы не поддерживаются.</value>
  </data>
  <data name="MultipleFlowNodesSharingSameChildBlockDU" xml:space="preserve">
    <value>Блок-схема не поддерживает динамическое обновление, если несколько узлов FlowNode используют одно и то же дочернее действие.</value>
  </data>
  <data name="MultipleLockOwnersNotSupported" xml:space="preserve">
    <value>SqlWorkflowInstanceStore не поддерживает одновременное создание нескольких владельцев блокировки. Рекомендуется установить параметр InstanceStore.DefaultInstanceOwner, чтобы совместно использовать хранилище большим числом приложений.</value>
  </data>
  <data name="MultipleOverloadGroupsConfigured" xml:space="preserve">
    <value>Настроены следующие перегруженные группы: {0}. Аргументы можно задать только для одной перегруженной группы.</value>
  </data>
  <data name="MustCallPrepareBeforeFinalize" xml:space="preserve">
    <value>Определение рабочего процесса не имеет присоединенной копии исходного определения. Перед обновлением рабочего процесса вызовите метод DynamicUpdateServices.PrepareForUpdate, чтобы сохранить копию исходного определения.</value>
  </data>
  <data name="MustCancelOldTimer" xml:space="preserve">
    <value>Перед установкой нового необходимо отменить предыдущий таймер.</value>
  </data>
  <data name="MustMatchReferenceExpressionReturnType" xml:space="preserve">
    <value>Ссылочные выражения не могут завершаться преобразованием. Тип указанного выражения должен в точности совпадать с типом T выражения VisualBasicReference&lt;T&gt; или LambdaReference&lt;T&gt;.</value>
  </data>
  <data name="MustSetTransactionOnFirstCall" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Включающая транзакция (System.Transactions.Transaction.Current) задана в потоке, который вызывает InstancePersistenceContext.Execute или InstancePersistenceContext.BeginExecute, однако в этом эпизоде выполнения уже выполнены команды, для которых не заданы транзакции. Включающую транзакцию можно задать только для первого вызова Execute или BeginExecute (и только в случае, если для эпизода не заданы другие транзакции).</value>
  </data>
  <data name="MustSpecifyConnectionStringOrName" xml:space="preserve">
    <value>Необходимо указать свойство connectionString или свойство connectionStringName.</value>
  </data>
  <data name="NameCollisionOnCollect" xml:space="preserve">
    <value>Для имени "{0}", указанного участником сохраняемости типа "{1}", обнаружен конфликт имен. Значение, переданное реализацией CollectValues в участнике, использует одинаковое имя с другим значением, переданным этим или другим участником сохраняемости. Исправьте участник, чтобы в нем использовалось другое имя, не вызывающее конфликта, или удалите участник из коллекции расширений потока операций.</value>
  </data>
  <data name="NameCollisionOnMap" xml:space="preserve">
    <value>Для имени "{0}", указанного участником сохраняемости типа "{1}", обнаружен конфликт имен. Значение, указанное реализацией MapValues в поставщике, использует одинаковое имя с другим значением, переданным этим или другим участником сохраняемости. Исправьте участник, чтобы в нем использовалось другое имя, не вызывающее конфликта, или удалите участник из коллекции расширений потока операций.</value>
  </data>
  <data name="NativeActivityUpdateInstanceThrewException" xml:space="preserve">
    <value>Действие вызвало исключение из метода UpdateInstance: {0}</value>
  </data>
  <data name="NAUCDisposed" xml:space="preserve">
    <value>Объект NativeActivityUpdateContext доступен только из области функции, в которую он был передан.</value>
  </data>
  <data name="NewArrayBoundsRequiresIntegralArguments" xml:space="preserve">
    <value>В качестве аргументов методу NewArrayBounds необходимо передавать целочисленные значения.</value>
  </data>
  <data name="NewArrayRequiresArrayTypeAsResultType" xml:space="preserve">
    <value>Типом результата действия "NewArray" должен быть конкретный тип массива.</value>
  </data>
  <data name="NoAdditionalKeysOnInstanceIdLoad" xml:space="preserve">
    <value>Если в качестве поставщика сохраняемости используется InstanceStore, то при загрузке экземпляра по идентификатору нельзя указывать дополнительные ключи.</value>
  </data>
  <data name="NoCAInSecondaryRoot" xml:space="preserve">
    <value>Действие CompensableActivity не может быть вложено в обработчик компенсации, подтверждения или отмены родителя CompensableActivity.</value>
  </data>
  <data name="NoChangesMapQueryNotSupported" xml:space="preserve">
    <value>Запрос к карте NoChanges не поддерживается.</value>
  </data>
  <data name="NoDynamicArgumentsInActivityDefinitionChange" xml:space="preserve">
    <value>В этом действии имеются конфликтующие изменения. Изменения произведены картой реализации и текущим обновлением. Аргументы действия изменены в обоих обновлениях.</value>
  </data>
  <data name="NoDynamicArgumentsInActivityDefinitionChangeRuntime" xml:space="preserve">
    <value>В этом действии имеются конфликтующие изменения. Изменения произведены обновлением реализации и обновлением более крупного рабочего процесса. Аргументы действия изменены в обоих обновлениях.</value>
  </data>
  <data name="NoNamespace" xml:space="preserve">
    <value>Не удается разрешить пространство имен "{0}:".</value>
  </data>
  <data name="NonWASActivationNotSupported" xml:space="preserve">
    <value>SqlWorkflowInstanceStore поддерживает только активацию WAS.</value>
  </data>
  <data name="NoOutputLocationWasFound" xml:space="preserve">
    <value>Аргумент {0} не соответствует допустимому расположению выходных данных.</value>
  </data>
  <data name="NoOverloadGroupsAreConfigured" xml:space="preserve">
    <value>Для перегруженных групп заданы не все требуемые (допустимые) аргументы действия.</value>
  </data>
  <data name="NoPersistScopeCannotContainPersist" xml:space="preserve">
    <value>Действие NoPersistScope "{0}" не может содержать действие Persist "{1}". </value>
  </data>
  <data name="NoPromotionsDefined" xml:space="preserve">
    <value>Именованное продвижение {0} не определяет никаких продвижений.</value>
  </data>
  <data name="NoRunnableInstances" xml:space="preserve">
    <value>В InstanceStore не найдены доступные для выполнения экземпляры рабочего процесса, которые можно загрузить.</value>
  </data>
  <data name="NoRuntimeTransactionExists" xml:space="preserve">
    <value>Вызов CompleteTransaction недопустим, если в среде выполнения нет активных транзакций.</value>
  </data>
  <data name="NotSpecified" xml:space="preserve">
    <value>&lt;не задано&gt;</value>
  </data>
  <data name="NotSupportMoreThanOneParametersInMessageContract" xml:space="preserve">
    <value>Операция не может содержать более одного параметра при использовании MessageContracts для операции "{0}" в контракте "{1}". Укажите допустимое определение контракта. </value>
  </data>
  <data name="NullAssignedToValueType" xml:space="preserve">
    <value>Из хранилища экземпляров извлечено значение неверного типа.  Ожидалось значение типа {0}, но вместо него обнаружено значение NULL.</value>
  </data>
  <data name="NullCorrelationHandleInInitializeCorrelation" xml:space="preserve">
    <value>CorrelationHandle не может иметь значение null в "{0}".</value>
  </data>
  <data name="NullCorrelationHandleInMultipleQueryCorrelation" xml:space="preserve">
    <value>По крайней мере в одном объекте QueryCorrelationInitializer не задан дескриптор корреляции. Дескриптор CorrelationHandle нужно задавать, если в коллекции CorrelationInitializers находится несколько элементов QueryCorrelationInitializer.</value>
  </data>
  <data name="NullKeyAlreadyPresent" xml:space="preserve">
    <value>Элемент с ключом null уже был добавлен.</value>
  </data>
  <data name="NullReferencedMemberAccess" xml:space="preserve">
    <value>Члену {1} не удалось разыменовать пустой объект типа {0}.</value>
  </data>
  <data name="NullReplyMessageContractMismatch" xml:space="preserve">
    <value>От сервера получено ответное сообщение, равное null. Возможной причиной может быть несоответствие контрактов на сторонах клиента и сервера. Убедитесь, что рабочий процесс на стороне сервера настроен для двусторонней операции.</value>
  </data>
  <data name="OnCancelRequestedThrew" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Обработчик события отмены вызвал исключения. Обработчик был определен методом InstancePersistenceContext.SetCancellationHandler.</value>
  </data>
  <data name="OneOfTwoPropertiesMustBeSet" xml:space="preserve">
    <value>Для "{2}" в действии "{3}" обязательным является либо свойство "{0}", либо свойство "{1}".</value>
  </data>
  <data name="OnewayContractIsImplementedAsTwoWay" xml:space="preserve">
    <value>Односторонняя операция "{0}" в контракте "{1}" не должна содержать действия SendReply. </value>
  </data>
  <data name="OnFreeInstanceHandleThrew" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Реализация метода OnFreeInstanceHandle вызвала исключение.</value>
  </data>
  <data name="OnlyBookmarkOwnerCanRemove" xml:space="preserve">
    <value>Закладки может удалить только тот экземпляр действия, который создал их.</value>
  </data>
  <data name="OnlyOneOperationPerActivity" xml:space="preserve">
    <value>Единовременно допускается выполнение одной операции для действия. В данный момент уже выполняется другая операция.</value>
  </data>
  <data name="OnlyOneRequireTransactionContextAllowed" xml:space="preserve">
    <value>Среда выполнения пытается обработать вызов RequireTransactionContext.</value>
  </data>
  <data name="OnlySingleCastDelegatesAllowed" xml:space="preserve">
    <value>Для событий WorkflowApplication допускаются только одноадресные делегаты.  Список вызова указанного делегата имеет длину больше одной строки.</value>
  </data>
  <data name="OperationAlreadyCompleted" xml:space="preserve">
    <value>Операция уже завершена.</value>
  </data>
  <data name="OperationDoesNotExistInContract" xml:space="preserve">
    <value>Операция "{0}" не существует в контракт с именем = "{1}" и пространством имен = "{2}".</value>
  </data>
  <data name="OperationFormatterAndFaultFormatterIncorrectlySet" xml:space="preserve">
    <value>Параметры OperationFormatter и FaultFormatter не могут быть заданы одновременно.</value>
  </data>
  <data name="OperationFormatterAndFaultFormatterNotSet" xml:space="preserve">
    <value>Параметры OperationFormatter и FaultFormatter не могут одновременно принимать значение null.</value>
  </data>
  <data name="OperationHasSerializerBehavior" xml:space="preserve">
    <value>Для операции "{0}" в контракте "{1}" уже задано поведение "{2}", поэтому новое поведение добавить нельзя. Это обычно указывает на то, что метод IOperationSerializer.ApplyToOperation уже был вызван для данной операции.</value>
  </data>
  <data name="OperationIsNotImplemented" xml:space="preserve">
    <value>Операция "{0}" контракта "{1}" не реализована в рабочем процессе.</value>
  </data>
  <data name="OperationNotAvailable" xml:space="preserve">
    <value>Невозможно выполнить в данный момент операцию "{0}" над экземпляром службы с идентификатором "{1}". Убедитесь, что операции выполняются в правильном порядке, а используемая привязка гарантирует упорядоченную доставку.</value>
  </data>
  <data name="OperationNotFound" xml:space="preserve">
    <value>Действие Receive по контракту {0} и операция {1} не найдены в WorkflowService по умолчанию. Убедитесь, что все операции в других версиях WorkflowService сначала были добавлены в WorkflowService по умолчанию.</value>
  </data>
  <data name="OptionalExtensionTypeMatchedMultiple" xml:space="preserve">
    <value>Найдено несколько модулей типа "{0}". Не более одного расширения данного типа допустимо при запуске этого потока операций.</value>
  </data>
  <data name="OriginalActivityReusedInModifiedDefinition" xml:space="preserve">
    <value>Действие "{0}" в исходном определении не может быть повторно использовано в обновленном определении.</value>
  </data>
  <data name="OriginalVariableReusedInModifiedDefinition" xml:space="preserve">
    <value>Переменная "{0}" в исходном определении не может быть повторно использована в обновленном определении.</value>
  </data>
  <data name="OriginCannotBeRuntimeIntrinsic" xml:space="preserve">
    <value>Объект "{0}" нельзя использовать в качестве исходного, так как он уже является элементом определения рабочего процесса (Activity, ActivityDelegate, Аргумент или LocationReference).</value>
  </data>
  <data name="OutArgumentCannotHaveInputValue" xml:space="preserve">
    <value>OutArgument "{0}" не может быть задан с входным значением.  Ключ "{0}" необходимо удалить из словаря входных значений.</value>
  </data>
  <data name="OutOfIdSpaceIds" xml:space="preserve">
    <value>Число действий в этом пространстве идентификаторов превысило значение Int32.MaxValue.  Выполните рефакторинг части рабочего процесса в новый подкласс действия.</value>
  </data>
  <data name="OutOfInstanceIds" xml:space="preserve">
    <value>В рабочем процессе можно выполнить только long.MaxValue экземпляров элемента Activity.</value>
  </data>
  <data name="OutOfInternalBookmarks" xml:space="preserve">
    <value>Для рабочего процесса можно создать только long.MaxValue внутренних закладок.</value>
  </data>
  <data name="OutOfRangeSourceLocationEndColumn" xml:space="preserve">
    <value>Для одной строки SourceLocation должно выполняться неравенство: endColumn &gt;= startColumn (= {0}).</value>
  </data>
  <data name="OutOfRangeSourceLocationEndLine" xml:space="preserve">
    <value>Для расположения SourceLocation должно выполняться неравенство: endLine &gt;= startLine (= {0}).</value>
  </data>
  <data name="OutsideInstanceExecutionScope" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Метод {0} может вызываться только во время обработки команды. Не пытайтесь сохранить экземпляр InstancePersistenceContext для дальнейшего использования. Объект InstancePersistenceContext, переданный в команду TryCommand или BeginTryCommand, может использоваться только в ходе обработки этой команды.</value>
  </data>
  <data name="OutsideTransactionalCommand" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вызвала метод {0} для InstancePersistenceContext, которому требуется согласованность транзакций, в рамках выполнения команды, которой не требуется согласованность транзакций. Это может привести к повреждению данных. Эта ошибка указывает на недопустимую реализацию поставщика сохраняемости.</value>
  </data>
  <data name="OverloadGroupHasSubsets" xml:space="preserve">
    <value>Следующие перегруженные группы являются подмножествами группы "{0}": {1}. Одна перегруженная группа не может быть подмножеством другой.</value>
  </data>
  <data name="OverloadGroupsAreEquivalent" xml:space="preserve">
    <value>Следующие перегруженные группы являются эквивалентными: {0}. В данном случае достаточно определить только одну перегруженную группу.</value>
  </data>
  <data name="OverloadingMethodMustBeStatic" xml:space="preserve">
    <value>Метод для перегрузки оператора должен быть статическим.</value>
  </data>
  <data name="OverloadOnlyCallableFromWorkflowThread" xml:space="preserve">
    <value>Перегрузку этого метода можно вызвать только из потока рабочего процесса.</value>
  </data>
  <data name="OwnerBelongsToWrongStore" xml:space="preserve">
    <value>Указан неверный InstanceOwner. Объект InstanceOwner, передаваемый в метод InstanceStore, должен принадлежать InstanceStore. Объект InstanceOwner можно использовать только с создавшим его методом InstanceStore.</value>
  </data>
  <data name="OwnerRequired" xml:space="preserve">
    <value>Системе сохранения экземпляров не удалось обработать недопустимую команду InstancePersistenceCommand. Для этой команды требуется владелец экземпляра, однако к дескриптору InstanceHandle не привязан владелец.</value>
  </data>
  <data name="ParallelForEachRequiresNonNullValues" xml:space="preserve">
    <value>Перед использованием действия ParallelForEach "{0}" необходимо привязать значения к непустому выражению.</value>
  </data>
  <data name="ParameterNumberMismatch" xml:space="preserve">
    <value>Параметр "{0}" не существует в операции "{1}" контракта "{2}".</value>
  </data>
  <data name="ParameterPositionMismatch" xml:space="preserve">
    <value>Параметр "{0}" указан в неправильном порядке для операции "{1}" в контракте "{2}". Переместите его в позицию "{3}" в коллекции параметров. </value>
  </data>
  <data name="ParameterTypeMismatch" xml:space="preserve">
    <value>Тип параметра "{0}" не соответствует типу "{1}", указанному в операции "{2}" реализованного контракта "{3}".</value>
  </data>
  <data name="PartialTrustPerformanceCounterNotEnabled" xml:space="preserve">
    <value>Доступ к счетчикам производительности запрещен. Возможно, приложение запущено с частичным доверием. Либо отключите счетчики производительности, либо настройте приложение за запуск с полным доверием.</value>
  </data>
  <data name="PauseWhenPersistableInvalidIfPersistable" xml:space="preserve">
    <value>Метод PauseWhenPersistable может быть вызван, только когда IsPersistable имеет значение false.</value>
  </data>
  <data name="PendingMessagesPerChannelRatio" xml:space="preserve">
    <value>Отношение ожидающих сообщений на канал: {0}/{1}</value>
  </data>
  <data name="PermissionArgumentWrongType" xml:space="preserve">
    <value>Аргумент имеет неправильный тип. Ожидается "{0}".</value>
  </data>
  <data name="PersistenceInitializerThrew" xml:space="preserve">
    <value>Реализация IPersistenceContextInitializer создала исключение. Не удалось загрузить или создать экземпляр надежной службы, например WorkflowServiceInstance. Свойство InnerException содержит исходное исключение.</value>
  </data>
  <data name="PersistencePipelineAbortThrew" xml:space="preserve">
    <value>Реализация метода Abort в участнике сохраняемости типа "{0}" вызвала исключение. Реализации метода Abort не должны вызывать исключения.</value>
  </data>
  <data name="PersistenceProviderRequiredToPersist" xml:space="preserve">
    <value>Только те экземпляры рабочего процесса, которые были настроены с расширением PersistenceProvider, могут быть сохранены или выгружены.</value>
  </data>
  <data name="PersistenceTooLateToEnlist" xml:space="preserve">
    <value>Прикрепление к транзакции уже невозможно, поскольку началась ее фиксация или прерывание.</value>
  </data>
  <data name="PersistenceViolationNoCreate" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Новый экземпляр создан в момент, когда было необходимо вызвать исключение InstanceNotReadyException.</value>
  </data>
  <data name="PickBranchRequiresTrigger" xml:space="preserve">
    <value>Перед использованием действия PickBranch "{0}" необходимо задать триггер.</value>
  </data>
  <data name="PickBranchTriggerActionSwapped" xml:space="preserve">
    <value>Выборка не поддерживает динамическое обновление, если поменять местами триггер и действие в PickBranch.</value>
  </data>
  <data name="PrepareForSerializationRequiresPersistability" xml:space="preserve">
    <value>Метод PrepareForSerialization может быть вызван, только когда IsPersistable имеет значение true.</value>
  </data>
  <data name="PrivateMembersHaveChanged" xml:space="preserve">
    <value>Закрытая реализация этого действия изменена (потомки реализации, делегаты, переменные или аргументы были добавлены, удалены или переупорядочены). Динамическое обновление поддерживает только изменения реализации, указанные в карте реализации, независимо от открытой конфигурации действия.</value>
  </data>
  <data name="PromotionAlreadyDefined" xml:space="preserve">
    <value>Набор продвижений {0} уже определен.</value>
  </data>
  <data name="PromotionTooManyDefined" xml:space="preserve">
    <value>Набор продвижений {0} определяет {1} {2} продвижений, что превышает максимально допустимое число продвижений объекта {3}.</value>
  </data>
  <data name="PropertyCannotBeModified" xml:space="preserve">
    <value>Свойство {0} не может быть изменено после того, как SqlTrackingParticipant начал обрабатывать записи.</value>
  </data>
  <data name="PropertyMemberNotSupportedByActivityXamlServices" xml:space="preserve">
    <value>ActivityXamlServices обнаружен элемент x:Property ({0}), который не поддерживается свойством DynamicActivityProperty.</value>
  </data>
  <data name="PropertyMismatch" xml:space="preserve">
    <value>"{0}" не соответствует значению "{1}", равному "{2}", указанному в контракте "{4}" операции "{3}".</value>
  </data>
  <data name="PropertyReadOnlyInWorkflowDataContext" xml:space="preserve">
    <value>Свойство "{0}" доступно только для чтения в контексте WorkflowDataContext.</value>
  </data>
  <data name="PropertyReferenceNotFound" xml:space="preserve">
    <value>Ссылке PropertyReference не удается разрешить свойство"{0}".</value>
  </data>
  <data name="ProtectionLevelIsNotSupported" xml:space="preserve">
    <value>Пользовательские параметры ProtectionLevel поддерживаются только в MessageContract. Укажите тип MessageContract для операции "{0}" реализованного контракта "{1}".</value>
  </data>
  <data name="ProtectionLevelNotSupported" xml:space="preserve">
    <value>Рабочий процесс не поддерживает пользовательские параметры ProtectionLevel при ошибках. Не указывайте ProtectionLevel в FaultContract для операции "{0}" реализованного контракта "{1}".</value>
  </data>
  <data name="ProvidedStateInitializedForExecution" xml:space="preserve">
    <value>Состояние среды выполнения уже инициализировано для выполнения и не может быть обновлено.  Перезагрузите состояние из постоянного хранилища.</value>
  </data>
  <data name="ProviderDoesNotSupportCommand" xml:space="preserve">
    <value>Реализаций InstanceStore в поставщике сохраняемости не поддерживает команду с именем {0}. Выберите другой поставщик или убедитесь, что такая команда сохраняемости не выполняется.</value>
  </data>
  <data name="PublicChildrenChangeBlockDU" xml:space="preserve">
    <value>Это действие не поддерживает изменения в открытых потомках (добавление, удаление или переупорядочивание действий или делегатов действий).</value>
  </data>
  <data name="PublicEnvironmentAccessToNonGenericActivity" xml:space="preserve">
    <value>Доступ к общей среде имеется только для действий, производных от CodeActivity&lt;TResult&gt;, но не от CodeActivity.</value>
  </data>
  <data name="PublicMethodWithMatchingParameterDoesNotExist" xml:space="preserve">
    <value>Действие "{0}" не имеет открытого метода "{1}" с именем "{2}", с совпадающими типами параметров, аргументами универсального типа и ограничениями универсального типа, переданными в метод InvokeMethod "{3}".</value>
  </data>
  <data name="PublicReferencesOnActivityRequiringArgumentResolution" xml:space="preserve">
    <value>Действию "{0}" не удается определить аргументы, кроме встроенного аргумента Result, и объявить доступ к общим местоположениям с помощью CodeActivityPublicEnvironmentAccessor. Передайте все данные действию либо с помощью аргументов, либо с помощью методов CodeActivityPublicEnvironmentAccessor.TryGetAccessToPublicLocation и TryGetReferenceToPublicLocation.</value>
  </data>
  <data name="QueryActivityIsInImplementation" xml:space="preserve">
    <value>Это действие находится внутри реализации составного действия "{0}". Для запроса его обновляемости используйте карту реализации для составного действия.</value>
  </data>
  <data name="QueryActivityIsNotInDefinition" xml:space="preserve">
    <value>Это действие не принадлежит ни к исходному, ни к обновленному определению рабочего процесса.</value>
  </data>
  <data name="QueryActivityIsPublic" xml:space="preserve">
    <value>Это действие является частью корневого определения рабочего процесса. Для запроса его обновляемости используйте карту обновления рабочего процесса, а не карту реализации для составного действия "{0}".</value>
  </data>
  <data name="QueryCorrelationInitializerCannotBeInitialized" xml:space="preserve">
    <value>Отсутствует дескриптор корреляции для инициализации QueryCorrelationInitializer. Это является следствием того, что в инициализаторе запросов не задан явный набор дескрипторов и отсутствует дескриптор, доступный для использования из области корреляции.</value>
  </data>
  <data name="QueryCorrelationInitializerWithEmptyMessageQuerySet" xml:space="preserve">
    <value>Действие с DisplayName="{0}" и OperationName="{1}" содержит QueryCorrelationInitializer с пустым MessageQuerySet.</value>
  </data>
  <data name="QueryVariableIsInImplementation" xml:space="preserve">
    <value>Эта переменная находится внутри реализации составного действия "{0}". Для запроса его обновляемости используйте карту реализации для составного действия.</value>
  </data>
  <data name="QueryVariableIsNotInDefinition" xml:space="preserve">
    <value>Эта переменная не принадлежит ни к исходному, ни к обновленному определению рабочего процесса.</value>
  </data>
  <data name="QueryVariableIsNotPublic" xml:space="preserve">
    <value>Эта переменная не является открытой. Только открытые переменные могут быть изменены динамическим обновлением.</value>
  </data>
  <data name="QueryVariableIsPublic" xml:space="preserve">
    <value>Эта переменная является частью корневого определения рабочего процесса. Для запроса его обновляемости используйте карту обновления рабочего процесса, а не карту реализации для составного действия "{0}".</value>
  </data>
  <data name="QueuingSqlRetry" xml:space="preserve">
    <value>Повторная попытка поместить SQL в очередь с задержкой {0} мс.</value>
  </data>
  <data name="ReadAccessToWriteOnlyPublicReference" xml:space="preserve">
    <value>Действию "{0}" не удается выполнить чтение из ссылки на это общее местоположение, так как она была объявлена с помощью ArgumentDirection.Out. Чтобы разрешить чтение и запись, объявите ссылку с помощью ArgumentDirection.InOut.</value>
  </data>
  <data name="ReadNotSupported" xml:space="preserve">
    <value>Чтение не поддерживается для этого потока.</value>
  </data>
  <data name="ReadonlyNameScopeCannotBeUpdated" xml:space="preserve">
    <value>Операцию невозможно использовать, так как реализация области имен доступна только для чтения.</value>
  </data>
  <data name="ReadonlyPropertyCannotBeSet" xml:space="preserve">
    <value>Свойство или индексатор "{0}.{1}" невозможно использовать в этом контексте, так как метод доступа get недоступен.</value>
  </data>
  <data name="ReceiveAndReceiveParametersHaveSameName" xml:space="preserve">
    <value>Две операции Receive с разными типами ReceiveContent имеют одинаковые свойства ServiceContractName и OperationName "{0}".</value>
  </data>
  <data name="ReceiveContentChanged" xml:space="preserve">
    <value>Содержимое этого действия Receive изменилось с бестипового на типовое.</value>
  </data>
  <data name="ReceiveCorrelationInitializiersChanged" xml:space="preserve">
    <value>CorrelationInitializers действия Receive изменилось.</value>
  </data>
  <data name="ReceiveIsInTRSWhenTransactionFlowNotAllowed" xml:space="preserve">
    <value>Действие Receive находится в диапазоне TransactedReceiveScope, в то время как операция "{0}" в реализованном контракте "{1}" имеет параметр TransactionFlowOption со значением NotAllowed.</value>
  </data>
  <data name="ReceiveIsNotInTRS" xml:space="preserve">
    <value>Операция "{0}" в реализованном контракте "{1}" требует обработки транзакции, но действие Receive НЕ находится в диапазоне TransactedReceiveScope.</value>
  </data>
  <data name="ReceiveMessageNeedsToPairWithSendMessageForTwoWayContract" xml:space="preserve">
    <value>Действие Receive настроено на использование операции "запрос-ответ" "{0}", однако при этом отсутствует связанное с ним действие SendReply. Свяжите действие Receive с действием SendReply и скоррелируйте их с помощью дескриптора CorrelationHandle.</value>
  </data>
  <data name="ReceiveNotWithinATransactedReceiveScope" xml:space="preserve">
    <value>Действие Receive, включенное в транзакцию, не входи в область TransactedReceiveScope.</value>
  </data>
  <data name="ReceivePairedWithSendReplyAndSendReplyParameters" xml:space="preserve">
    <value>Операция SendReply с SendMessageContent и операция SendReply с SendParametersContent составляют пары с одинаковыми операциями Receive с OperationName="{0}". Это недопустимо.</value>
  </data>
  <data name="ReceiveParametersContentDoesNotSupportMessage" xml:space="preserve">
    <value>Действие с DisplayName="{0}" содержит аргумент с именем "{1}", который является Message или MessageContract. Метод ReceiveParametersContent не поддерживает Message и MessageContract. Свойство Content должно быть указано как ReceiveMessageContent для Message или MessageContract на основании содержимого.</value>
  </data>
  <data name="ReceiveReplyRequestCannotBeNull" xml:space="preserve">
    <value>Свойство Request в действии "{0}" не может иметь значение NULL. Оно должно быть установлено в действие Send, относящееся к данной паре "запрос-ответ".</value>
  </data>
  <data name="ReferencedChildInIsNewlyAdded" xml:space="preserve">
    <value>Этот метод не может быть вызван для действий, ссылающихся на импортированных потомков. Прежде чем вызывать этот метод, проверьте NativeActivityUpdateContext.IsReferenceToImportedChild.</value>
  </data>
  <data name="RegisteredBookmarkScopeRequired" xml:space="preserve">
    <value>Только зарегистрированные области закладок могут быть использованы для создания закладок с указанием области.</value>
  </data>
  <data name="RelativeUriRequiresBinding" xml:space="preserve">
    <value>У конечной точки с параметрами Name="{0}" и ServiceContract "{1}" есть относительный универсальный код ресурса (URI) "{2}", который невозможно преобразовать в абсолютный URI из-за того, что свойство Binding конечной точки равно null. Задайте свойство Binding или измените относительный универсальный код ресурса (URI) на абсолютный.</value>
  </data>
  <data name="RelativeUriRequiresHost" xml:space="preserve">
    <value>У конечной точки с параметрами Name="{0}" и ServiceContract "{1}" есть относительный универсальный код ресурса (URI) "{2}", который невозможно преобразовать в абсолютный URI из-за того, что аргумент host метода GetAddress равен null. Укажите экземпляр узла службы, в котором будет размещена конечная точка, или измените относительный универсальный код ресурса (URI) на абсолютный.</value>
  </data>
  <data name="RemovingTransitionsBlockDU" xml:space="preserve">
    <value>StateMachine не поддерживает динамическое обновление, если переход удален из текущего состояния.</value>
  </data>
  <data name="RenewLockSystemError" xml:space="preserve">
    <value>Не удалось увеличить срок окончания блокировки, срок окончания блокировки уже истек или владелец блокировки удален. Прерывание блокировки SqlWorkflowInstanceStore.</value>
  </data>
  <data name="ReplyShouldNotIncludeRequestReplyHandle" xml:space="preserve">
    <value>Действие "{0}" с параметром OperationName="{1}" не должно содержать в дополнительных корреляциях дескриптор "запрос-ответ".</value>
  </data>
  <data name="RequestMustBeSpecified" xml:space="preserve">
    <value>В действии "{0}" должен быть указан аргумент Request.</value>
  </data>
  <data name="RequestReplyHandleShouldNotBePresentForOneWay" xml:space="preserve">
    <value>RequestReplyCorrelationInitializer не должен указываться для одностороннего действия Send или Receive. При инициализации корреляции RequestReply действию Send должно быть поставлено в пару действие ReceiveReply, а действию Receive - действие SendReply.</value>
  </data>
  <data name="RequiredArgumentValueNotSupplied" xml:space="preserve">
    <value>Значение обязательного аргумента действия "{0}" не передано.</value>
  </data>
  <data name="RequiredExtensionTypeNotFound" xml:space="preserve">
    <value>Модуль типа "{0}" должен быть настроен для запуска этого потока операций.</value>
  </data>
  <data name="RequiredVariableCoundNotBeExtracted" xml:space="preserve">
    <value>Обязательная переменная {0} недоступна для извлечения в действии: {1}.</value>
  </data>
  <data name="RequireExtensionOnlyAcceptsReferenceTypes" xml:space="preserve">
    <value>"{0}" является типом значения. RequireExtension принимает только ссылочные типы.</value>
  </data>
  <data name="ResponseContextIsNotNull" xml:space="preserve">
    <value>Контекст ResponseContext не равен null.</value>
  </data>
  <data name="ResultArgumentHasRequiredTypeAndDirection" xml:space="preserve">
    <value>У предоставленного автором действия объекта RuntimeArgument с именем "Result" должно быть свойство ArgumentDirection со значением Out и типом {0}. Вместо этого у свойства ArgumentDirection значение {1} и тип {2}.</value>
  </data>
  <data name="ResultArgumentMustBeBoundToResultProperty" xml:space="preserve">
    <value>Предоставленный автором действия объект RuntimeArgument с именем "Result" должен быть привязан к аргументу, возвращаемому свойством Result действия.</value>
  </data>
  <data name="ResultArgumentMustBeSpecificType" xml:space="preserve">
    <value>Выходной аргумент Result OutArgument для этого действия должен быть аргументом типа {0}.</value>
  </data>
  <data name="ResultCannotBeSetOnArgumentExpressions" xml:space="preserve">
    <value>Выходной аргумент Result OutArgument в действии&lt;T&gt; не может быть задан, когда действие&lt;T&gt; используется как выражение аргумента.</value>
  </data>
  <data name="ResultMustBeSpecified" xml:space="preserve">
    <value>В действии "{0}" должен быть указан аргумент Result.</value>
  </data>
  <data name="RethrowMustBeAPublicChild" xml:space="preserve">
    <value>Действие Rethrow "{0}" нельзя использовать в закрытом потомке действия TryCatch. Rethrow допускается только в открытых потомках действия TryCatch.</value>
  </data>
  <data name="RethrowNotInATryCatch" xml:space="preserve">
    <value>При повторном создании исключения действие "{0}" должно быть дочерним по отношению к обработчику Catch действия TryCatch.</value>
  </data>
  <data name="RetryingSqlCommandDueToSqlError" xml:space="preserve">
    <value>Выполняется повтор команды SQL из-за ошибки SQL с номером {0}.</value>
  </data>
  <data name="ReturnTypeIncompatible" xml:space="preserve">
    <value>Несовпадение типа. Тип возвращаемого значения "{0}" наиболее подходящего метода "{1}" в типе "{2}" несовместим с аргументом "Result", переданным в метод InvokeMethod "{3}", для которого ожидаются возвращаемые значения типа "{4}".</value>
  </data>
  <data name="ReturnValueMissing" xml:space="preserve">
    <value>Параметр возвращаемого значения типа "{0}" отсутствует для операции "{1}" в контракте "{2}". </value>
  </data>
  <data name="RootActivityAlreadyAssociatedWithInstance" xml:space="preserve">
    <value>Действие с отображаемым именем "{0}" уже сопоставлено с экземпляром.  Операции с метаданными действия, которое связано с экземпляром, не допускаются.  Эта ошибка также может указывать на попытку выполнения потока операций, в котором корневое действие входит в другой поток операций.</value>
  </data>
  <data name="RootActivityCannotBeReferenced" xml:space="preserve">
    <value>Действие "{0}" является корневым действием, и на него не может ссылаться действие "{1}".</value>
  </data>
  <data name="RootArgumentViolationsFound" xml:space="preserve">
    <value>Значения, предоставленные для аргументов корневого действия, не удовлетворяют требованиям корневого действия:</value>
  </data>
  <data name="RootArgumentViolationsFoundNoInputs" xml:space="preserve">
    <value>Параметры аргумента корневого действия некорректны. Либо исправьте определение рабочего процесса, либо введите допустимые значения, чтобы исправить эти ошибки:</value>
  </data>
  <data name="RunnableInstancesDetectionError" xml:space="preserve">
    <value>Не удалось обнаружить доступные для выполнения экземпляры, поскольку обнаружено следующее исключение</value>
  </data>
  <data name="RuntimeArgumentBindingInvalid" xml:space="preserve">
    <value>Аргумент RuntimeArgument "{0}" ссылается на аргумент, который в свою очередь привязан к аргументу RuntimeArgument с именем "{1}". Убедитесь, что объект Argument привязан не более чем к одному объекту RuntimeArgument и не используется совместно несколькими открытыми свойствами Argument.</value>
  </data>
  <data name="RuntimeArgumentChangeBlockDU" xml:space="preserve">
    <value>Динамическое обновление не может быть разрешено внутри действия "{0}" из-за изменений RuntimeArguments. Чтобы включить динамическое обновление в этом действии, нельзя добавлять, удалять или переупорядочивать аргументы RuntimeArgument. Также нельзя изменять имя, тип и направление.</value>
  </data>
  <data name="RuntimeArgumentNotCreated" xml:space="preserve">
    <value>Экземпляр RuntimeArgument еще не создан.</value>
  </data>
  <data name="RuntimeArgumentNotOpen" xml:space="preserve">
    <value>Невозможно использовать аргумент "{0}".  Убедитесь, что он объявлен в действии.</value>
  </data>
  <data name="RuntimeDelegateArgumentDirectionIncorrect" xml:space="preserve">
    <value>Направление объекта RuntimeDelegateArgument должно совпадать с направлением объекта DelegateArgument, к которому оно привязано.</value>
  </data>
  <data name="RuntimeDelegateArgumentTypeIncorrect" xml:space="preserve">
    <value>Тип объекта RuntimeDelegateArgument должен совпадать с типом объекта DelegateArgument, к которому он привязан.</value>
  </data>
  <data name="RuntimeOperationInProgress" xml:space="preserve">
    <value>Операция среды выполнения уже выполняется.  Доступ к объекту WorkflowInstance должен быть синхронизирован вызывающим объектом.</value>
  </data>
  <data name="RuntimeRunning" xml:space="preserve">
    <value>В данный момент среда выполнения выполняет поток операций, а операции могут выполняться только во время его приостановки.  Доступ к объекту WorkflowInstance должен быть синхронизирован вызывающим объектом.</value>
  </data>
  <data name="RuntimeTransactionAlreadyExists" xml:space="preserve">
    <value>В среде выполнения уже была настроена транзакция.  Разрешено выполнение не более одной транзакции одновременно.</value>
  </data>
  <data name="RuntimeTransactionComplete" xml:space="preserve">
    <value>Транзакция среды выполнения завершена; состояние "{0}".</value>
  </data>
  <data name="RuntimeTransactionCompletionRequested" xml:space="preserve">
    <value>Элемент Activity "{0}", DisplayName: "{1}", InstanceId: "{2}" запланировал завершение транзакции среды выполнения.</value>
  </data>
  <data name="RuntimeTransactionHandleNotRegisteredAsExecutionProperty" xml:space="preserve">
    <value>Метод "{0}" может вызываться, только если соответствующий объект RuntimeTransactionHandle зарегистрирован в качестве свойства выполнения.</value>
  </data>
  <data name="RuntimeTransactionIsSuppressed" xml:space="preserve">
    <value>Данная операция недопустима при подавлении транзакции среды выполнения. Транзакция среды выполнения подавляется, поскольку свойство SuppressTransaction было задано в классе RuntimeTransactionHandle текущей среды.</value>
  </data>
  <data name="RuntimeTransactionSet" xml:space="preserve">
    <value>Транзакция среды выполнения задана элементом Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".  Выполнение изолировано в элементе Activity "{3}", DisplayName: "{4}", InstanceId: "{5}".</value>
  </data>
  <data name="SameUserStateUsedForMultipleInvokes" xml:space="preserve">
    <value>Один и тот же экземпляр пользовательского состояния не может использоваться для параллельных вызовов действия.</value>
  </data>
  <data name="SavingActivityToXamlNotSupported" xml:space="preserve">
    <value>Сохранение DynamicActivity и Activity.Implementation в язык XAML не поддерживается.  Если нужно создать параметризованный поток операций и сохранить его в язык XAML, воспользуйтесь классом ActivityBuilder.</value>
  </data>
  <data name="SavingFuncToXamlNotSupported" xml:space="preserve">
    <value>Сохранение общей функции Func&lt;T&gt; в XAML не поддерживается. Чтобы преобразовать объект в сериализуемую функцию, сериализуйте объект в XAML, а затем вызовите метод ActivityXamlServices.CreateFactory.</value>
  </data>
  <data name="ScheduleBookmarkWorkItem" xml:space="preserve">
    <value>Элемент BookmarkWorkItem был запланирован для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".  BookmarkName: {3}, BookmarkScope: {4}.</value>
  </data>
  <data name="ScheduleCancelActivityWorkItem" xml:space="preserve">
    <value>Элемент CancelActivityWorkItem был запланирован для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".</value>
  </data>
  <data name="ScheduleCompletionWorkItem" xml:space="preserve">
    <value>Элемент CompletionWorkItem был запланирован для родительского элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".  Выполнение элемента Activity "{3}" завершено, DisplayName: "{4}", InstanceId: "{5}".</value>
  </data>
  <data name="ScheduleExecuteActivityWorkItem" xml:space="preserve">
    <value>Элемент ExecuteActivityWorkItem был запланирован для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".</value>
  </data>
  <data name="ScheduleFaultWorkItem" xml:space="preserve">
    <value>Элемент FaultWorkItem был запланирован для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".  В элементе Activity "{3}" произошло исключение, DisplayName: "{4}", InstanceId: "{5}".</value>
  </data>
  <data name="ScheduleRuntimeWorkItem" xml:space="preserve">
    <value>Рабочий элемент среды выполнения был запланирован для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".</value>
  </data>
  <data name="ScheduleTransactionContextWorkItem" xml:space="preserve">
    <value>Элемент TransactionContextWorkItem был запланирован для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".</value>
  </data>
  <data name="SchemaContextFromBeforeInitializeComponentXBTExtensionCannotBeGeneric" xml:space="preserve">
    <value>Имя класса поддержки XAML, созданное расширением сборки задания XAML BeforeInitializeComponent ({0}), не может быть универсальным. Ресурс не может быть создан расширением построения задания XAML BeforeInitializeComponent. Перестройте проект.</value>
  </data>
  <data name="SchemaContextFromBeforeInitializeComponentXBTExtensionNotFound" xml:space="preserve">
    <value>Имя класса поддержки XAML, созданное расширением построения задания XAML BeforeInitializeComponent ({0}), не найдено. Перестройте проект.</value>
  </data>
  <data name="SeekNotSupported" xml:space="preserve">
    <value>Поиск не поддерживается для этого потока.</value>
  </data>
  <data name="SendActivityCorrelationHandleNotFound" xml:space="preserve">
    <value>Не удалось найти допустимый дескриптор связи, связанный с действием отправки с именем "{0}".</value>
  </data>
  <data name="SendMessageChannelCacheMiss" xml:space="preserve">
    <value>Отсутствует SendMessageChannelCache</value>
  </data>
  <data name="SendMessageNeedsToPairWithReceiveMessageForTwoWayContract" xml:space="preserve">
    <value>Действие Send настроено на использование операции "запрос-ответ" "{0}", однако при этом отсутствует связанное с ним действие ReceiveReply. Свяжите действие Send с действием ReceiveReply и скоррелируйте их с помощью дескриптора CorrelationHandle.</value>
  </data>
  <data name="SendNotSupported" xml:space="preserve">
    <value>Метод Send не поддерживается.</value>
  </data>
  <data name="SendParametersContentDoesNotSupportMessage" xml:space="preserve">
    <value>Действие с DisplayName="{0}" содержит аргумент с именем "{1}", который является Message или MessageContract. Метод SendParametersContent не поддерживает Message и MessageContract. Свойство Content должно быть указано как SendMessageContent для Message или MessageContract.</value>
  </data>
  <data name="SendReceiveExtensionNotFound" xml:space="preserve">
    <value>Не удается найти расширение SendReceiveExtension, убедитесь, что приложение, содержащее рабочий процесс, предоставляет реализацию этого расширения.</value>
  </data>
  <data name="SendRepliesHaveSameFaultTypeDifferentAction" xml:space="preserve">
    <value>Два действия SendReply имеют одинаковый тип ошибки, но разные действия.</value>
  </data>
  <data name="SendReplyRequestCannotBeNull" xml:space="preserve">
    <value>Свойство Request в действии "{0}" не может иметь значение NULL. Ему необходимо присвоить действие Receive, принадлежащее данной паре "запрос-ответ".</value>
  </data>
  <data name="SendWithUninitializedCorrelatesWith" xml:space="preserve">
    <value>Действие с именем операции "{0}" содержит неинициализированный дескриптор CorrelatesWith.</value>
  </data>
  <data name="SequenceDuplicateReferences" xml:space="preserve">
    <value>Последовательность не поддерживает динамическое обновление, если она содержит более одной ссылки на один и тот же импортированный потомок.</value>
  </data>
  <data name="ServiceEndpointAdded" xml:space="preserve">
    <value>Конечная точка службы была добавлена для адреса "{0}", привязки "{1}" и контракта "{2}".</value>
  </data>
  <data name="ServiceHostExtensionAborted" xml:space="preserve">
    <value>Операция не может быть выполнена, поскольку узел службы или одно из его расширений были прерваны.</value>
  </data>
  <data name="ServiceHostExtensionImmutable" xml:space="preserve">
    <value>Операция вызывалась при помощи расширения узла службы, которое разрешено использовать только до открытия узла службы.</value>
  </data>
  <data name="ServiceInstanceTerminated" xml:space="preserve">
    <value>Работа экземпляра службы с идентификатором "{0}" завершена.</value>
  </data>
  <data name="ServiceInstanceUnloaded" xml:space="preserve">
    <value>Экземпляр службы с идентификатором "{0}" выгружен из памяти.</value>
  </data>
  <data name="ServiceMetadataBehaviorNotFoundForServiceMetadataEndpoint" xml:space="preserve">
    <value>Не удалось найти контракт с именем "IMetadataExchange" в списке контрактов, реализованных службой {0}.  Чтобы включить поддержку этого контракта, добавьте свойство ServiceMetadataBehavior в файл конфигурации или непосредственно в WorkflowServiceHost.</value>
  </data>
  <data name="SetupOrCleanupWorkflowThreadThrew" xml:space="preserve">
    <value>Интерфейс IExecutionProperty создал исключение при настройке или очистке потока рабочего процесса.  Дополнительные сведения см. в описании внутреннего исключения.</value>
  </data>
  <data name="SFxTaskNotStarted" xml:space="preserve">
    <value>Данный экземпляр задачи еще не запущен. Экземпляры задачи нужно запустить, прежде чем они смогут возвратить результаты каких-либо операций.</value>
  </data>
  <data name="ShipAssertExceptionMessage" xml:space="preserve">
    <value>Произошла непредвиденная ошибка. Приложения не должны обрабатывать эту ошибку. В целях диагностики приводится сообщение на английском языке, связанное с ошибкой: {0}.</value>
  </data>
  <data name="SimpleStateMustHaveOneTransition" xml:space="preserve">
    <value>Состояние "{0}" должно содержать хотя бы одну транзицию.</value>
  </data>
  <data name="SpecialMethodNotFound" xml:space="preserve">
    <value>Особый метод "{0}" типа "{1}" не найден.</value>
  </data>
  <data name="SqlExceptionCaught" xml:space="preserve">
    <value>Обнаружено исключение SQL с номером {0}, сообщение {1}.</value>
  </data>
  <data name="StartBookmarkWorkItem" xml:space="preserve">
    <value>Начинается выполнение элемента BookmarkWorkItem для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".  BookmarkName: {3}, BookmarkScope: {4}.</value>
  </data>
  <data name="StartCancelActivityWorkItem" xml:space="preserve">
    <value>Начинается выполнение элемента CancelActivityWorkItem для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".</value>
  </data>
  <data name="StartCompletionWorkItem" xml:space="preserve">
    <value>Начинается выполнение элемента CompletionWorkItem для родительского элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}". Выполнение элемента Activity "{3}" завершено, DisplayName: "{4}", InstanceId: "{5}".</value>
  </data>
  <data name="StartExecuteActivityWorkItem" xml:space="preserve">
    <value>Начинается выполнение элемента ExecuteActivityWorkItem для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".</value>
  </data>
  <data name="StartFaultWorkItem" xml:space="preserve">
    <value>Начинается выполнение элемента FaultWorkItem для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".  В элементе Activity "{3}" произошло исключение, DisplayName: "{4}", InstanceId: "{5}".</value>
  </data>
  <data name="StartRuntimeWorkItem" xml:space="preserve">
    <value>Начинается выполнение рабочего элемента среды выполнения для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".</value>
  </data>
  <data name="StartSignpostEvent" xml:space="preserve">
    <value>Ограничение действия.</value>
  </data>
  <data name="StartSqlCommandExecute" xml:space="preserve">
    <value>Запуск выполнения команды SQL: {0}</value>
  </data>
  <data name="StartTransactionContextWorkItem" xml:space="preserve">
    <value>Начинается выполнение элемента TransactionContextWorkItem для элемента Activity "{0}", DisplayName: "{1}", InstanceId: "{2}".</value>
  </data>
  <data name="StateCannotBeAddedTwice" xml:space="preserve">
    <value>Состояние "{0}" не удалось добавить в конечный автомат дважды.  Все состояния в конечном автомате должны быть уникальными.</value>
  </data>
  <data name="StateCannotBeSerialized" xml:space="preserve">
    <value>Экземпляр "{0}" не может быть запущен или сохранен, поскольку динамическое обновление для него завершилось сбоем. Чтобы запустить экземпляр, перезагрузите свежую копию из хранилища сохраняемости.</value>
  </data>
  <data name="StateMachineMustHaveInitialState" xml:space="preserve">
    <value>У StateMachine "{0}" должно быть начальное состояние.</value>
  </data>
  <data name="StateNotBelongToAnyParent" xml:space="preserve">
    <value>Целевое состояние "{1}" транзиции "{0}" должно принадлежать машине состояний.</value>
  </data>
  <data name="StopSignpostEvent" xml:space="preserve">
    <value>Ограничение действия.</value>
  </data>
  <data name="StoreReportedConflictingLockTokens" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она дважды вызвала метод BindInstanceOwner с одним значением instanceOwnerId и разными значениями lockToken. Используйте поставщик сохраняемости, который всегда использует одинаковые значения lockToken для одного владельца экземпляра.</value>
  </data>
  <data name="StoreViolationNoInstanceBound" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недопустима. Реализации не удалось привязать InstanceHandle к экземпляру и установить InstanceState при обработке команды LoadWorkflowByInstanceKeyCommand, LoadWorkflowCommand или TryLoadRunnableWorkflowCommand.</value>
  </data>
  <data name="SubexpressionResultWasNotVisible" xml:space="preserve">
    <value>Результатом части выражения для объекта типа "{0}" является ссылка на расположение, которое не видимо в данной области.</value>
  </data>
  <data name="SubexpressionResultWasNull" xml:space="preserve">
    <value>Результатом части выражения для объекта типа "{0}" является значение NULL.</value>
  </data>
  <data name="SwitchCaseKeyTypesMustMatchExpressionType" xml:space="preserve">
    <value>Варианты переключателя "{0}" содержат {1} ключей, которые несовместимы с типом выражения "{2}".</value>
  </data>
  <data name="SwitchCaseNotFound" xml:space="preserve">
    <value>Действию Switch "{0}" не удалось найти действие Case, соответствующее результату выражения Expression.</value>
  </data>
  <data name="SwitchCaseNullWithValueType" xml:space="preserve">
    <value>Ключ для случая null существует, но Switch Expression является типом значения "{0}". Типы значений не могут принимать значение null.</value>
  </data>
  <data name="SwitchCaseTypeMismatch" xml:space="preserve">
    <value>Ключ варианта "{0}" не принадлежит типу "{1}" и может не соответствовать любому значению, выданному выражением переключателя типа "InArgument&lt;{1}&gt;".</value>
  </data>
  <data name="SymbolNamesMustBeUnique" xml:space="preserve">
    <value>Переменная RuntimeArgument или DelegateArgument с именем "{0}" уже существует. Имена должны быть уникальными в области среды.</value>
  </data>
  <data name="SymbolResolverAlreadyExists" xml:space="preserve">
    <value>Для экземпляра потока операций может быть настроено только одно расширение SymbolResolver.  Расширение SymbolResolver уже существует в WorkflowInstanceExtensionManager.</value>
  </data>
  <data name="SymbolResolverDoesNotHaveSymbol" xml:space="preserve">
    <value>Не удается найти символ "{0}" типа "{1}" в расширении SymbolResolver для данного экземпляра.</value>
  </data>
  <data name="SymbolResolverMustBeSingleton" xml:space="preserve">
    <value>SymbolResolver не может быть использован как модуль для каждого экземпляра. Переопределите singletonObject, чтобы добавить SymbolResolver в WorkflowInstanceExtensionManager.</value>
  </data>
  <data name="TargetContractCannotBeOneWayWithTransactionFlow" xml:space="preserve">
    <value>Недопустимое определение контракта: односторонняя операция имеет параметр TransactionFlowOption со значением Mandatory в операции "{0}" контракта "{1}".</value>
  </data>
  <data name="TargetTypeAndTargetObjectAreMutuallyExclusive" xml:space="preserve">
    <value>Тип TargetType и объект TargetObject являются взаимоисключающими для действия {0} "{1}".</value>
  </data>
  <data name="TargetTypeCannotBeEnum" xml:space="preserve">
    <value>Тип операнда в {0} "{1}" не может быть типом перечисления.</value>
  </data>
  <data name="TargetTypeIsValueType" xml:space="preserve">
    <value>Тип операнда является типом значения. Изменение поля в "{0}" "{1}" ни на что не повлияет.</value>
  </data>
  <data name="TaskTimedOutError" xml:space="preserve">
    <value>Превышено время ожидания задачи после {0}. Время, выделенное на эту операцию, может быть составной частью более продолжительного времени ожидания.</value>
  </data>
  <data name="TextExpressionCompilerActivityNameRequired" xml:space="preserve">
    <value>TextExpressionCompilerSettings.ActivityName должно быть предоставлено.</value>
  </data>
  <data name="TextExpressionCompilerActivityNamespaceRequired" xml:space="preserve">
    <value>TextExpressionCompilerSettings.ActivityNamespace должно быть предоставлено.</value>
  </data>
  <data name="TextExpressionCompilerActivityRequired" xml:space="preserve">
    <value>TextExpressionCompilerSettings.Activity должно быть предоставлено.</value>
  </data>
  <data name="TextExpressionCompilerAddGeneratedFileRequired" xml:space="preserve">
    <value>TextExpressionCompilerSettings.AddGeneratedFile должен быть предоставлен.</value>
  </data>
  <data name="TextExpressionCompilerLanguageRequired" xml:space="preserve">
    <value>TextExpressionCompilerSettings.Language должен быть предоставлен.</value>
  </data>
  <data name="TextExpressionCompilerNoCodebase" xml:space="preserve">
    <value>Сборка, загруженная для имени "{0}", не содержит значения CodeBase. Значение CodeBase необходимо для компиляции.</value>
  </data>
  <data name="TextExpressionCompilerOutputPathRequired" xml:space="preserve">
    <value>TextExpressionCompilerSettings.OutputPath должен быть предоставлен.</value>
  </data>
  <data name="TextExpressionCompilerUnableToLoadAssembly" xml:space="preserve">
    <value>Не удается загрузить сборку "{0}".</value>
  </data>
  <data name="TextExpressionMetadataRequiresCompilation" xml:space="preserve">
    <value>Для запуска типа действия выражения "{0}" требуется компиляция. Убедитесь, что поток операций скомпилирован.</value>
  </data>
  <data name="ThreadNeutralSemaphoreAborted" xml:space="preserve">
    <value>ThreadNeutralSemaphore был прерван.</value>
  </data>
  <data name="ThrowingEtwException" xml:space="preserve">
    <value>Создание исключения. Источник: {0}. Сведения об исключении: {1}</value>
  </data>
  <data name="ThrowingEtwExceptionVerbose" xml:space="preserve">
    <value>Создание исключения. Источник: {0}. Сведения об исключении: {1}</value>
  </data>
  <data name="ThrowingException" xml:space="preserve">
    <value>Создание исключения. Источник: {0}. Сведения об исключении: {1}</value>
  </data>
  <data name="ThrowingExceptionVerbose" xml:space="preserve">
    <value>Создание исключения. Источник: {0}. Сведения об исключении: {1}</value>
  </data>
  <data name="TimedOutWaitingForLockResolution" xml:space="preserve">
    <value>Поставщику сохраняемости не удалось восстановить блокировку за заданное время ожидания. Это указывает на возможность взаимоблокировки в наборе команд, одновременно выполняемых в различных InstanceHandle, принадлежащих одному InstanceOwner. Чтобы разрешить такую ситуацию, можно использовать несколько владельцев InstanceOwner или сделать так, чтобы свойство InstancePersistenceCommand.AutomaticallyAcquiringLock возвращало значение false для команд, которые не могут получить блокировку для экземпляра.</value>
  </data>
  <data name="TimeoutInputQueueDequeue" xml:space="preserve">
    <value>Время ожидания операции Dequeue истекло после {0}. Время, выделенное на эту операцию, может быть составной частью более продолжительного времени ожидания.</value>
  </data>
  <data name="TimeoutMustBeNonNegative" xml:space="preserve">
    <value>Аргумент {0} должен быть неотрицательным значением времени ожидания. Было указано значение {1}.</value>
  </data>
  <data name="TimeoutMustBePositive" xml:space="preserve">
    <value>Аргумент {0} должен быть положительным значением времени ожидания. Указанное значение: {1}.</value>
  </data>
  <data name="TimeoutOnOperation" xml:space="preserve">
    <value>Не удалось выполнить операцию за выделенное время ожидания {0}. Время, выделенное на эту операцию, может быть составной частью более продолжительного времени ожидания.</value>
  </data>
  <data name="TimeoutOnSqlOperation" xml:space="preserve">
    <value>Не удалось выполнить операцию за выделенное время ожидания {0}. Возможно, время, выделенное на эту операцию, входит в более продолжительное время ожидания.</value>
  </data>
  <data name="TimeoutOpeningSqlConnection" xml:space="preserve">
    <value>Истекло время ожидания при открытии соединения SQL. Не удалось выполнить операцию за выделенное время ожидания {0}. Возможно, время, выделенное на эту операцию, входит в более продолжительное время ожидания.</value>
  </data>
  <data name="TimerExtensionAlreadyAttached" xml:space="preserve">
    <value>Данный класс TimerExtension уже был прикреплен к экземпляру рабочего процесса.</value>
  </data>
  <data name="TimerExtensionRequiresWorkflowInstance" xml:space="preserve">
    <value>Класс TimerExtension может использоваться, только если он прикреплен к экземпляру рабочего процесса.</value>
  </data>
  <data name="TooManyViolationsForExceptionMessage" xml:space="preserve">
    <value>&lt;усечено&gt; Сообщение об исключении было усечено из-за большого размера. Используйте класс ActivityValidationServices, чтобы просмотреть все нарушения.</value>
  </data>
  <data name="TraceCodeEventLogCritical" xml:space="preserve">
    <value>Записал в журнал событий.</value>
  </data>
  <data name="TraceCodeEventLogError" xml:space="preserve">
    <value>Записал в журнал событий.</value>
  </data>
  <data name="TraceCodeEventLogInfo" xml:space="preserve">
    <value>Записал в журнал событий.</value>
  </data>
  <data name="TraceCodeEventLogVerbose" xml:space="preserve">
    <value>Записал в журнал событий.</value>
  </data>
  <data name="TraceCodeEventLogWarning" xml:space="preserve">
    <value>Записал в журнал событий.</value>
  </data>
  <data name="TraceCorrelationKeys" xml:space="preserve">
    <value>Вычислен ключ корреляции "{0}" с использованием значений "{1}" родительской области "{2}".</value>
  </data>
  <data name="TrackingDataExtracted" xml:space="preserve">
    <value>Отслеживание данных, извлеченных {0} в действии {1}.</value>
  </data>
  <data name="TrackingProfileNotFound" xml:space="preserve">
    <value>Не найден TrackingProfile "{0}" для ActivityDefinitionId "{1}". Профиль TrackingProfile не найден в файле конфигурации, или обнаружено несоответствие ActivityDefinitionId.</value>
  </data>
  <data name="TrackingRecordDropped" xml:space="preserve">
    <value>Размер записи отслеживания {0} превышает максимально допустимое значение, разрешенное в сеансе трассировки событий Windows для поставщика {1}</value>
  </data>
  <data name="TrackingRecordRaised" xml:space="preserve">
    <value>Запись отслеживания {0} повышена до {1}.</value>
  </data>
  <data name="TrackingRecordTruncated" xml:space="preserve">
    <value>Усеченная запись отслеживания {0} записана в сеанс трассировки событий Windows с использованием поставщика {1}. Данные переменных, заметок, пользователей удалены</value>
  </data>
  <data name="TrackingRelatedWorkflowAbort" xml:space="preserve">
    <value>При вызове участников отслеживания произошла ошибка, которая привела к прерыванию экземпляра.  Дополнительные сведения см. в описании внутреннего исключения.</value>
  </data>
  <data name="TrackingValueNotSerializable" xml:space="preserve">
    <value>Извлеченный аргумент или переменная "{0}" не сериализуется.</value>
  </data>
  <data name="TransactedReceiveScopeEndCommitFailed" xml:space="preserve">
    <value>Вызов EndCommit для CommittableTransaction с id = "{0}" привел к созданию исключения TransactionException со следующим сообщением: "{1}".</value>
  </data>
  <data name="TransactedReceiveScopeMustHaveValidReceive" xml:space="preserve">
    <value>В свойстве Request класса TransactedReceiveScope "{0}" должно быть задано допустимое действие Receive.</value>
  </data>
  <data name="TransactedReceiveScopeRequiresReceive" xml:space="preserve">
    <value>Перед использованием области TransactedReceiveScope "{0}" необходимо задать свойство ReceiveActivity.</value>
  </data>
  <data name="TransactionHandleAlreadyHasTransaction" xml:space="preserve">
    <value>Объект TransactionHandle уже имеет транзакцию. Невозможно настроить новую транзакцию.</value>
  </data>
  <data name="TransactionInDoubtNonHost" xml:space="preserve">
    <value>Включающая транзакция отсутствовала при вызове InstanceStore.Execute или BeginExecute, однако в ходе обработки команды использовалась внутренняя транзакция. Внутренняя транзакция переведена в состояние InDoubt.</value>
  </data>
  <data name="TransactionPersistenceTimeout" xml:space="preserve">
    <value>Истекло время ожидания запроса, поскольку экземпляр заблокирован другими транзакциями.</value>
  </data>
  <data name="TransactionRolledBackNonHost" xml:space="preserve">
    <value>Включающая транзакция отсутствовала при вызове InstanceStore.Execute или BeginExecute, однако в ходе обработки команды использовалась внутренняя транзакция. Внутренняя транзакция прервана.</value>
  </data>
  <data name="TransitionCannotBeAddedTwice" xml:space="preserve">
    <value>Переход "{0}" нельзя добавить в состояние "{1}", так как он был добавлен в состояние "{2}".</value>
  </data>
  <data name="TransitionTargetCannotBeNull" xml:space="preserve">
    <value>Свойство "To" транзиции "{0}" состояния "{1}" не должно быть равно нулю.</value>
  </data>
  <data name="TriggerOrConditionChangedDuringTransitioning" xml:space="preserve">
    <value>StateMachine не поддерживает динамическое обновление, если действие Trigger или Condition выполняющегося перехода было изменено.</value>
  </data>
  <data name="TriggerOrConditionIsReferenced" xml:space="preserve">
    <value>StateMachine не поддерживает динамическое обновление, если любое из действий Trigger или Condition является ссылкой на импортированного потомка.</value>
  </data>
  <data name="TryCatchExceptionDuringCancelation" xml:space="preserve">
    <value>При отмене дочернего действия для действия TryCatch "{0}" произошло исключение.</value>
  </data>
  <data name="TryCatchExceptionFromCatchOrFinally" xml:space="preserve">
    <value>В действии Catch или Finally, связанном с действием TryCatch "{0}", произошло исключение.</value>
  </data>
  <data name="TryCatchExceptionFromTry" xml:space="preserve">
    <value>В действии TryCatch "{0}" было перехвачено исключение типа "{1}".</value>
  </data>
  <data name="TryCatchInvalidStateForUpdate" xml:space="preserve">
    <value>Не удается выполнить обновление внутри TryCatch, так как исключение типа "{0}" было выявлено, но соответствующий блок catch был удален.</value>
  </data>
  <data name="TryCommandCannotExecuteSubCommandsAndReduce" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она вернула значение false из команды TryCommand (или EndTryCommand) после выполнения вложенной команды с помощью InstancePersistenceContext.Execute (или BeginExecute). Если поставщик сохраняемости распознает команду и обрабатывает ее, он должен возвращать значение true.</value>
  </data>
  <data name="TryLoadRequiresOwner" xml:space="preserve">
    <value>Для операции WorkflowApplication.LoadRunnableInstance требуется явно созданный InstanceOwner. Чтобы использовать этот метод, создайте владельца экземпляра, имеющего тип узла рабочих процессов, и задайте его в свойстве DefaultInstanceOwner объекта InstanceStore.</value>
  </data>
  <data name="TryLoadRequiresWorkflowType" xml:space="preserve">
    <value>Чтобы найти и загрузить доступный для выполнения экземпляр в хранилище, в запрашивающем объекте InstanceOwner во время создания нужно указать тип узла рабочих процессов. Для этого добавьте пару "ключ-значение" в контейнер свойств CreateWorkflowOwnerCommand.InstanceOwnerMetadata во время выполнения команды. Ключом является WorkflowHostType, описанный в документации. Значение должно иметь тип XName и совпадать со значением для загружаемого экземпляра.</value>
  </data>
  <data name="TryRegisterRequestContextFailed" xml:space="preserve">
    <value>Часть контекста обработчика корреляций была неверно использована. Убедитесь, что обработчик был правильно инициализирован средой выполнения и в рабочем процессе за операцией Send следуют операции Receive или ReceiveReply.</value>
  </data>
  <data name="TwoReceiveParametersWithSameNameButDifferentParameterCount" xml:space="preserve">
    <value>Два объекта ReceiveParametersContent с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разное число параметров.</value>
  </data>
  <data name="TwoReceiveParametersWithSameNameButDifferentParameterName" xml:space="preserve">
    <value>Два объекта ReceiveParametersContent с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные имена параметров.</value>
  </data>
  <data name="TwoReceiveParametersWithSameNameButDifferentParameterType" xml:space="preserve">
    <value>Два объекта ReceiveParametersContent с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные типы параметров.</value>
  </data>
  <data name="TwoReceivesWithSameNameButDifferentAction" xml:space="preserve">
    <value>Два объекта Receive с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные действия.</value>
  </data>
  <data name="TwoReceivesWithSameNameButDifferentIsOneWay" xml:space="preserve">
    <value>Два объекта Receive с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные значения IsOneWay.</value>
  </data>
  <data name="TwoReceivesWithSameNameButDifferentTxProperties" xml:space="preserve">
    <value>Два объекта Receive с одинаковыми именами ServiceContractName и OperationName "{0}" имеют различные свойства транзакции.</value>
  </data>
  <data name="TwoReceivesWithSameNameButDifferentValueType" xml:space="preserve">
    <value>Два объекта Receive с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные типы ValueType.</value>
  </data>
  <data name="TwoSendRepliesWithSameNameButDifferentAction" xml:space="preserve">
    <value>Два объекта SendReply с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные действия.</value>
  </data>
  <data name="TwoSendRepliesWithSameNameButDifferentValueType" xml:space="preserve">
    <value>Два объекта SendReply с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные типы ValueType.</value>
  </data>
  <data name="TwoSendReplyParametersWithSameNameButDifferentParameterCount" xml:space="preserve">
    <value>Два объекта SendParametersContent с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разное число параметров.</value>
  </data>
  <data name="TwoSendReplyParametersWithSameNameButDifferentParameterName" xml:space="preserve">
    <value>Два объекта SendParameters с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные имена параметров.</value>
  </data>
  <data name="TwoSendReplyParametersWithSameNameButDifferentParameterType" xml:space="preserve">
    <value>Два объекта SendParameters с одинаковыми свойствами ServiceContractName и OperationName "{0}" имеют разные типы параметров.</value>
  </data>
  <data name="TwoWayIsImplementedAsOneWay" xml:space="preserve">
    <value>Операция "{0}" в контракте "{1}" указана как двунаправленная, но отсутствует действие SendReply. Добавьте действие SendReply для этой операции.</value>
  </data>
  <data name="TypeConverterHelperCacheAddFailed" xml:space="preserve">
    <value>Не удалось добавить метод TypeConverterHelper для типа "{0}" во внутренний кэш вспомогательных методов.</value>
  </data>
  <data name="TypeMismatchForAssign" xml:space="preserve">
    <value>Невозможно присвоить типу "{0}" тип "{1}" в действии Assign "{2}".</value>
  </data>
  <data name="TypeMustbeValueType" xml:space="preserve">
    <value>Тип "{0}" должен быть типом значения.</value>
  </data>
  <data name="TypeNotAssignableTo" xml:space="preserve">
    <value>{1} нельзя присвоить значение {0}.</value>
  </data>
  <data name="UnableToDeserializeHttpResponseContent" xml:space="preserve">
    <value>Не удалось выполнить десериализацию ResponseContent типа "{0}".</value>
  </data>
  <data name="UnableToLocateCompiledLocationContext" xml:space="preserve">
    <value>Невозможно обнаружить ICompiledExpressionRoot для скомпилированного местоположения "{0}". Убедитесь, что определение действия, содержащего это выражение, скомпилировано.</value>
  </data>
  <data name="UnableToOpenAndRegisterStore" xml:space="preserve">
    <value>Не удалось инициализировать объект InstanceStore.</value>
  </data>
  <data name="UnconditionalTransitionShouldNotShareNullTriggersWithOthers" xml:space="preserve">
    <value>Переход без триггера "{0}" для состояния "{1}" должен иметь условие.  Состояние может иметь только один безусловный переход, не имеющий триггера.</value>
  </data>
  <data name="UnconditionalTransitionShouldNotShareTriggersWithOthers" xml:space="preserve">
    <value>Переход "{0}" состояния "{1}" является безусловным. Он не должен иметь тот же триггер "{2}", что и другие переходы.</value>
  </data>
  <data name="UnexpectedArgumentCount" xml:space="preserve">
    <value>Число аргументов, заданных в коллекции "{0}", равно "{1}", а ожидалось "{2}". </value>
  </data>
  <data name="UnexpectedExpressionNodeType" xml:space="preserve">
    <value>Ожидался узел выражения типа "{0}", но был указан узел выражения типа "{1}".</value>
  </data>
  <data name="UnhandledException" xml:space="preserve">
    <value>Необработанное исключение. Сведения об исключении: {0}</value>
  </data>
  <data name="UninitializedCannotHaveData" xml:space="preserve">
    <value>Используемая реализация поставщика сохраняемости InstanceStore недействительна. Она сообщила о загрузке экземпляра в состоянии InstanceState.Uninitialized, который содержит данные экземпляра. Неинициализированные экземпляры не могут содержать данные.</value>
  </data>
  <data name="UnInitializedRuntimeTransactionHandle" xml:space="preserve">
    <value>Указанный объект RuntimeTransactionHandle не был инициализирован должным образом.</value>
  </data>
  <data name="UnknownCompressionOption" xml:space="preserve">
    <value>Запрошенный параметр сжатия {0} не является допустимым.</value>
  </data>
  <data name="UnknownDatabaseVersion" xml:space="preserve">
    <value>Версия базы данных не может быть определена, так как в таблице System.Activities.DurableInstancing.SqlWorkflowInstanceStoreVersionTable не найдено строк. Эта таблица должна содержать одну строку, соответствующую версии платформы, в которой она была создана или до которой была обновлена.</value>
  </data>
  <data name="UnknownExpressionCompilationError" xml:space="preserve">
    <value>При обработке выражения "{0}" произошла неизвестная ошибка. При обработке текста выражения исключений не возникло, но также не создано и выполняемое выражение.</value>
  </data>
  <data name="UnknownLanguage" xml:space="preserve">
    <value>Не удается использовать "{0}" как язык для выражений.</value>
  </data>
  <data name="UnknownSprocResult" xml:space="preserve">
    <value>Хранимая процедура возвратила неизвестный результат выполнения {0}.</value>
  </data>
  <data name="UnlockInstanceException" xml:space="preserve">
    <value>При попытке разблокировать экземпляр обнаружено исключение {0}.</value>
  </data>
  <data name="UnmatchedNoPersistExit" xml:space="preserve">
    <value>В объекте NoPersistHandle обнаружен несогласованный выход.  Для каждого входа может быть вызван только один выход.</value>
  </data>
  <data name="UnopenedActivitiesCannotBeExecuted" xml:space="preserve">
    <value>Можно выполнять только открытые действия.  Действие "{0}" не открыто.</value>
  </data>
  <data name="UnsupportedExpressionType" xml:space="preserve">
    <value>Выражение типа "{0}" не поддерживается.</value>
  </data>
  <data name="UnsupportedLocationReferenceValue" xml:space="preserve">
    <value>Значение LocationReference должно быть переменной, RuntimeArgument или DelegateArgument.</value>
  </data>
  <data name="UnsupportedMemberExpressionWithType" xml:space="preserve">
    <value>Выражение MemberExpression, получающее член типа "{0}", не поддерживается.</value>
  </data>
  <data name="UnsupportedReferenceExpressionType" xml:space="preserve">
    <value>Выражение типа "{0}" для значения LValue не поддерживается.</value>
  </data>
  <data name="UnusedInputArguments" xml:space="preserve">
    <value>Следующие ключи из словаря вводимых значений не соответствуют аргументам и должны быть удалены: {0}. Обратите внимание, что имена аргументов задаются с учетом регистра.</value>
  </data>
  <data name="UnwrappedMessageNotSupported" xml:space="preserve">
    <value>Неупакованные сообщения поддерживаются только с помощью MessageContract. Используйте тип MessageContract для операции "{0}" реализованного контракта "{1}".</value>
  </data>
  <data name="UpdateDefinitionNotFound" xml:space="preserve">
    <value>WorkflowIdentity "{0}" не соответствует любой из размещенных служб WorkflowService.</value>
  </data>
  <data name="UpdateMapBuilderRequiredProperty" xml:space="preserve">
    <value>Необходимо задать свойство "{0}" для DynamicUpdateMapBuilder.</value>
  </data>
  <data name="UpdateMapNotFound" xml:space="preserve">
    <value>DynamicUpdateMap доступные для обновления из WorkflowIdentity "{0}" в "{1}" отсутствуют.</value>
  </data>
  <data name="UpdateSymbolsMustMatch" xml:space="preserve">
    <value>Исходный и обновленный рабочий процесс должны иметь одинаковый номер, имя, тип и порядок внешних символов.</value>
  </data>
  <data name="UriBaseMustBeSpecified" xml:space="preserve">
    <value>В действии "{0}" должен быть указан аргумент UriBase.</value>
  </data>
  <data name="UseInstanceStoreInsteadOfPersistenceProvider" xml:space="preserve">
    <value>Класс System.ServiceModel.Activities.WorkflowServiceHost не совместим с System.ServiceModel.Persistence.PersistenceProviderBehavior.  Следует удалить PersistenceProviderBehavior или производный класс, такой как SqlPersistenceProviderBehavior.  Для поддержки сохраняемости с WorkflowServiceHost следует использовать режим, который устанавливает System.Runtime.DurableInstancing.InstanceStore, например SqlInstanceStoreBehavior.</value>
  </data>
  <data name="ValidateUnlockInstance" xml:space="preserve">
    <value>Системе сохранения экземпляров не удалось обработать недопустимую команду InstancePersistenceCommand. Для команды необходимо, чтобы свойство UnlockInstance имело значение true, если свойство CompleteInstance имеет значение true.</value>
  </data>
  <data name="ValidationContextCannotBeNull" xml:space="preserve">
    <value>Аргумент ToValidateContext объекта {0} с именем "{1}" был разрешен в значение null.  Необходимо предоставить объект контекста проверки, не равный null.</value>
  </data>
  <data name="ValidationErrorPrefixForHiddenActivity" xml:space="preserve">
    <value>В закрытой реализации действия "{0}" обнаружена следующая ошибка проверки:   </value>
  </data>
  <data name="ValidationErrorPrefixForPublicActivityWithHiddenParent" xml:space="preserve">
    <value>В закрытой реализации действия "{0}" обнаружена следующая ошибка проверки в действии "{1}":   </value>
  </data>
  <data name="ValueArgumentTypeNotDerivedFromValueType" xml:space="preserve">
    <value>Тип ArgumentType сообщения не является производным от типа DeclaredMessageType в действии "{0}" с параметром OperationName="{1}".</value>
  </data>
  <data name="ValueCannotBeNegative" xml:space="preserve">
    <value>Значение "{0}" должно быть больше либо равно нулю.</value>
  </data>
  <data name="ValueCannotBeNull" xml:space="preserve">
    <value>Свойство Content должно быть задано в действии "{0}" с параметром OperationName="{1}".</value>
  </data>
  <data name="ValueCollectionUpdatesNotAllowed" xml:space="preserve">
    <value>Изменение коллекции значений, полученных из словаря, запрещено.</value>
  </data>
  <data name="ValueMustBeAssignableToType" xml:space="preserve">
    <value>Предоставленное значение должно быть таким, чтобы его можно было присвоить предоставленному типу.</value>
  </data>
  <data name="ValueMustBeNonNegative" xml:space="preserve">
    <value>Значение должно быть неотрицательным.</value>
  </data>
  <data name="ValueTooLarge" xml:space="preserve">
    <value>"{0}" больше значения Int32.MaxValue не одобрено. Для отключения таймаута укажите значение TimeSpan.MaxValue.</value>
  </data>
  <data name="VariableAlreadyInUseOnActivity" xml:space="preserve">
    <value>Переменную "{0}" нельзя использовать в действии "{1}", поскольку она уже используется в действии "{2}".</value>
  </data>
  <data name="VariableCannotBePopulatedInLocationEnvironment" xml:space="preserve">
    <value>Переменную {0} нельзя заполнять в среде LocationEnvironment.</value>
  </data>
  <data name="VariableDoesNotExist" xml:space="preserve">
    <value>Переменная "{0}" в этой среде не существует.</value>
  </data>
  <data name="VariableExpressionTypeMismatch" xml:space="preserve">
    <value>Значение по умолчанию для переменной "{0}" должно относиться к типу "{1}", однако предоставлено действие с типом результата "{2}".</value>
  </data>
  <data name="VariableIsReadOnly" xml:space="preserve">
    <value>Переменная "{0}" предназначена только для чтения и не может быть изменена.</value>
  </data>
  <data name="VariableMustBeSet" xml:space="preserve">
    <value>Перед вызовом метода CacheMetadata необходимо задать значение переменной.</value>
  </data>
  <data name="VariableNameNotAnIdentifier" xml:space="preserve">
    <value>Невозможно выполнить сериализацию имени переменной "{0}", поскольку оно не является допустимым идентификатором.</value>
  </data>
  <data name="VariableNotOpen" xml:space="preserve">
    <value>Не удается использовать переменную "{0}" типа "{1}". Убедитесь, что эта переменная объявлена в действии или объекте SymbolResolver.</value>
  </data>
  <data name="VariableNotVisible" xml:space="preserve">
    <value>Объект Variable (имя = "{0}"), на который делается ссылка, невидим в данной области. Может существовать другая ссылка на расположение с таким же именем, которое видимо в данной области, но она ссылается на другое расположение.</value>
  </data>
  <data name="VariableOnlyAccessibleAtScopeOfDeclaration" xml:space="preserve">
    <value>Действие "{0}" не имеет доступа к этой переменной, поскольку она объявлена в области действия "{1}".  Действие имеет доступ только к собственным переменным реализации.</value>
  </data>
  <data name="VariableOrArgumentAdditionToReferencedEnvironmentNoDUSupported" xml:space="preserve">
    <value>Добавление переменных или аргументов в уже завершенное действие, на которое может ссылаться обработчик компенсации или обработчик подтверждения, не поддерживается.</value>
  </data>
  <data name="VariableOrArgumentDoesNotExist" xml:space="preserve">
    <value>Переменная или аргумент "{0}" в этой среде не существует.</value>
  </data>
  <data name="VariableShouldBeOpen" xml:space="preserve">
    <value>Перед использованием переменной "{0}" она должна быть включена в действие.</value>
  </data>
  <data name="VariableTypeInvalid" xml:space="preserve">
    <value>Переменную "{0}" нельзя использовать в выражении типа "{1}", поскольку она относится к несовместимому типу "{2}".</value>
  </data>
  <data name="VariableTypeNotMatchLocationType" xml:space="preserve">
    <value>Тип переменной "{0}" не соответствует типу расположения "{1}".</value>
  </data>
  <data name="ExpressionTamperedSinceLastCompiled" xml:space="preserve">
    <value>Сбой при получении дерева выражений с помощью метода GetExpressionTree, поскольку произошло изменение видимых ему текста выражения или среды LocationReferenceEnvironment со времени их кэширования.  Сообщение об ошибке компиляции: {0}.</value>
  </data>
  <data name="WaitAlreadyInProgress" xml:space="preserve">
    <value>Объект InstanceHandle может иметь не более одной незавершенной операции WaitForEvents или BeginWaitForEvents в каждый момент времени. Запрошена вторая операция. Операцию WaitForEvents ил BeginWaitForEvents следует вызывать только после завершения предыдущей операции.</value>
  </data>
  <data name="WaitForEventsTimedOut" xml:space="preserve">
    <value>Время ожидания операции WaitForEvents или BeginWaitForEvents истекло через {0}. Возможно, время, выделенное на эту операцию, входит в более продолжительный интервал ожидания.</value>
  </data>
  <data name="WDCDisposed" xml:space="preserve">
    <value>Объект WorkflowDataContext доступен только из области действия, в которой он был получен.</value>
  </data>
  <data name="WfMessageReceived" xml:space="preserve">
    <value>Сообщение, полученное рабочим процессом</value>
  </data>
  <data name="WfMessageSent" xml:space="preserve">
    <value>Сообщение, отправленное из рабочего процесса</value>
  </data>
  <data name="WhileRequiresCondition" xml:space="preserve">
    <value>Перед использованием действия While "{0}" необходимо задать условие.</value>
  </data>
  <data name="WindowsGroupNotFound" xml:space="preserve">
    <value>Не удается найти группу окон "{0}".</value>
  </data>
  <data name="WorkflowAbortedReason" xml:space="preserve">
    <value>Сообщение InnerException {0}: {1}</value>
  </data>
  <data name="WorkflowActivityResume" xml:space="preserve">
    <value>Элемент WorkflowInstance с идентификатором "{0}", действие E2E</value>
  </data>
  <data name="WorkflowActivityStart" xml:space="preserve">
    <value>Элемент WorkflowInstance с идентификатором "{0}", действие E2E</value>
  </data>
  <data name="WorkflowActivityStop" xml:space="preserve">
    <value>Элемент WorkflowInstance с идентификатором "{0}", действие E2E</value>
  </data>
  <data name="WorkflowActivitySuspend" xml:space="preserve">
    <value>Элемент WorkflowInstance с идентификатором "{0}", действие E2E</value>
  </data>
  <data name="WorkflowApplicationAborted" xml:space="preserve">
    <value>Операция не может быть выполнена, поскольку работа приложения WorkflowApplication {0} прервалась.</value>
  </data>
  <data name="WorkflowApplicationAlreadyHasId" xml:space="preserve">
    <value>Для WorkflowApplication сформирован идентификатор экземпляра, поскольку было считано свойство "Id". После формирования идентификатора WorkflowApplication не может быть использован для загрузки экземпляра.</value>
  </data>
  <data name="WorkflowApplicationCompleted" xml:space="preserve">
    <value>Элемент WorkflowInstance с идентификатором "{0}" завершил работу в состоянии Closed.</value>
  </data>
  <data name="WorkflowApplicationIdled" xml:space="preserve">
    <value>Идентификатор класса WorkflowApplication: "{0}" перешел в состояние простоя.</value>
  </data>
  <data name="WorkflowApplicationInstanceAbandoned" xml:space="preserve">
    <value>Этот экземпляр WorkflowApplicationInstance уже был отменен или находится в процессе отмены. С ним невозможны никакие дальнейшие операции.</value>
  </data>
  <data name="WorkflowApplicationInstanceLoaded" xml:space="preserve">
    <value>Этот экземпляр WorkflowApplicationInstance уже был связан с приложением WorkflowApplication. Для управления экземпляром используйте это приложение WorkflowApplication.</value>
  </data>
  <data name="WorkflowApplicationPersistableIdle" xml:space="preserve">
    <value>Приложение с идентификатором WorkflowApplication: "{0}" бездействует и является сохраняемым.  Будет выполняться следующее действие: {1}.</value>
  </data>
  <data name="WorkflowApplicationPersisted" xml:space="preserve">
    <value>Идентификатор класса WorkflowApplication: "{0}" был сохранен.</value>
  </data>
  <data name="WorkflowApplicationTerminated" xml:space="preserve">
    <value>Идентификатор класса WorkflowApplication: "{0}" был завершен. Был прерван в состоянии сбоя с исключением.</value>
  </data>
  <data name="WorkflowApplicationUnhandledException" xml:space="preserve">
    <value>Идентификатор класса WorkflowInstance: в "{0}" обнаружено необработанное исключение. Исключение произошло в действии "{1}" (отображаемое имя "'{2}"). Будет предпринято следующее действие: {3}.</value>
  </data>
  <data name="WorkflowApplicationUnloaded" xml:space="preserve">
    <value>Элемент WorkflowInstance с идентификатором "{0}" выгружен из памяти.</value>
  </data>
  <data name="WorkflowBehaviorWithNonWorkflowHost" xml:space="preserve">
    <value>Поведение "{0}" должно быть применено к WorkflowServiceHost.</value>
  </data>
  <data name="WorkflowCompletionAsyncResultCannotBeNull" xml:space="preserve">
    <value>Значение AsyncResult, возвращенное объектом OnBeginWorkflowCompleted, не может быть null.</value>
  </data>
  <data name="WorkflowControlEndpointDefaultBaseUriNotSupportedInPartialTrust" xml:space="preserve">
    <value>Значение по умолчанию для WorkflowControlEndpoint.DefaultBaseUri не поддерживается в режиме частичного уровня доверия. Используйте конфигурацию или конструктор, не используемый по умолчанию, для указания привязки и адреса для WorkflowControlEndpoint.</value>
  </data>
  <data name="WorkflowIdentityNullHostId" xml:space="preserve">
    <value>Экземпляр, сохраняемый с идентификатором WorkflowIdentity ("{0}"), не может быть загружен на узел без указания идентификатора WorkflowIdentity.</value>
  </data>
  <data name="WorkflowIdentityNullStateId" xml:space="preserve">
    <value>Экземпляр, сохраняемый без идентификатора WorkflowIdentity, не может быть загружен на узел, для которого был указан идентификатор WorkflowIdentity ("{0}"). Экземпляр можно загрузить с помощью другого определения или обновить с помощью динамического обновления.</value>
  </data>
  <data name="WorkflowIdentityStateIdHostIdMismatch" xml:space="preserve">
    <value>Параметр WorkflowIdentity ("{0}") загруженного экземпляра действия не соответствует параметру WorkflowIdentity ("{1}") указанного определения рабочего процесса. Экземпляр можно загрузить с помощью другого определения или обновить с помощью динамического обновления.</value>
  </data>
  <data name="WorkflowInstanceAborted" xml:space="preserve">
    <value>Не удалось выполнить операцию, поскольку прервано выполнение WorkflowInstance "{0}".</value>
  </data>
  <data name="WorkflowInstanceAbortedRecordWithId" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceAbortedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}</value>
  </data>
  <data name="WorkflowInstanceCanceled" xml:space="preserve">
    <value>Элемент WorkflowInstance с идентификатором "{0}" завершил работу в состоянии Canceled.</value>
  </data>
  <data name="WorkflowInstanceCompleted" xml:space="preserve">
    <value>Не удалось выполнить операцию, поскольку завершено выполнение WorkflowInstance "{0}".</value>
  </data>
  <data name="WorkflowInstanceIsReadOnly" xml:space="preserve">
    <value>WorkflowInstance "{0}" нельзя изменять после запуска.</value>
  </data>
  <data name="WorkflowInstanceNotFoundInStore" xml:space="preserve">
    <value>Экземпляр "{0}" обнаружен в хранилище экземпляров, однако он не содержит поток операций.</value>
  </data>
  <data name="WorkflowInstanceRecordWithId" xml:space="preserve">
    <value>TrackRecord= WorkflowInstanceRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, State = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}</value>
  </data>
  <data name="WorkflowInstanceSuspendedRecord" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceSuspendedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, причина = {4}, заметки = {5}, ProfileName = {6}</value>
  </data>
  <data name="WorkflowInstanceSuspendedRecordWithId" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceSuspendedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}</value>
  </data>
  <data name="WorkflowInstanceTerminated" xml:space="preserve">
    <value>Не удалось выполнить операцию, поскольку выполнение WorkflowInstance "{0}" завершено.</value>
  </data>
  <data name="WorkflowInstanceTerminatedRecord" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceTerminatedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}</value>
  </data>
  <data name="WorkflowInstanceTerminatedRecordWithId" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceTerminatedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}</value>
  </data>
  <data name="WorkflowInstanceUnhandledExceptionRecordWithId" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceUnhandledExceptionRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, SourceName = {4}, SourceId = {5}, SourceInstanceId = {6}, SourceTypeName={7}, Exception ={8}, Annotations = {9}, ProfileName = {10}, WorkflowDefinitionIdentity = {11}</value>
  </data>
  <data name="WorkflowInstanceUnloaded" xml:space="preserve">
    <value>Не удалось выполнить операцию, поскольку экземпляр WorkflowInstance "{0}" выгружен.</value>
  </data>
  <data name="WorkflowInstanceUnlocked" xml:space="preserve">
    <value>Невозможно выполнить операцию, поскольку экземпляр WorkflowInstance {0} разблокирован.</value>
  </data>
  <data name="WorkflowInstanceUpdatedRecord" xml:space="preserve">
    <value>TrackRecord= WorkflowInstanceUpdatedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, State = {4}, OriginalDefinitionIdentity = {5}, UpdatedDefinitionIdentity = {6}, Annotations = {7}, ProfileName = {8}</value>
  </data>
  <data name="WorkflowInstanceUpdateFailed" xml:space="preserve">
    <value>Не удалось обновить WorkflowInstance "{0}" до идентификатора "{1}". Проверьте выходные данные отслеживания на наличие списка выполняющихся действий, которые не удалось обновить.</value>
  </data>
  <data name="WorkflowMustBeHosted" xml:space="preserve">
    <value>Убедитесь, что действие Receive размещено в узле WorkflowServiceHost.</value>
  </data>
  <data name="WorkflowServiceDefinitionIdentityNotMatched" xml:space="preserve">
    <value>Параметр WorkflowIdentity ("{0}") загруженного экземпляра действия не соответствует ни одной из размещенных служб WorkflowService.</value>
  </data>
  <data name="WorkflowServiceHostCannotAddOrRemoveServiceDefinitionAfterOpen" xml:space="preserve">
    <value>Определения WorkflowService нельзя добавлять или удалять после открытия, сбоя, отмены или закрытия WorkflowServiceHost.</value>
  </data>
  <data name="WorkflowTerminatedExceptionDefaultMessage" xml:space="preserve">
    <value>Рабочий процесс был завершен действием Terminate.</value>
  </data>
  <data name="WorkItemAbortedInstance" xml:space="preserve">
    <value>Обработка ошибки текущего рабочего элемента вызвала прерывание потока операций.  Подробные сведения см. в описании внутреннего исключения.</value>
  </data>
  <data name="WrapperNotSupportedInMessageContract" xml:space="preserve">
    <value>Пользовательские имена и пространства имен оболочек поддерживаются только с помощью контрактов MessageContract. Используйте тип MessageContract для операции "{0}" реализованного контракта "{1}".</value>
  </data>
  <data name="WriteAccessToReadOnlyPublicReference" xml:space="preserve">
    <value>Действию "{0}" не удается выполнить запись в это общее местоположение по ссылке, так как она была объявлена с помощью ArgumentDirection.In. Чтобы разрешить чтение и запись, объявите ссылку с помощью ArgumentDirection.InOut.</value>
  </data>
  <data name="WriteonlyPropertyCannotBeRead" xml:space="preserve">
    <value>Свойство индексатора "{0}.{1}" нельзя использовать в этом контексте, поскольку метод доступа get недоступен.</value>
  </data>
  <data name="WrongArgumentType" xml:space="preserve">
    <value>Аргумент имеет неправильный тип.  Он относится к типу "{0}", а должен относиться к типу "{1}".</value>
  </data>
  <data name="WrongCacheMetadataForCodeActivity" xml:space="preserve">
    <value>Метод CacheMetadata, который принимает параметр ActivityMetadata, не должен вызываться в классах CodeActivity или AsyncCodeActivity. Правильный метод CacheMetadata для этих классов принимает параметр CodeActivityMetadata.</value>
  </data>
  <data name="WrongCacheMetadataForNativeActivity" xml:space="preserve">
    <value>Метод CacheMetadata, который принимает параметр ActivityMetadata, не должен вызываться в классе NativeActivity. Правильный метод CacheMetadata для класса NativeActivity принимает параметр NativeActivityMetadata.</value>
  </data>
  <data name="WrongEnvironmentCount" xml:space="preserve">
    <value>Ожидалось, что действие "{0}" будет иметь аргументов: "{1}", открытых переменных: "{2}", закрытых переменных: "{3}" и делегатов аргументов времени выполнения: "{4}". В действительности имеется аргументов: "{5}", открытых переменных: "{6}", закрытых переменных: "{7}", делегатов аргументов времени выполнения: "{8}".</value>
  </data>
  <data name="WrongMemberCount" xml:space="preserve">
    <value>IdSpace с владельцем "{0}" имеет {1} членов. Ожидалось "{2}".</value>
  </data>
  <data name="WrongNumberOfArgumentsForActivityDelegate" xml:space="preserve">
    <value>Аргументы ActivityDelegate не соответствуют объявленным. Проверьте конфигурацию действия и убедитесь, что оно синхронизировано с объявленным делегатом ActivityDelegate.</value>
  </data>
  <data name="WrongOnCreateDynamicUpdateMapForNativeActivity" xml:space="preserve">
    <value>Метод OnCreateDynamicUpdateMap, принимающий параметр UpdateMapMetadata, не должен вызываться для NativeActivity. Правильный метод OnCreateDynamicUpdateMap для NativeActivity принимает параметр NativeActivityUpdateMapMetadata.</value>
  </data>
  <data name="WrongOriginalEnvironmentCount" xml:space="preserve">
    <value>Ожидалось, что исходное окружение действия "{0}" будет иметь аргументов: "{1}", открытых переменных: "{2}", закрытых переменных: "{3}" и делегатов аргументов времени выполнения: "{4}"; всего: "{5}". Общее число местоположений: "{6}".</value>
  </data>
  <data name="XamlBuildTaskResourceNotFound" xml:space="preserve">
    <value>Предполагалось, что ресурс XAML будет создан расширением построения задания XAML ({0}). Этот ресурс не найден. Перестройте проект.</value>
  </data>
  <data name="XamlElementExpected" xml:space="preserve">
    <value>Ожидается представление элемента.</value>
  </data>
  <data name="XamlElementExpectedAt" xml:space="preserve">
    <value>В строке ({0}, {1}) ожидается представление элемента.</value>
  </data>
</root>