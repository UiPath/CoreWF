<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AbortingDueToDynamicUpdateFailure" xml:space="preserve">
    <value>WorkflowApplication a été abandonné car une tentative de mise à jour d'instance a échoué.</value>
  </data>
  <data name="AbortingDueToInstanceTimeout" xml:space="preserve">
    <value>L'instance de workflow a été abandonnée, car son exécution a dépassé le délai imparti.</value>
  </data>
  <data name="AbortingDueToLoadFailure" xml:space="preserve">
    <value>WorkflowApplication a été abandonné car une opération Load ou LoadRunnableInstance a levé une exception. Créez un nouvel objet WorkflowApplication pour tenter de charger une autre instance de workflow.</value>
  </data>
  <data name="AbortingDueToVersionMismatch" xml:space="preserve">
    <value>WorkflowApplication a été abandonné car une opération Load ou LoadRunnableInstance a levé une exception VersionMismatchException.</value>
  </data>
  <data name="AbortInstanceOnTransactionFailureDoesNotMatch" xml:space="preserve">
    <value>La valeur de la propriété AbortInstanceOnTransactionFailure de l'activité TransactionScope '{0}' imbriquée dans l'activité TransactedReceiveScope '{1}' ne doit pas avoir la valeur False.</value>
  </data>
  <data name="ActionItemCallbackInvoked" xml:space="preserve">
    <value>Rappel du planificateur de threads d'E/S invoqué.</value>
  </data>
  <data name="ActionItemIsAlreadyScheduled" xml:space="preserve">
    <value>ActionItem est déjà planifié pour une exécution qui n'est pas encore terminée.</value>
  </data>
  <data name="ActionItemScheduled" xml:space="preserve">
    <value>Rappel du planificateur de threads d'E/S invoqué.</value>
  </data>
  <data name="ActivityBlockingUpdate" xml:space="preserve">
    <value>Activité '{0}' : {1}</value>
  </data>
  <data name="ActivityCannotBeReferenced" xml:space="preserve">
    <value>Impossible de référencer l'activité '{0}' par l'activité '{1}', car l'activité '{0}' est déjà référencée ailleurs dans le workflow et cette référence n'est pas visible par l'activité '{1}'. Pour que l'activité '{0}' soit visible par l'activité '{1}', elle doit être un enfant ou un enfant importé (mais pas un enfant de l'implémentation) de l'activité '{2}'. L'activité '{0}' est à l'origine référencée par l'activité '{3}' et l'activité '{1}' se trouve dans l'implémentation de l'activité '{2}'.</value>
  </data>
  <data name="ActivityCannotBeReferencedWithoutTarget" xml:space="preserve">
    <value>Impossible de référencer l'activité '{0}' par l'activité '{1}' car cette dernière ne se trouve pas dans l'implémentation de cette activité. Une activité ne peut être référencée que par l'implémentation d'une activité qui spécifie cette activité en tant qu'enfant ou importation. L'activité '{0}' est déclarée par l'activité '{2}'.</value>
  </data>
  <data name="ActivityCannotReferenceItself" xml:space="preserve">
    <value>L'activité portant le nom d'affichage '{0}' essaie de s'autoréférencer. Une activité ne peut pas être son propre parent.</value>
  </data>
  <data name="ActivityCompleted" xml:space="preserve">
    <value>L'activité '{0}', DisplayName : '{1}', InstanceID : '{2}' s'est terminée à l'état '{3}'.</value>
  </data>
  <data name="ActivityDefinitionCannotBeShared" xml:space="preserve">
    <value>L'objet de définition de l'activité pour '{0}' semble être partagé entre plusieurs nœuds dans le workflow. Il ne faut pas réutiliser un objet de définition d'activité au sein d'un workflow.</value>
  </data>
  <data name="ActivityDelegateAlreadyOpened" xml:space="preserve">
    <value>ActivityDelegate '{0}' a déjà une activité '{1}' comme parent et ne peut pas avoir une activité '{2}' comme parent. Un délégué ne peut retourner qu'un seul enfant à la fois.</value>
  </data>
  <data name="ActivityDelegateCannotBeReferenced" xml:space="preserve">
    <value>Impossible de référencer le délégué de l'activité avec Handler '{0}' par l'activité '{1}' car cette dernière ne se trouve pas dans l'implémentation de l'activité '{2}'. Un délégué d'activité ne peut être référencé que par l'implémentation d'une activité qui spécifie ce délégué d'activité en tant qu'enfant ou importation. Le délégué de l'activité avec Handler '{0}' est déclaré par l'activité '{3}'.</value>
  </data>
  <data name="ActivityDelegateCannotBeReferencedNoHandler" xml:space="preserve">
    <value>Impossible de référencer le délégué d'activité sans Handler par l'activité '{0}' car cette dernière ne se trouve pas dans l'implémentation de l'activité '{1}'. Un délégué d'activité ne peut être référencé que par l'implémentation d'une activité qui spécifie ce délégué d'activité en tant qu'enfant ou importation. Le délégué d'activité sans Handler est déclaré par l'activité '{2}'.</value>
  </data>
  <data name="ActivityDelegateCannotBeReferencedWithoutTarget" xml:space="preserve">
    <value>Impossible de référencer le délégué d'activité avec Handler '{0}' par l'activité '{1}' car cette dernière ne se trouve pas dans l'implémentation d'une autre activité. Un délégué d'activité ne peut être référencé que par l'implémentation d'une activité qui spécifie ce délégué d'activité en tant qu'enfant ou importation. Le délégué d'activité avec Handler '{0}' est déclaré par l'activité '{2}'.</value>
  </data>
  <data name="ActivityDelegateCannotBeReferencedWithoutTargetNoHandler" xml:space="preserve">
    <value>Impossible de référencer le délégué d'activité sans Handler par l'activité '{0}' car cette dernière ne se trouve pas dans l'implémentation d'une autre activité. Un délégué d'activité ne peut être référencé que par l'implémentation d'une activité qui spécifie ce délégué d'activité en tant qu'enfant ou importation. Le délégué d'activité sans Handler est déclaré par l'activité '{1}'.</value>
  </data>
  <data name="ActivityDelegateHandlersMustBeDeclarations" xml:space="preserve">
    <value>Le Handler pour un ActivityDelegate, ActivityAction ou ActivityFunc ne doit pas être une référence à une activité qui existe déjà dans l'arborescence. L'activité Handler '{0}' d'un délégué dont le parent est '{1}' est déjà référencée par '{2}'.</value>
  </data>
  <data name="ActivityDelegateNotOpened" xml:space="preserve">
    <value>ActivityDelegate '{0}' n'est pas dans un état ouvert.</value>
  </data>
  <data name="ActivityDelegateOwnerEnvironmentMissing" xml:space="preserve">
    <value>Environnement d'emplacement pour l'activité '{0}' qui déclare le délégué d'activité '{1}' introuvable.</value>
  </data>
  <data name="ActivityDelegateOwnerMissing" xml:space="preserve">
    <value>Un élément propriétaire de workflow doit être spécifié pour ActivityDelegate '{0}'.</value>
  </data>
  <data name="ActivityDelegateOwnerNotInParentScope" xml:space="preserve">
    <value>Le Activity qui déclare ActivityDelegate '{0}' n'a pas été trouvé dans la hiérarchie parente de l'activité '{1}' en cours d'exécution.</value>
  </data>
  <data name="ActivityFailedToOpenBefore" xml:space="preserve">
    <value>Impossible d'ouvrir cette activité car elle n'a pas pu être ouverte précédemment.</value>
  </data>
  <data name="ActivityHasNoImplementation" xml:space="preserve">
    <value>L'activité '{0}' a une table d'implémentation, mais pas d'implémentation.</value>
  </data>
  <data name="ActivityInstanceFixupFailed" xml:space="preserve">
    <value>Échec de chargement du workflow. L'arborescence d'activité donnée n'est pas compatible avec cette instance.</value>
  </data>
  <data name="ActivityIsNotRoot" xml:space="preserve">
    <value>Cet argument doit être la racine de la définition de workflow.</value>
  </data>
  <data name="ActivityIsUncached" xml:space="preserve">
    <value>Cette méthode ne peut être appelée qu'après l'appel de CacheMetadata sur la définition de workflow.</value>
  </data>
  <data name="ActivityMapIsCorrupt" xml:space="preserve">
    <value>Le mappage entre le programme d'activité et l'instance est endommagé au sein de l'instance persistante.</value>
  </data>
  <data name="ActivityNotFound" xml:space="preserve">
    <value>Activité '{0}' introuvable.</value>
  </data>
  <data name="ActivityNotICompiledExpressionRoot" xml:space="preserve">
    <value>L'activité doit être ICompiledExpressionRoot pour pouvoir déterminer l'ID de l'expression. Assurez-vous que la définition actuelle a été compilée.</value>
  </data>
  <data name="ActivityNotPartOfThisTree" xml:space="preserve">
    <value>L'activité fournie ne faisait pas partie de cette définition de workflow lorsque ses métadonnées ont été traitées. L'activité problématique nommée '{0}' a été fournie par l'activité nommée '{1}'.</value>
  </data>
  <data name="ActivityPropertyMustBeSet" xml:space="preserve">
    <value>'{0}' est une propriété requise pour l'activité '{1}'.</value>
  </data>
  <data name="ActivityPropertyNotSet" xml:space="preserve">
    <value>La propriété '{0}' de l'activité '{1}' est Null et n'a aucun effet.</value>
  </data>
  <data name="ActivityPropertyRequiresName" xml:space="preserve">
    <value>'Name' est une propriété requise pour chaque ActivityProperty sur DynamicActivity '{0}'.</value>
  </data>
  <data name="ActivityPropertyRequiresType" xml:space="preserve">
    <value>'Type' est une propriété requise pour chaque ActivityProperty sur DynamicActivity '{0}'.</value>
  </data>
  <data name="ActivityScheduled" xml:space="preserve">
    <value>L'activité parent '{0}', DisplayName : '{1}', InstanceID : '{2}' a planifié l'activité enfant '{3}', DisplayName : '{4}', InstanceID : '{5}'.</value>
  </data>
  <data name="ActivityTypeMismatch" xml:space="preserve">
    <value>'{0}' n'est pas de type '{1}'. Lors du téléchargement de cette instance vous devez vérifier que l'activité portant le nom '{0}' implémente '{1}'.</value>
  </data>
  <data name="ActivityXamlServiceLineString" xml:space="preserve">
    <value>Ligne</value>
  </data>
  <data name="ActivityXamlServicesCompilationFailed" xml:space="preserve">
    <value>Échecs de compilation : {0}Les résultats complets se trouvent dans la propriété Data de cette exception. Corrigez les erreurs de la source, puis retentez le chargement.</value>
  </data>
  <data name="ActivityXamlServicesRequiresActivity" xml:space="preserve">
    <value>ActivityXamlServices.Load ne prend en charge que les types basés sur une activité. Un type non valide ({0}) a été fourni.</value>
  </data>
  <data name="AddedIdleArgumentBlockDU" xml:space="preserve">
    <value>L'expression de l'argument '{0}' récemment ajouté contient l'activité '{1}', qui peut devenir inactive pendant l'exécution. Pour activer la mise à jour dynamique au sein de cette activité, utilisez l'expression d'un argument dont vous aurez vérifié qu'elle ne peut pas devenir inactive.</value>
  </data>
  <data name="AddedIdleExpressionBlockDU" xml:space="preserve">
    <value>Une nouvelle valeur par défaut ou expression d'argument pouvant devenir inactive pendant l'exécution a été ajoutée.</value>
  </data>
  <data name="AddedIdleVariableDefaultBlockDU" xml:space="preserve">
    <value>L'expression par défaut de la variable '{0}' récemment ajoutée contient l'activité '{1}', qui peut devenir inactive pendant l'exécution. Pour activer la mise à jour dynamique au sein de cette activité, utilisez l'expression d'une variable par défaut dont vous aurez vérifié qu'elle ne peut pas devenir inactive.</value>
  </data>
  <data name="AddMatchActivityNewAndOldParentMismatch" xml:space="preserve">
    <value>Impossible de faire correspondre la nouvelle activité '{0}' à l'ancienne activité '{1}' car leurs déclarateurs ne sont pas les mêmes. La nouvelle activité est déclarée par '{2}' alors que l'ancienne activité est déclarée par '{3}'.</value>
  </data>
  <data name="AddMatchActivityNewParentMismatch" xml:space="preserve">
    <value>L'activité '{0}' ne peut pas ajouter une correspondance pour l'activité '{1}' car il ne s'agit pas de son déclarateur. L'activité correspondante est déclarée par '{2}'.</value>
  </data>
  <data name="AddMatchActivityPrivateChild" xml:space="preserve">
    <value>Impossible d'ajouter une correspondance pour l'activité '{0}' car il s'agit d'un enfant privé. Les correspondances ne peuvent être que des enfants publics.</value>
  </data>
  <data name="AddMatchVariableNewAndOldParentMismatch" xml:space="preserve">
    <value>Impossible de faire correspondre la nouvelle variable '{0}' à l'ancienne variable '{1}' car leurs propriétaires ne sont pas les mêmes. Le propriétaire de la nouvelle variable est '{2}' alors que le propriétaire de l'ancienne variable est '{3}'.</value>
  </data>
  <data name="AddMatchVariableNewParentMismatch" xml:space="preserve">
    <value>L'activité '{0}' ne peut pas ajouter de correspondance pour la variable '{1}' car elle n'est pas son propriétaire. Le propriétaire de la variable correspondante est '{2}'.</value>
  </data>
  <data name="AddMatchVariablePrivateChild" xml:space="preserve">
    <value>Impossible d'ajouter une correspondance à la variable '{0}' car elle est privée. Les correspondances peuvent uniquement être ajoutées aux variables publiques.</value>
  </data>
  <data name="AddMatchVariableSignatureMismatch" xml:space="preserve">
    <value>L'activité '{0}' ne peut pas ajouter de correspondance de variable car les signatures des deux variables ne sont pas les mêmes. Les signatures, y compris le nom, le type et les modificateurs, doivent correspondre. Le nom, le type et les modificateurs de la nouvelle variable sont respectivement, {1}, {2} et {3}. Le nom, le type et les modificateurs de l'ancienne variable sont respectivement, {4}, {5} et {6}.  </value>
  </data>
  <data name="AddValidationErrorMustBeCalledFromConstraint" xml:space="preserve">
    <value>AddValidationError peut uniquement être appelé par le sous-arbre d'une activité {0}.</value>
  </data>
  <data name="AECDisposed" xml:space="preserve">
    <value>ActivityContext n'est accessible qu'au sein de la portée de la fonction dans laquelle il a été passé.</value>
  </data>
  <data name="AECForPropertiesHasBeenDisposed" xml:space="preserve">
    <value>L'ActivityContext qui a créé cet objet ExecutionProperties a déjà été éliminé. Les propriétés ne sont accessibles que lors d'un élément de travail de l'activité.</value>
  </data>
  <data name="AlreadyBoundToInstance" xml:space="preserve">
    <value>Ce système de persistance d'instance n'a pas réussi à traiter un InstancePersistenceCommand non valide. La commande requiert un handle non lié, mais InstanceHandle est déjà lié à une instance.</value>
  </data>
  <data name="AlreadyBoundToOwner" xml:space="preserve">
    <value>Le système de persistance d'instance n'a pas réussi à traiter un InstancePersistenceCommand non valide. La commande requiert un handle indépendant, mais InstanceHandle est déjà lié à un propriétaire d'instance.</value>
  </data>
  <data name="AlreadySetupNoPersist" xml:space="preserve">
    <value>Cet élément de workflow a déjà configuré un bloc sans persistance. Un seul bloc sans persistance peut être configuré par un élément de workflow.</value>
  </data>
  <data name="AmbiguousVBVariableReference" xml:space="preserve">
    <value>'{0}' est une référence de variable ambiguë. Les identificateurs VisualBasic ne respectent pas la casse.</value>
  </data>
  <data name="AppDomainUnload" xml:space="preserve">
    <value>Déchargement AppDomain. AppDomain.FriendlyName {0}, ProcessName {1}, ProcessId {2}.</value>
  </data>
  <data name="ArgumentAlreadyInitialized" xml:space="preserve">
    <value>L'argument '{0}' de l'activité '{1}' aurait dû être ajouté à l'aide d'une mise à jour dynamique, mais il a déjà été initialisé.</value>
  </data>
  <data name="ArgumentAlreadyInUse" xml:space="preserve">
    <value>Argument '{0}' est utilisé par Activity '{1}' ; il ne peut donc pas être utilisé également par Activity '{2}'.</value>
  </data>
  <data name="ArgumentCannotHaveNullOrVoidType" xml:space="preserve">
    <value>L'activité avec DisplayName='{0}' a un argument nommé '{1}' qui est de type Null ou void.</value>
  </data>
  <data name="ArgumentDirectionMismatch" xml:space="preserve">
    <value>Impossible de lier l'argument fourni par RuntimeArgument '{0}' en raison d'une incompatibilité de direction. RuntimeArgument déclare la direction comme étant {1} et Argument a une direction égale à {2}.</value>
  </data>
  <data name="ArgumentDoesNotExist" xml:space="preserve">
    <value>Aucun argument portant le nom '{0}' n'existe dans cette collection.</value>
  </data>
  <data name="ArgumentDoesNotExistInEnvironment" xml:space="preserve">
    <value>L'argument '{0}' n'existe pas dans la portée d'environnement actuelle.</value>
  </data>
  <data name="ArgumentIsAddedMoreThanOnce" xml:space="preserve">
    <value>L'argument '{0}' est ajouté plusieurs fois à l'activité '{1}'.</value>
  </data>
  <data name="ArgumentLocationExpressionTypeMismatch" xml:space="preserve">
    <value>L'expression est requise comme type '{0}', mais le type '{1}' a été fourni.</value>
  </data>
  <data name="ArgumentMustbePropertyofWorkflowElement" xml:space="preserve">
    <value>Un argument doit être l'une des propriétés d'un WorkflowElement.</value>
  </data>
  <data name="ArgumentNameRequired" xml:space="preserve">
    <value>Le nom de l'argument d'un ArgumentReference ou d'un ArgumentValue doit être défini.</value>
  </data>
  <data name="ArgumentNotFound" xml:space="preserve">
    <value>Impossible de trouver l'argument nommé '{0}' sur l'activité propriétaire de ces enfants privés. ArgumentReference et ArgumentValue ne doivent être utilisés que dans le corps d'une définition Activity.</value>
  </data>
  <data name="ArgumentNotInTree" xml:space="preserve">
    <value>Impossible d'utiliser l'argument de type '{0}'. Vérifiez qu'il est déclaré dans cette activité.</value>
  </data>
  <data name="ArgumentNullOrEmpty" xml:space="preserve">
    <value>L'argument {0} est Null ou vide.</value>
  </data>
  <data name="ArgumentNumberRequiresTheSameAsParameterNumber" xml:space="preserve">
    <value>Le nombre d'arguments et le nombre de paramètres de type '{0}' doivent être identiques.</value>
  </data>
  <data name="ArgumentRequired" xml:space="preserve">
    <value>Le contenu de l'argument dans la collection '{0}' de '{1}' est requis.</value>
  </data>
  <data name="ArgumentTypeCannotBeNull" xml:space="preserve">
    <value>Le type de l'argument ne peut pas être Null.</value>
  </data>
  <data name="ArgumentTypeMismatch" xml:space="preserve">
    <value>L'argument fourni pour RuntimeArgument '{0}' ne peut pas être lié en raison d'une incompatibilité de type. RuntimeArgument déclare le type {1} et l'argument est du type {2}. Les deux types doivent être identiques.</value>
  </data>
  <data name="ArgumentTypeMustBeCompatible" xml:space="preserve">
    <value>Le type d'argument doit être compatible avec le type de ArgumentReference ou de ArgumentValue. L'argument '{0}' est de type {1} et le type attendu est {2}.</value>
  </data>
  <data name="ArgumentValueExpressionTypeMismatch" xml:space="preserve">
    <value>ResultType doit être '{0}' pour l'argument, mais une activité avec un type de résultat '{1}' est fournie.</value>
  </data>
  <data name="ArgumentViolationsFound" xml:space="preserve">
    <value>Violations trouvées dans l'activité '{0}'. Une ou plusieurs violations ont été trouvées comme suit :    {1}</value>
  </data>
  <data name="AssemblyReferenceIsImmutable" xml:space="preserve">
    <value>Impossible de modifier les AssemblyReferences intégrés par défaut.</value>
  </data>
  <data name="AsyncCallbackThrewException" xml:space="preserve">
    <value>Le rappel asynchrone a levé une exception.</value>
  </data>
  <data name="AsyncEventArgsCompletedTwice" xml:space="preserve">
    <value>L'implémentation AsyncEventArgs '{0}' a tenté d'effectuer une même opération plusieurs fois. Cela peut être dû à une implémentation AsyncEventArgs incorrecte de l'application ou à un autre code d'extensibilité qui appelle AsyncCallback plusieurs fois.</value>
  </data>
  <data name="AsyncEventArgsCompletionPending" xml:space="preserve">
    <value>L'implémentation AsyncEventArgs '{0}' a tenté de définir l'état sur En attente plusieurs fois sans terminer une opération mise en attente. Cela peut être dû à une implémentation incorrecte d'AsyncEventArgs par l'application ou à un autre code d'extensibilité qui appelle Set() plusieurs fois.</value>
  </data>
  <data name="AsyncMethodsMustAllBeStaticOrInstance" xml:space="preserve">
    <value>Les méthodes async doivent être toutes statiques ou d'instance.</value>
  </data>
  <data name="AsyncMethodsMustFromSameType" xml:space="preserve">
    <value>Les méthodes async doivent toutes être du même type.</value>
  </data>
  <data name="AsyncResultAlreadyEnded" xml:space="preserve">
    <value>End ne peut pas être appelé deux fois sur un AsyncResult.</value>
  </data>
  <data name="AsyncResultCompletedTwice" xml:space="preserve">
    <value>L'implémentation IAsyncResult '{0}' a tenté d'effectuer une même opération plusieurs fois. Cela peut être dû à une implémentation IAsyncResult incorrecte de l'application ou à un autre code d'extensibilité, tel qu'un IAsyncResult qui retourne des valeurs CompletedSynchronously incorrectes ou qui appelle AsyncCallback plusieurs fois.</value>
  </data>
  <data name="AsyncTransactionException" xml:space="preserve">
    <value>Une exception a été levée à partir d'un TransactionScope utilisé pour passer une transaction dans une opération asynchrone.</value>
  </data>
  <data name="BadCopyToArray" xml:space="preserve">
    <value>Impossible de copier les éléments du dictionnaire dans le tableau spécifié. Cela est dû à une ou plusieurs des erreurs suivantes : le tableau avait trop de dimensions, l'index se trouvait au-delà de la fin du tableau ou le tableau ne disposait pas de suffisamment d'espace.</value>
  </data>
  <data name="BadWorkflowIdentityFormat" xml:space="preserve">
    <value>Format de WorkflowIdentity non valide. WorkflowIdentity doit répondre au format 'nom; Version=version; Package=package'. La version et le package sont facultatifs.</value>
  </data>
  <data name="BeforeInitializeComponentXBTExtensionResourceNotFound" xml:space="preserve">
    <value>La ressource qui aurait dû être générée par l'extension de tâche de génération XAML BeforeInitializeComponent est introuvable. Régénérez le projet.</value>
  </data>
  <data name="BeginExecuteMustNotReturnANullAsyncResult" xml:space="preserve">
    <value>AsyncCodeActivity.BeginExecute ne doit pas retourné un IAsyncResult Null.</value>
  </data>
  <data name="BeginExecuteMustUseProvidedStateAsAsyncResultState" xml:space="preserve">
    <value>AsyncCodeActivity.BeginExecute doit retourner un IAsyncResult pour lequel IAsyncResult.AsyncState est l'objet d'état fourni par le runtime.</value>
  </data>
  <data name="BinaryExpressionActivityRequiresArgument" xml:space="preserve">
    <value>{0} doit être défini avant que l'activité {1} '{2}' puisse être utilisée.</value>
  </data>
  <data name="BindLockRequiresCommandFlag" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a appelé BindAcquiredLock, BindReclaimedLock, BeginBindReclaimedLock ou CreateBindReclaimedLockException à une heure incorrecte. Ces méthodes ne peuvent être appelées que lors du traitement d'une commande susceptible d'acquérir un verrou sur une instance. Basculez vers un fournisseur de persistance valide ou remplacez l'implémentation InstancePersistenceCommand pour retourner la valeur True à partir de AutomaticallyAcquiringLock.</value>
  </data>
  <data name="BindReclaimedLockException" xml:space="preserve">
    <value>Cette exception ne représente pas une erreur et ne doit pas être interceptée. Elle peut être levée à partir d'une implémentation du fournisseur de persistance de InstanceStore.TryCommand, BeginTryCommand ou EndTryCommand pour indiquer qu'il est nécessaire de tenter de récupérer le verrou dont la version est celle spécifiée dans l'appel à InstancePersistenceContext.CreateBindReclaimedLockException.</value>
  </data>
  <data name="BindReclaimSucceeded" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore a annulé la commande. Un verrou orphelin a été récupéré et la commande annulée via InstancePersistenceContext.CreateBindReclaimedLockException.</value>
  </data>
  <data name="BlockedUpdateInsideActivityUpdateByUserError" xml:space="preserve">
    <value>L'auteur de la mise à jour a interdit la mise à jour au sein de l'activité en cours d'exécution.</value>
  </data>
  <data name="BlockedUpdateInsideActivityUpdateError" xml:space="preserve">
    <value>La mise à jour dynamique de cette activité est bloquée.</value>
  </data>
  <data name="BodyCannotBeNull" xml:space="preserve">
    <value>Le corps de la description du message ne peut pas être Null. Attribuez une valeur correcte à OperationDescription.MessageDescription.Body.</value>
  </data>
  <data name="BookmarkAlreadyExists" xml:space="preserve">
    <value>Un signet portant le nom '{0}' existe déjà.</value>
  </data>
  <data name="BookmarkNotFoundGeneric" xml:space="preserve">
    <value>Impossible de trouver le signet demandé.</value>
  </data>
  <data name="BookmarkNotRegistered" xml:space="preserve">
    <value>Le signet {0} n'est pas inscrit actuellement dans Compensation Extension.</value>
  </data>
  <data name="BookmarkScopeAlreadyInitialized" xml:space="preserve">
    <value>Impossible d'initialiser la portée du signet car elle est déjà initialisée.</value>
  </data>
  <data name="BookmarkScopeHasBookmarks" xml:space="preserve">
    <value>Impossible d'annuler l'inscription de la portée du signet spécifiée car elle a des signets en attente.</value>
  </data>
  <data name="BookmarkScopeInitialized" xml:space="preserve">
    <value>Le BookmarkScope avec TemporaryId : '{0}' a été initialisé avec l'Id : '{1}'.</value>
  </data>
  <data name="BookmarkScopeNotFound" xml:space="preserve">
    <value>La portée du signet avec l'id '{0}' est introuvable.</value>
  </data>
  <data name="BookmarkScopeNotRegisteredForInitialize" xml:space="preserve">
    <value>Impossible d'initialiser la portée du signet spécifiée car elle n'est pas actuellement inscrite.</value>
  </data>
  <data name="BookmarkScopeNotRegisteredForUnregister" xml:space="preserve">
    <value>Impossible d'annuler l'inscription de la portée du signet spécifiée car elle n'est pas actuellement inscrite.  </value>
  </data>
  <data name="BookmarkScopesRequireKeys" xml:space="preserve">
    <value>Les portées de signet exigent un hôte qui prenne en charge la gestion de clés.  Ce n'est pas le cas de l'hôte que vous utilisez.  Si vous utilisez WorkflowApplication ou WorkflowInvoker, préférez-lui WorkflowServiceHost.</value>
  </data>
  <data name="BookmarkScopeWithIdAlreadyExists" xml:space="preserve">
    <value>Impossible d'initialiser la portée du signet spécifiée avec l'identificateur '{0}' car une portée de signet existe déjà avec cet identificateur.</value>
  </data>
  <data name="BookmarksOnlyResumableWhileIdle" xml:space="preserve">
    <value>TryScheduleBookmarkResumption ne peut être appelé que lorsque le runtime est inactif.</value>
  </data>
  <data name="BufferAllocationFailed" xml:space="preserve">
    <value>Impossible d'allouer une mémoire tampon gérée de {0} octets. La quantité de mémoire disponible est peut-être faible.</value>
  </data>
  <data name="BufferedOutputStreamQuotaExceeded" xml:space="preserve">
    <value>Dépassement du quota de taille de ce flux ({0}).</value>
  </data>
  <data name="BufferedReceiveBehaviorMultipleUse" xml:space="preserve">
    <value>Impossible d'ajouter l'instance BufferedReceiveServiceBehavior au WorkflowServiceHost car elle a déjà été ajoutée à une autre instance WorkflowServiceHost. Créez une nouvelle instance BufferedReceiveServiceBehavior pour chaque WorkflowServiceHost supplémentaire.</value>
  </data>
  <data name="BufferedReceiveBehaviorUsedWithoutProperty" xml:space="preserve">
    <value>Le BufferedReceiveServiceBehavior doit être utilisé avec une définition de workflow qui prend en charge le traitement BufferedReceive. Utilisez WorkflowService.AllowBufferedReceive pour activer le traitement BufferedReceive.</value>
  </data>
  <data name="BufferedReceiveRequiresReceiveContext" xml:space="preserve">
    <value>L'opération portant le nom '{0}' doit être activée pour utiliser le mode ManualAcknowledgement ReceiveContext lorsque le BufferedReceiveServiceBehavior est utilisé.</value>
  </data>
  <data name="BufferIsNotRightSizeForBufferManager" xml:space="preserve">
    <value>Impossible de renvoyer cette mémoire tampon au gestionnaire de tampons car sa taille est incorrecte.</value>
  </data>
  <data name="BufferOutOfOrderMessageNoBookmark" xml:space="preserve">
    <value>Impossible d'effectuer actuellement l'opération '{1}' sur l'instance de service '{0}'. Une autre tentative sera faite lorsque l'instance de service sera prête à traiter cette opération.</value>
  </data>
  <data name="BufferOutOfOrderMessageNoInstance" xml:space="preserve">
    <value>Impossible d'effectuer l'opération '{0}' actuellement. Une autre tentative sera faite lorsque l'instance de service sera prête à traiter cette opération.</value>
  </data>
  <data name="BufferPoolAllocation" xml:space="preserve">
    <value>Le pool est en train d'allouer {0} octets.</value>
  </data>
  <data name="BufferPoolChangeQuota" xml:space="preserve">
    <value>BufferPool de taille {0}, modification du quota par {1}.</value>
  </data>
  <data name="BusyCountTraceFormatString" xml:space="preserve">
    <value>ID d'instance de workflow {0}</value>
  </data>
  <data name="CacheRootMetadataStart" xml:space="preserve">
    <value>CacheRootMetadata a démarré sur l'activité '{0}'</value>
  </data>
  <data name="CacheRootMetadataStop" xml:space="preserve">
    <value>CacheRootMetadata s'est arrêté sur l'activité {0}.</value>
  </data>
  <data name="CacheSettingsLocked" xml:space="preserve">
    <value>Les paramètres du cache sont immuables car l'extension est déjà ajoutée à l'instance de workflow ou à la collection d'extensions hôte.</value>
  </data>
  <data name="CallbackExceptionFromHostAbort" xml:space="preserve">
    <value>L'appel de OnRequestAbort sur le WorkflowInstance '{0}' a levé une exception considérée comme irrécupérable. Consultez l'exception interne pour plus d'informations.</value>
  </data>
  <data name="CallbackExceptionFromHostGetExtension" xml:space="preserve">
    <value>L'appel de OnGetExtension sur le WorkflowInstance '{0}' a levé une exception considérée comme irrécupérable. Consultez l'exception interne pour plus d'informations.</value>
  </data>
  <data name="CancellationHandlerFatalException" xml:space="preserve">
    <value>Une exception non prise en charge a été levée à partir du gestionnaire Cancellation '{0}'. Cancellation peut se trouver dans un état incohérent et le workflow a été annulé.</value>
  </data>
  <data name="CanInduceIdleActivityInArgumentExpression" xml:space="preserve">
    <value>L'argument '{0}' de l'activité '{1}' est lié à une expression qui contient l'activité '{2}'. '{2}' peut entraîner l'inactivité de l'expression lors de l'évaluation. Si les expressions d'argument de l'activité '{1}' modifient l'état partagé, le passage à l'état inactif lors de l'évaluation de l'expression peut produire des valeurs inattendues pour les arguments.</value>
  </data>
  <data name="CanInduceIdleNotSpecified" xml:space="preserve">
    <value>L'activité '{0}' n'est pas valide. Les activités dérivées de NativeActivity qui effectuent des opérations asynchrones en appelant l'une des surcharges CreateBookmark définies sur System.Activities.NativeActivityContext doivent remplacer la propriété CanInduceIdle et retourner True.</value>
  </data>
  <data name="CannotAcquireLockDefault" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue car l'instance est verrouillée par un propriétaire d'instance différent. Généralement, cette erreur se produit car l'instance est chargée par un hôte différent.</value>
  </data>
  <data name="CannotAcquireLockSpecific" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue, car l'instance '{0}' est verrouillée par un propriétaire d'instance différent. Généralement, cette erreur se produit car l'instance est chargée par un hôte différent.</value>
  </data>
  <data name="CannotAcquireLockSpecificWithOwner" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue, car l'instance '{0}' est verrouillée par un propriétaire d'instance différent. Généralement, cette erreur se produit, car l'instance est chargée par un hôte différent. L'ID du propriétaire de l'instance du propriétaire ou de l'hôte avec un verrou sur l'instance est '{1}'.</value>
  </data>
  <data name="CannotAddHandlesUpdateError" xml:space="preserve">
    <value>L'activité a ajouté une nouvelle variable d'un type dérivé de Handle.</value>
  </data>
  <data name="CannotAddOrRemoveWithChildren" xml:space="preserve">
    <value>Une activité ne peut pas ajouter ou supprimer des propriétés d'exécution du workflow lorsque des enfants sont en cours d'exécution.</value>
  </data>
  <data name="CannotCallAbortInstanceFromWorkflowThread" xml:space="preserve">
    <value>AbortInstance ne peut pas être appelé à partir du thread de workflow, car cela provoquerait un état incohérent.</value>
  </data>
  <data name="CannotChangeAbortInstanceFlagAfterPropertyRegistration" xml:space="preserve">
    <value>La valeur de l'indicateur AbortInstanceOnTransactionFailure ne peut pas être modifiée une fois le IPropertyRegistrationCallback.Register du RuntimeTransactionHandle correspondant exécuté.</value>
  </data>
  <data name="CannotChangeMatchesInImplementation" xml:space="preserve">
    <value>Impossible d'ajouter de nouvelles correspondances au sein de l'implémentation privée du workflow pour lequel la table de mise à jour est en train d'être générée.</value>
  </data>
  <data name="CannotCompleteRuntimeOwnedTransaction" xml:space="preserve">
    <value>La transaction actuelle a été configurée par le runtime et ne peut être exécutée que par le runtime. Une transaction configurée par le runtime est le résultat d'un appel d'une API invoke sur WorkflowInvoker lorsqu'une transaction ambiante existe.</value>
  </data>
  <data name="CannotCompleteWithKeys" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé la fin d'une instance avec des clés actives. Toutes les clés associées à une instance doivent être terminées avant que l'instance puisse se terminer.</value>
  </data>
  <data name="CannotConvertObject" xml:space="preserve">
    <value>Impossible de convertir l'objet '{0}' en type '{1}'.</value>
  </data>
  <data name="CannotCreateContextWithNullId" xml:space="preserve">
    <value>L'argument instanceId de InstanceStore.CreateInstanceHandle ne peut pas indiquer un ID composé que de zéros, tel que Guid.Empty.</value>
  </data>
  <data name="CannotCreateMessageFault" xml:space="preserve">
    <value>Création de MessageFault impossible.</value>
  </data>
  <data name="CannotCreateOwnerWithoutIdentity" xml:space="preserve">
    <value>Impossible de créer un propriétaire d'instance par défaut sans WorkflowIdentity. Pour créer un propriétaire, spécifiez une identité de définition ou sélectionnez WorkflowIdentityFilter.Any.</value>
  </data>
  <data name="CanNotDefineNullForAPromotion" xml:space="preserve">
    <value>La collection de la promotion {0} pour le nom de promotion {1} contient une valeur Null.</value>
  </data>
  <data name="CannotDereferenceNull" xml:space="preserve">
    <value>Impossible de créer un L-value à partir de l'expression donnée avec la propriété '{0}' car l'objet cible est Null.</value>
  </data>
  <data name="CannotEnlistMultipleTransactions" xml:space="preserve">
    <value>Une transaction est déjà inscrite dans le workflow. Une seule transaction peut être inscrite à la fois.</value>
  </data>
  <data name="CanNotFindSymbolResolverInWorkflowInstanceExtensions" xml:space="preserve">
    <value>Impossible de trouver le programme de résolution de symbole dans une collection d'extensions d'instance de workflow.</value>
  </data>
  <data name="CannotGenerateSchemaForXmlSerializable" xml:space="preserve">
    <value>'{0}' correspond à des données internes de runtime et ne prend pas en charge la génération de schémas.</value>
  </data>
  <data name="CannotGetValueOfOutArgument" xml:space="preserve">
    <value>Impossible d'obtenir la valeur pour un argument sortie seule.</value>
  </data>
  <data name="CannotInvokeBindingFromNonBinding" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a tenté d'exécuter une commande susceptible d'acquérir un verrou alors qu'elle traitait une commande ne pouvant pas acquérir de verrou. Cette exception peut se produire lorsque InstancePersistenceContext.Execute ou InstancePersistenceContext.BeginExecute est appelé avec une commande qui retourne la valeur True à partir de InstancePersistenceCommand.AutomaticallyAcquiringLock alors qu'il traite une commande qui retourne la valeur false. Utilisez un fournisseur de persistance qui n'agit pas ainsi ou remplacez AutomaticallyAcquiringLock dans l'une des commandes pour qu'elle retourne la valeur correcte.</value>
  </data>
  <data name="CannotInvokeOpenedActivity" xml:space="preserve">
    <value>Cette activité ne peut pas être appelée, car elle n'a pas été ouverte par une surcharge de Invoke qui prend un IDictionary de chaîne et d'objet.</value>
  </data>
  <data name="CannotInvokeTransactionalFromNonTransactional" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a tenté d'exécuter une commande transactionnelle alors qu'elle traitait une commande non transactionnelle. Cette exception peut se produire lorsque InstancePersistenceContext.Execute ou InstancePersistenceContext.BeginExecute est appelé avec une commande qui retourne la valeur false à partir de InstancePersistenceCommand.IsTransactionEnlistmentOptional alors qu'il traite une commande qui retourne la valeur True. Utilisez un fournisseur de persistance qui n'agit pas ainsi ou remplacez IsTransactionEnlistmentOptional dans l'une des commandes pour qu'elle retourne la valeur correcte.</value>
  </data>
  <data name="CannotModifyCatchAfterOpen" xml:space="preserve">
    <value>Ce Catch a déjà été ouvert et ne peut pas être modifié. Les Catch ne peuvent être modifiés qu'au moment du design.</value>
  </data>
  <data name="CannotMoveChildAcrossDifferentFlowNodeTypes" xml:space="preserve">
    <value>L'organigramme ne prend pas en charge la mise à jour dynamique lorsque l'activité d'un enfant est déplacée d'un type FlowNode à un autre type FlowNode.</value>
  </data>
  <data name="CannotNestTransactedReceiveScopeWhenAmbientHandleIsSuppressed" xml:space="preserve">
    <value>La transaction runtime est actuellement supprimée. L'exécution de l'activité TransactedReceiveScope '{0}' lorsque la transaction runtime est supprimée n'est pas prise en charge.</value>
  </data>
  <data name="CannotNestTransactionScopeWhenAmbientHandleIsSuppressed" xml:space="preserve">
    <value>La transaction runtime est actuellement supprimée. L'exécution de l'activité TransactedScope '{0}' lorsque la transaction runtime est supprimée, n'est pas prise en charge.</value>
  </data>
  <data name="CannotPerformOperationFromHandlerThread" xml:space="preserve">
    <value>Les opérations WorkflowApplication ne peuvent pas être exécutées au sein de gestionnaires d'événements.</value>
  </data>
  <data name="CannotPerformOperationOnHandle" xml:space="preserve">
    <value>L'opération ne peut pas être exécutée sur des de sous-types Handle.</value>
  </data>
  <data name="CannotPersistInsideIsolation" xml:space="preserve">
    <value>Les activités Persist ne peuvent pas être contenues dans des blocs d'isolation.</value>
  </data>
  <data name="CannotPersistInsideNoPersist" xml:space="preserve">
    <value>Les activités Persist ne peuvent pas être contenues au sein de blocs sans persistance.</value>
  </data>
  <data name="CannotPersistWhileDetached" xml:space="preserve">
    <value>L'instance ne peut pas être persistante, car elle n'est pas propriétaire du verrou. Un appel précédent à Persist avec une valeur de déverrouillage égale à True est responsable de la libération du verrou.</value>
  </data>
  <data name="CannotPromoteAsSqlVariant" xml:space="preserve">
    <value>Le type de données '{0}' de la propriété promue '{1}' n'est pas pris en charge par SQL. Remplacez-le par un type de données pris en charge ou promouvez la propriété en tant que valeur binaire.</value>
  </data>
  <data name="CannotPromoteXNameTwiceInPromotion" xml:space="preserve">
    <value>Le XName '{0}' est promu plusieurs fois dans la promotion '{1}.' Les XNames en double ne sont pas autorisés dans la même promotion.</value>
  </data>
  <data name="CannotPropagateExceptionWhileCanceling" xml:space="preserve">
    <value>L'activité '{0}' avec l'ID {1} a levé ou propagé une exception lors de son annulation.</value>
  </data>
  <data name="CannotRemoveExecutingActivityUpdateError" xml:space="preserve">
    <value>Impossible de supprimer l'activité '{0}: {1}' car elle est en cours d'exécution.</value>
  </data>
  <data name="CannotReplaceTransaction" xml:space="preserve">
    <value>La transaction ambiante (System.Transactions.Transaction.Current) ne correspond pas à la transaction utilisée pour cet épisode d'exécution. Une seule transaction peut être utilisée pendant l'intégralité d'un épisode d'exécution.</value>
  </data>
  <data name="CannotResetPropertyInDataContext" xml:space="preserve">
    <value>La propriété dans WorkflowDataContext ne peut pas être réinitialisée.</value>
  </data>
  <data name="CannotSaveOriginalValueForActivity" xml:space="preserve">
    <value>Une activité peut uniquement enregistrer les valeurs d'origine pour ses enfants et ses gestionnaires délégués publics ou importés.</value>
  </data>
  <data name="CannotSaveOriginalValueForNewActivity" xml:space="preserve">
    <value>Impossible d'enregistrer une valeur d'origine pour l'activité '{0}' car elle n'est pas présente dans la définition de workflow d'origine.</value>
  </data>
  <data name="CannotSaveOriginalValuesForReferencedChildren" xml:space="preserve">
    <value>Cette activité ne gère pas correctement les mises à jour lorsqu'elle se trouve dans une implémentation d'activité. Elle a tenté d'enregistrer des valeurs d'origine pour des références à des enfants importés.</value>
  </data>
  <data name="CannotScheduleChildrenWhileEnteringIsolation" xml:space="preserve">
    <value>Les activités enfants ne peuvent pas être planifiées lors de la configuration d'un bloc d'isolation. Attendez l'appel de OnEntered BookmarkCallback avant de planifier les enfants.</value>
  </data>
  <data name="CannotSerializeExpression" xml:space="preserve">
    <value>Impossible de sérialiser une expression de type "{0}".</value>
  </data>
  <data name="CannotSerializeVariableExpression" xml:space="preserve">
    <value>Impossible de sérialiser l'expression, car les sous-expressions d'accès aux variables étaient incorrectes ou non reconnues.</value>
  </data>
  <data name="CannotSetRuntimeTransactionInNoPersist" xml:space="preserve">
    <value>Le runtime ne peut pas être configuré avec une transaction par une activité qui est contenue au sein d'une portée sans persistance. Une activité ancêtre a interdit la persistance.</value>
  </data>
  <data name="CannotSetupIsolationInsideIsolation" xml:space="preserve">
    <value>Le bloc d'isolation ne peut pas être installé, car il serait contenu dans un autre bloc d'isolation. Les blocs d'isolation ne peuvent pas être imbriqués.</value>
  </data>
  <data name="CannotSetupIsolationInsideNoPersist" xml:space="preserve">
    <value>Le bloc d'isolation ne peut pas être installé, car il serait contenu dans un bloc sans persistance.</value>
  </data>
  <data name="CannotSetupIsolationWithChildren" xml:space="preserve">
    <value>Un bloc d'isolation ne peut pas être installé, lorsque des enfants sont en cours d'exécution.</value>
  </data>
  <data name="CannotSetValueOfInArgument" xml:space="preserve">
    <value>Impossible d'assigner des valeurs à In Arguments.</value>
  </data>
  <data name="CannotSetValueToLocation" xml:space="preserve">
    <value>Impossible de définir une valeur de type '{0}' à l'emplacement nommé '{1}', car il s'agit d'un emplacement de type '{2}'.</value>
  </data>
  <data name="CannotSpecifyBothConnectionStringAndName" xml:space="preserve">
    <value>Impossible de spécifier à la fois la propriété connectionString et la propriété connectionStringName.</value>
  </data>
  <data name="CannotSuppressAlreadyRegisteredHandle" xml:space="preserve">
    <value>Impossible de changer la valeur de la propriété SuppressTransaction sur un RuntimeTransactionHandle déjà inscrit.</value>
  </data>
  <data name="CannotUnregisterDefaultBookmarkScope" xml:space="preserve">
    <value>Impossible de supprimer la portée du signet car il s'agit de la portée du signet par défaut de l'instance.</value>
  </data>
  <data name="CannotUnregisterNullBookmarkScope" xml:space="preserve">
    <value>Impossible d'annuler l'inscription d'une portée de signet Null.</value>
  </data>
  <data name="CannotUpdateEnvironmentInTheMiddleOfResolvingArguments" xml:space="preserve">
    <value>Les arguments et les variables ne peuvent pas être ajoutés, supprimés ou réorganisés lorsque l'instance est en cours de résolution des arguments.</value>
  </data>
  <data name="CannotUpdateEnvironmentInTheMiddleOfResolvingVariables" xml:space="preserve">
    <value>Les arguments et les variables ne peuvent pas être ajoutés, supprimés ou réorganisés lorsque l'instance est en cours de résolution des variables.</value>
  </data>
  <data name="CannotUpdateLoadedInstance" xml:space="preserve">
    <value>Impossible de mettre à jour le WorkflowInstance '{0}' car il est déjà chargé. Si possible, suspendez l'instance avant de la mettre à jour.</value>
  </data>
  <data name="CannotUseAddServiceEndpointOverloadForWorkflowServices" xml:space="preserve">
    <value>WorkflowServiceHost ne prend pas en charge l'ajout de points de terminaison d'application à l'aide de la surcharge AddServiceEndpoint(ServiceEndpoint endpoint). Utilisez l'une des surcharges 'XName serviceContract' ou 'string implementedContract' pour ajouter des points de terminaison d'application à WorkflowServiceHost.</value>
  </data>
  <data name="CannotUseInputsWithLoad" xml:space="preserve">
    <value>Impossible d'utiliser des entrées de workflow avec Load ou LoadRunnableInstance, car elles sont uniquement fournies aux nouvelles instances.</value>
  </data>
  <data name="CannotValidateNullObject" xml:space="preserve">
    <value>L'argument ToValidate du {0} nommé '{1}' a été résolu en une valeur Null. Un objet non Null à valider doit être fourni.</value>
  </data>
  <data name="CannotWaitForIdleSynchronously" xml:space="preserve">
    <value>L'opération a échoué, car elle a été appelée à partir d'un gestionnaire alors que le workflow n'était pas inactif. Le workflow doit être inactif afin que l'opération puisse avoir lieu et le workflow ne peut pas s'exécuter dans un gestionnaire d'événements.</value>
  </data>
  <data name="CanOnlyAbortDirectChildren" xml:space="preserve">
    <value>Une activité ne peut abandonner que ses enfants directs.</value>
  </data>
  <data name="CanOnlyCancelDirectChildren" xml:space="preserve">
    <value>Une activité ne peut annuler que ses enfants directs.</value>
  </data>
  <data name="CanOnlyGetOwnedArguments" xml:space="preserve">
    <value>Une activité ne peut obtenir que l'emplacement des arguments dont elle est propriétaire. L'activité '{0}' essaie d'obtenir l'emplacement de l'argument '{1}' dont l'activité '{2}' est propriétaire.</value>
  </data>
  <data name="CanOnlyScheduleDirectChildren" xml:space="preserve">
    <value>Une activité ne peut planifier que ses enfants directs. L'activité '{0}' essaie de planifier '{1}' qui est un enfant de l'activité '{2}'.</value>
  </data>
  <data name="CantFindTimerExtension" xml:space="preserve">
    <value>TimerExtension doit être ajouté à la collection d'extensions.</value>
  </data>
  <data name="CatchOrFinallyExpected" xml:space="preserve">
    <value>Catch ou Finally attendu pour l'activité TryCatch '{0}'.</value>
  </data>
  <data name="ChangeConditionalTransitionToUnconditionalBlockDU" xml:space="preserve">
    <value>StateMachine ne prend pas en charge la mise à jour dynamique si une transition conditionnelle devient inconditionnelle à la suite de la mise à jour.</value>
  </data>
  <data name="ChangeTransitionTypeDuringTransitioningBlockDU" xml:space="preserve">
    <value>StateMachine ne prend pas en charge la mise à jour dynamique si l'état est en cours de transition et que la transition actuelle est en passe de devenir conditionnelle.</value>
  </data>
  <data name="ChangingTriggerOrUseOriginalConditionActionBlockDU" xml:space="preserve">
    <value>StateMachine ne prend pas en charge la mise à jour dynamique si le déclencheur d'une transition existante est modifié ou si l'activité Condition ou Action est réassignée à une nouvelle transition.</value>
  </data>
  <data name="CleanupInProgress" xml:space="preserve">
    <value>SqlWorkflowInstanceStore ne peut pas traiter la commande, car le nettoyage de magasin est en cours. Patientez le temps que le nettoyage finisse et recommencez.</value>
  </data>
  <data name="CollectionActivityRequiresCollection" xml:space="preserve">
    <value>La propriété 'Collection' de '{0}' n'est pas initialisée.</value>
  </data>
  <data name="ColumnNumberTooLarge" xml:space="preserve">
    <value>Le nombre de colonnes spécifié pour l'activité {0} est trop important pour être pris en charge en mode de confiance partielle</value>
  </data>
  <data name="CommandExecutionCannotOverlap" xml:space="preserve">
    <value>Une seule commande peut être exécutée à la fois pour un InstanceHandle. N'appelez pas la méthode Execute ou BeginExecute sur InstanceStore tant que la précédente commande qui s'exécute pour ce InstanceHandle n'est pas terminée.</value>
  </data>
  <data name="CompensableActivityAlreadyConfirmedOrCompensated" xml:space="preserve">
    <value>Le CompensableActivity spécifié par 'Target' CompensationToken a déjà été confirmé ou compensé.</value>
  </data>
  <data name="CompensableActivityInsideTransactedReceiveScope" xml:space="preserve">
    <value>Impossible d'imbriquer CompensableActivity dans un TransactedReceiveScope.</value>
  </data>
  <data name="CompensableActivityInsideTransactionScopeActivity" xml:space="preserve">
    <value>CompensableActivity ne peut pas être imbriqué dans une activité TransactionScope.</value>
  </data>
  <data name="CompensateWithNoTargetConstraint" xml:space="preserve">
    <value>L'utilisation de Compensate sans Target spécifié n'est possible qu'utilisé dans des gestionnaires Compensation, Confirmation ou Annulation.</value>
  </data>
  <data name="CompensateWithoutCompensableActivity" xml:space="preserve">
    <value>L'activité Compensate '{0}' ne peut être utilisée que si CompensableActivity au sein du workflow a déjà été exécuté.</value>
  </data>
  <data name="CompensationHandlerFatalException" xml:space="preserve">
    <value>Une exception non prise en charge a été levée à partir du gestionnaire Compensation de '{0}'. Compensation peut se trouver dans un état incohérent et le workflow a été annulé.</value>
  </data>
  <data name="CompensationState" xml:space="preserve">
    <value>CompensableActivity '{0}' est dans l'état '{1}'.</value>
  </data>
  <data name="CompiledExpressionIdNotFound" xml:space="preserve">
    <value>Impossible de localiser l'ID d'expression de '{0}'. Assurez-vous que la définition actuelle a bien été compilée.</value>
  </data>
  <data name="CompiledExpressionsActivityException" xml:space="preserve">
    <value>TextExpressionCompiler : une exception de type '{0}' a été levée lors du traitement de l'activité '{1}': '{2}'.</value>
  </data>
  <data name="CompiledExpressionsCacheMetadataException" xml:space="preserve">
    <value>CacheMetadata pour l'activité '{0}' a levé une exception '{1}'.</value>
  </data>
  <data name="CompiledExpressionsDuplicateName" xml:space="preserve">
    <value>'{0}' est une référence de variable ambiguë. Renommez l'identificateur.</value>
  </data>
  <data name="CompiledExpressionsIgnoringInvalidIdentifierVariable" xml:space="preserve">
    <value>TextExpressionCompiler : variable '{0}' ignorée. L'identificateur n'est pas valide pour le langage actuel.</value>
  </data>
  <data name="CompiledExpressionsIgnoringUnnamedVariable" xml:space="preserve">
    <value>TextExpressionCompiler : variable sans nom ignorée.</value>
  </data>
  <data name="CompiledExpressionsNoCompiledRoot" xml:space="preserve">
    <value>Impossible de localiser l'instance d'activité correspondant à l'activité '{0}'. Recompilez le workflow.</value>
  </data>
  <data name="CompiledLocationNoDefaultConstructor" xml:space="preserve">
    <value>Les expressions compilées nécessitent un constructeur par défaut dans leur racine locale. Ajoutez un constructeur par défaut au type '{0}'.</value>
  </data>
  <data name="CompiledLocationReferenceGetLocation" xml:space="preserve">
    <value>CompiledLocationReference ne doit jamais être utilisé pour accéder à un emplacement.</value>
  </data>
  <data name="CompilerError" xml:space="preserve">
    <value>Erreurs du compilateur rencontrées.</value>
  </data>
  <data name="CompilerErrorSpecificExpression" xml:space="preserve">
    <value>Erreurs du compilateur rencontrées lors du traitement de l'expression "{0}".{1}</value>
  </data>
  <data name="CompileVbExpressionStart" xml:space="preserve">
    <value>Compilation de l'expression Visual Basic '{0}'</value>
  </data>
  <data name="CompileVbExpressionStop" xml:space="preserve">
    <value>Compilation de l'expression Visual Basic terminée.</value>
  </data>
  <data name="CompleteBookmarkWorkItem" xml:space="preserve">
    <value>BookmarkWorkItem est terminé pour l'activité '{0}', DisplayName : '{1}', InstanceID : '{2}'. BookmarkName : {3}, BookmarkScope : {4}.</value>
  </data>
  <data name="CompleteCancelActivityWorkItem" xml:space="preserve">
    <value>CancelActivityWorkItem est terminé pour l'activité '{0}', DisplayName : '{1}', InstanceID : '{2}'.</value>
  </data>
  <data name="CompleteCompletionWorkItem" xml:space="preserve">
    <value>CompletionWorkItem est terminé pour l'activité parent '{0}', DisplayName : '{1}', InstanceID : '{2}'. Activité '{3}' terminée, DisplayName : '{4}', InstanceID : '{5}'.</value>
  </data>
  <data name="CompletedMustNotHaveAssociatedKeys" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé le chargement d'une instance avec InstanceState.Completed qui a des clés associées qui ne sont pas terminées.</value>
  </data>
  <data name="CompleteExecuteActivityWorkItem" xml:space="preserve">
    <value>ExecuteActivityWorkItem est terminé pour l'activité '{0}', DisplayName : '{1}', InstanceID : '{2}'.</value>
  </data>
  <data name="CompleteFaultWorkItem" xml:space="preserve">
    <value>FaultWorkItem est terminé pour l'activité '{0}', DisplayName : '{1}', InstanceID : '{2}'. L'exception a été propagée à partir de l'activité '{3}', DisplayName : '{4}', InstanceID : '{5}'.</value>
  </data>
  <data name="CompleteRuntimeWorkItem" xml:space="preserve">
    <value>Un élément de travail runtime est terminé pour l'activité '{0}', DisplayName : '{1}', InstanceID : '{2}'.</value>
  </data>
  <data name="CompleteTransactionContextWorkItem" xml:space="preserve">
    <value>TransactionContextWorkItem est terminé pour l'activité '{0}', DisplayName : '{1}', InstanceID : '{2}'.</value>
  </data>
  <data name="CompletionConditionSetButNoBody" xml:space="preserve">
    <value>Dans ParallelForEach, la propriété CompletionCondition ne doit pas avoir la valeur Null, mais la propriété Body doit avoir la valeur Null. Définissez la propriété Body de ParallelForEach '{0}' à une activité Sequence vide.</value>
  </data>
  <data name="ConfirmationHandlerFatalException" xml:space="preserve">
    <value>Une exception non prise en charge a été levée à partir du gestionnaire Confirmation de '{0}'. Confirmation peut se trouver dans un état incohérent et le workflow a été annulé.</value>
  </data>
  <data name="ConfirmWithNoTargetConstraint" xml:space="preserve">
    <value>L'utilisation de Confirm sans Target spécifié n'est possible qu'utilisé dans des gestionnaires Compensation, Confirmation ou Annulation.</value>
  </data>
  <data name="ConfirmWithoutCompensableActivity" xml:space="preserve">
    <value>L'activité Confirm '{0}' ne peut être utilisée que si CompensableActivity au sein du workflow a déjà été exécuté.</value>
  </data>
  <data name="ConflictingValueName" xml:space="preserve">
    <value>Le nom de la propriété '{0}' (un XName) pour une valeur fournie à DurableInstanceManager.AddInstanceOwnerValues est en conflit avec le nom d'une valeur déjà ajoutée. Vérifiez que les noms de toutes les valeurs passées à AddInstanceOwnerValues sont uniques. Cette erreur peut être due à des comportements de services configurés en conflit.</value>
  </data>
  <data name="ConnectionStringNameWrong" xml:space="preserve">
    <value>Impossible de trouver une chaîne de connexion pour le nom de connexion '{0}'.</value>
  </data>
  <data name="ConstructorInfoNotFound" xml:space="preserve">
    <value>Les infos du constructeur correspondant sont introuvables dans le type de '{0}'.</value>
  </data>
  <data name="ConstVariableCannotBeSet" xml:space="preserve">
    <value>Cet emplacement est marqué comme const, sa valeur ne peut donc pas être modifiée.</value>
  </data>
  <data name="ContextAlreadyBoundToInstance" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a appelé BindInstance pour définir l'ID d'instance d'un InstanceHandle qui est déjà lié à une instance. Un InstanceHandle ne peut être lié qu'à une seule instance pendant sa durée de vie.</value>
  </data>
  <data name="ContextAlreadyBoundToLock" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a appelé BindLock pour définir la version d'instance verrouillée d'un InstanceHandle qui est déjà lié à un verrou. Un InstanceHandle ne peut être lié qu'à un seul verrou pendant sa durée de vie.</value>
  </data>
  <data name="ContextAlreadyBoundToOwner" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a appelé BindOwner pour définir le propriétaire d'un InstanceHandle qui est déjà lié à un propriétaire. Un InstanceHandle ne peut être lié qu'à un seul propriétaire pendant sa durée de vie.</value>
  </data>
  <data name="ContextMismatchInContextAndCallBackContext" xml:space="preserve">
    <value>CorrelationCallbackContext et CorrelationContext sont définis, mais le contexte ne correspond pas.</value>
  </data>
  <data name="ContextMustBeBoundToInstance" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a appelé BindAcquiredLock, BindReclaimedLock, BeginBindReclaimedLock ou CreateBindReclaimedLockException pour lier InstanceHandle à une version de verrou d'instance, mais InstanceHandle n'est pas lié à une instance. Un InstanceHandle doit d'abord être lié à une instance afin d'être lié à un verrou.</value>
  </data>
  <data name="ContextMustBeBoundToOwner" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a appelé BindAcquiredLock, BindReclaimedLock, BeginBindReclaimedLock ou CreateBindReclaimedLockException pour lier InstanceHandle à une version de verrou d'instance, mais InstanceHandle n'est pas lié à un propriétaire. Un InstanceHandle doit d'abord être lié à un propriétaire afin d'être lié à un verrou.</value>
  </data>
  <data name="ContextNotFromThisStore" xml:space="preserve">
    <value>L'argument handle de InstanceStore.Execute ou InstanceStore.BeginExecute doit avoir été créé par un appel à CreateInstanceHandle sur la même instance InstanceStore.</value>
  </data>
  <data name="ContractInferenceValidationForTransactionFlowBehavior" xml:space="preserve">
    <value>Le comportement TransactionFlow de l'opération doit être défini à Allowed.</value>
  </data>
  <data name="ContractNotFoundInAddServiceEndpoint" xml:space="preserve">
    <value>Impossible d'ajouter un point de terminaison car ContractDescription avec Name='{0}' et Namespace='{1}' sont introuvables.</value>
  </data>
  <data name="ControllerInvalidBeforeInitialize" xml:space="preserve">
    <value>WorkflowInstance.Controller n'est valide qu'après l'appel de Initialize.</value>
  </data>
  <data name="ConvertVariableToValueExpressionFailed" xml:space="preserve">
    <value>Impossible de convertir Variable de type '{0}' en Activity de type '{1}'.</value>
  </data>
  <data name="CopyToIndexOutOfRange" xml:space="preserve">
    <value>L'index du tableau doit être supérieur à 0.</value>
  </data>
  <data name="CopyToNotEnoughSpaceInArray" xml:space="preserve">
    <value>Le tableau fourni n'a pas la capacité de détenir des valeurs.</value>
  </data>
  <data name="CopyToRankMustBeOne" xml:space="preserve">
    <value>Le tableau fourni a plusieurs dimensions. Le tableau doit avoir un rang un pour être utilisé avec CopyTo.</value>
  </data>
  <data name="CorrelatedContextRequiredForAnonymousSend" xml:space="preserve">
    <value>Une activité Send doit être configurée avec un point de terminaison ou corrélée à un contexte établi antérieurement avec CorrelatesWith.</value>
  </data>
  <data name="CorrelationHandleInUse" xml:space="preserve">
    <value>CorrelationHandle est déjà utilisé avec BookmarkScope '{0}', il ne peut pas être utilisé avec BookmarkScope '{1}'.</value>
  </data>
  <data name="CorrelationResponseContextShouldNotBeNull" xml:space="preserve">
    <value>Le contexte CorrelationResponse ne doit pas être Null. Il se peut que le gestionnaire de corrélation ne soit pas correctement configuré.</value>
  </data>
  <data name="CouldNotResolveNamespacePrefix" xml:space="preserve">
    <value>Impossible de résoudre le préfixe de l'espace de noms '{0}'.</value>
  </data>
  <data name="CreateBookmark" xml:space="preserve">
    <value>Un signet a été créé pour l'activité '{0}', DisplayName : '{1}', InstanceID : '{2}'. BookmarkName : {3}, BookmarkScope : {4}.</value>
  </data>
  <data name="CreateBookmarkScope" xml:space="preserve">
    <value>Un BookmarkScope a été créé : {0}.</value>
  </data>
  <data name="CreateBookmarkScopeFailed" xml:space="preserve">
    <value>Ce BookmarkScopeHandle est déjà associé à un BookmarkScope.</value>
  </data>
  <data name="CreateWorkflowServiceHostStart" xml:space="preserve">
    <value>Début de CreateWorkflowServiceHost</value>
  </data>
  <data name="CreateWorkflowServiceHostStop" xml:space="preserve">
    <value>Arrêt de CreateWorkflowServiceHost Stop</value>
  </data>
  <data name="CSharpExpressionsMustBeCompiled" xml:space="preserve">
    <value>Les expressions CSharp doivent être compilées.</value>
  </data>
  <data name="CurrentOperationCannotCreateInstance" xml:space="preserve">
    <value>Aucun contexte n'est attaché au message entrant pour le service et l'opération actuelle n'est pas marquée avec "CanCreateInstance = True". Afin de communiquer avec ce service, vérifiez que la liaison entrant prend en charge le protocole de contexte et qu'un contexte valide est initialisé.</value>
  </data>
  <data name="DanglingReceive" xml:space="preserve">
    <value>Il manque un Receive au workflow pour l'associer à un SendReply. Vérifiez que chaque activité SendReply est associée à une activité Receive figurant dans le workflow.</value>
  </data>
  <data name="DatabaseUpgradeRequiredForCommand" xml:space="preserve">
    <value>La version de la base de données de SqlWorkflowInstanceStore est '{0}'. InstancePersistenceCommand '{1}' ne peut pas être exécuté avec cette version de base de données. Mettez la base de données à niveau vers '{2}'.</value>
  </data>
  <data name="DebugInfoCannotEvaluateExpression" xml:space="preserve">
    <value>Impossible d'évaluer '{0}' dans le contexte actuel.</value>
  </data>
  <data name="DebugInfoExceptionCaught" xml:space="preserve">
    <value>Exception interceptée lors de l'évaluation de {0} : {1}.</value>
  </data>
  <data name="DebugInfoNotSkipArgumentResolution" xml:space="preserve">
    <value>*** la valeur n'est pas SkipArgumentResolution ***</value>
  </data>
  <data name="DebugInfoTryGetValueFailed" xml:space="preserve">
    <value>*** échec de TryGetValue ***</value>
  </data>
  <data name="DebugInstrumentationFailed" xml:space="preserve">
    <value>Échec de l'instrumentation pour le débogueur. Raison : {0}.</value>
  </data>
  <data name="DebugSymbolChecksumValueInvalid" xml:space="preserve">
    <value>La somme de contrôle spécifiée pour un symbole de débogage n'est pas valide en mode de confiance partielle</value>
  </data>
  <data name="DefaultAbortReason" xml:space="preserve">
    <value>Le workflow a été abandonné.</value>
  </data>
  <data name="DefaultCancelationRequiresCancelHasBeenRequested" xml:space="preserve">
    <value>La logique d'annulation par défaut requiert que HasCancelBeenRequested ait la valeur True. La méthode Cancel de NativeActivity ne doit être appelée que par le runtime.</value>
  </data>
  <data name="DefaultCreateOnlyReason" xml:space="preserve">
    <value>Le workflow a été créé avec WorkflowCreationContext.CreateOnly ayant la valeur True.</value>
  </data>
  <data name="DefaultInvalidWorkflowExceptionMessage" xml:space="preserve">
    <value>La structure de la définition du workflow n'est pas valide. Utilisez ActivityValidationServices pour afficher toutes les violations.</value>
  </data>
  <data name="DefaultSuspendReason" xml:space="preserve">
    <value>Le workflow a été suspendu via le point de terminaison de contrôle.</value>
  </data>
  <data name="DefaultTerminationReason" xml:space="preserve">
    <value>Il a été demandé au workflow de se terminer.</value>
  </data>
  <data name="DefaultWorkflowApplicationExceptionMessage" xml:space="preserve">
    <value>Impossible d'effectuer l'opération, car elle n'était pas autorisée par l'état actuel du WorkflowApplication.</value>
  </data>
  <data name="DelegateArgumentAlreadyInUseOnActivity" xml:space="preserve">
    <value>Impossible d'utiliser DelegateArgument '{0}' sur l'activité '{1}', car il est déjà utilisé par l'activité '{2}'.</value>
  </data>
  <data name="DelegateArgumentChangeBlockDU" xml:space="preserve">
    <value>Cette activité est le Gestionnaire d'un ActivityDelegate dont les arguments ont été modifiés.</value>
  </data>
  <data name="DelegateArgumentDoesNotExist" xml:space="preserve">
    <value>DelegateArgument '{0}' n'existe pas dans cet environnement.</value>
  </data>
  <data name="DelegateArgumentMustBeReferenced" xml:space="preserve">
    <value>DelegateArgument '{0}' doit être inclus dans un ActivityDelegate de l'activité avant d'être utilisé.</value>
  </data>
  <data name="DelegateArgumentMustBeSet" xml:space="preserve">
    <value>DelegateArgument doit être défini avant que CacheMetadata soit appelé.</value>
  </data>
  <data name="DelegateArgumentNotVisible" xml:space="preserve">
    <value>L'objet DelegateArgument ('{0}') référencé n'est pas visible dans cette portée.</value>
  </data>
  <data name="DelegateArgumentTypeInvalid" xml:space="preserve">
    <value>Impossible d'utiliser DelegateArgument '{0}' dans une expression de type '{1}', car il est de type '{2}' qui n'est pas compatible.</value>
  </data>
  <data name="DelegateHandlersCannotBeScheduledDirectly" xml:space="preserve">
    <value>L'activité '{0}' a essayé de planifier directement l'activité '{1}' du gestionnaire ActivityDelegate. Les gestionnaires ActivityDelegate ne peuvent pas être planifiés directement. ActivityDelegate doit être lui-même planifié pour s'exécuter.</value>
  </data>
  <data name="DelegateInArgumentTypeMismatch" xml:space="preserve">
    <value>Le type de l'argument fourni pour l'entrée de délégué nommée '{0}' n'était pas valide. L'entrée de délégué est de type '{1}' alors que l'argument est de type '{2}'. Le type de l'argument doit être converti en celui de l'entrée de délégué.</value>
  </data>
  <data name="DelegateOutArgumentTypeMismatch" xml:space="preserve">
    <value>Le type de l'argument fourni pour la sortie de délégué nommée '{0}' n'était pas valide. La sortie de délégué est de type '{1}' alors que l'argument est de type '{2}'. Le type de la sortie de délégué doit être converti en celui de l'argument.</value>
  </data>
  <data name="DelegateParameterCannotBeModifiedAfterOpen" xml:space="preserve">
    <value>ActivityDelegateParameter '{0}' ne peut pas être modifié. L'ActivityDelegate qui l'utilise a été verrouillé. Un ActivityDelegate est verrouillé lorsque Invoke est appelé sur le WorkflowElement propriétaire ou lorsqu'un WorkflowInstance est créé.</value>
  </data>
  <data name="DelegateParameterDirectionalityMismatch" xml:space="preserve">
    <value>La direction du paramètre délégué de l'activité '{0}' est dans le dictionnaire DelegateParameters est '{1}'. La direction attendue est '{2}'.</value>
  </data>
  <data name="DictionaryIsReadOnly" xml:space="preserve">
    <value>Ce dictionnaire est en lecture seule et ne peut pas être modifié.</value>
  </data>
  <data name="DifferentContractsSameConfigName" xml:space="preserve">
    <value>Deux contrats différents ont le même ConfigurationName.</value>
  </data>
  <data name="DifferentWorkflowServiceNameNotSupported" xml:space="preserve">
    <value>Le nom {0} de WorkflowService des versions supplémentaires ne correspond pas au nom {1} du WorkflowService par défaut.</value>
  </data>
  <data name="DirectLambdaParameterReference" xml:space="preserve">
    <value>Impossible de sérialiser les expressions contenant des références de paramètre lambda directes. Possible référence de variable incorrect.</value>
  </data>
  <data name="DirectoryAborted" xml:space="preserve">
    <value>Le répertoire des instances chargées a été abandonné. Un arrêt brutal du service est en cours.</value>
  </data>
  <data name="DispatchOperationInInvalidState" xml:space="preserve">
    <value>WorkflowOperationBehavior ne peut pas appliquer le comportement de répartition car l'état de l'instance DispatchOperation n'est pas valide.</value>
  </data>
  <data name="DoNotCompleteTryCommandWithPendingReclaim" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a terminé le traitement d'une demande TryCommand alors qu'une tentative de récupération de verrou était en cours. Utilisez un fournisseur de persistance qui ne retourne pas d'erreur ni ne lève d'exception à partir de TryCommand, qui ne termine pas le IAsyncResult retourné par BeginTryCommand avant que le IAsyncResult retourné par BeginBindReclaimedLock ne soit terminé ou qui ne se termine pas avant de lever l'exception retournée par CreateBindReclaimedLockException.</value>
  </data>
  <data name="DoNotSupportArrayIndexerOnNonArrayType" xml:space="preserve">
    <value>ArrayIndexer sur le type {0} n'est pas pris en charge, car il n'est pas de type de tableau.</value>
  </data>
  <data name="DoNotSupportArrayIndexerReferenceWithDifferentArrayTypeAndResultType" xml:space="preserve">
    <value>ArrayIndexer comme LValue avec le type de tableau {0} et le type de résultat {1} n'est pas pris en charge, car ils ne sont pas identiques.</value>
  </data>
  <data name="DoNotSupportArrayIndexerValueWithIncompatibleArrayTypeAndResultType" xml:space="preserve">
    <value>ArrayIndexer comme valeur right avec un type d'élément de tableau {0} et un type de résultat {1} n'est pas pris en charge car {0} n'est pas compatible avec {1}.</value>
  </data>
  <data name="DoNotSupportArrayIndexerWithDifferentArrayTypeAndResultType" xml:space="preserve">
    <value>ArrayIndexer avec un type de tableau {0} et un type de résultat {1} n'est pas pris en charge, car ils ne sont pas identiques.</value>
  </data>
  <data name="DoNotSupportArrayIndexerWithNonIntIndex" xml:space="preserve">
    <value>ArrayIndexer avec le type d'index {0} n'est pas pris en charge, car il n'est pas de type int.</value>
  </data>
  <data name="DoWhileRequiresCondition" xml:space="preserve">
    <value>Une condition doit être définie avant qu'une activité DoWhile '{0}' puisse être utilisée.</value>
  </data>
  <data name="DUActivityTypeMismatch" xml:space="preserve">
    <value>Le type de cette activité est '{0}' dans la définition mise à jour mais '{1}' dans la définition d'origine.</value>
  </data>
  <data name="DUActivityTypeMismatchRuntime" xml:space="preserve">
    <value>Le type de cette activité a été modifié dans le cadre de la mise à jour.</value>
  </data>
  <data name="DUDisallowIfCannotFindingMatchingCondition" xml:space="preserve">
    <value>StateMachine ne prend pas en charge la mise à jour dynamique si le déclencheur d'une transition conditionnelle est supprimé ou si une activité Condition dans la définition mise à jour est réassignée à partir d'une autre propriété.</value>
  </data>
  <data name="DuplexContractsNotSupported" xml:space="preserve">
    <value>Le workflow ne prend pas en charge les contrats duplex. Supprimez la propriété CallbackContract de ServiceContractAttribute. </value>
  </data>
  <data name="DuplicateAnnotationName" xml:space="preserve">
    <value>Impossible d'ajouter une annotation nommée '{0}'. Vérifiez les requêtes de profil de suivi pour les noms en double dans les annotations ou les variables d'environnement. </value>
  </data>
  <data name="DuplicateCatchClause" xml:space="preserve">
    <value>Une clause catch existe déjà pour le type {0}. Une seule clause catch peut être ajoutée pour chaque type d'exception CLR unique.</value>
  </data>
  <data name="DuplicateCorrelationQuery" xml:space="preserve">
    <value>CorrelationQuery en double trouvé avec Where='{0}'. Cette requête en double ne sera pas utilisée lors du calcul de la corrélation.</value>
  </data>
  <data name="DuplicatedContract" xml:space="preserve">
    <value>Plusieurs types de contrats implémentés contiennent le contrat '{0}' et l'opération '{1}'.</value>
  </data>
  <data name="DuplicateDefinitionIdentity" xml:space="preserve">
    <value>Le WorkflowService ({0}) avec DefinitionIdentity existe déjà.</value>
  </data>
  <data name="DuplicateEvaluationOrderValues" xml:space="preserve">
    <value>L'activité '{0}' a plusieurs arguments runtime avec un ordre d'évaluation défini à '{1}'. Les valeurs de l'ordre d'évaluation de l'argument runtime doivent être uniques.</value>
  </data>
  <data name="DuplicateImportAttribute" xml:space="preserve">
    <value>La propriété '{0}' de DynamicActivity '{1}' possède plusieurs ImportAttribute. Seul un ImportAttribute est permis par propriété.</value>
  </data>
  <data name="DuplicateInstanceKeyExists" xml:space="preserve">
    <value>Une clé d'instance de valeur '{0}' existe déjà. Il se peut qu'il existe plusieurs MessageQuerySets définis qui correspondent au même CorrelationKey.</value>
  </data>
  <data name="DuplicateInstrumentation" xml:space="preserve">
    <value>Instrumentation dupliquée pour {0}. Le débogueur risque de s'interrompre à un emplacement incorrect.</value>
  </data>
  <data name="DuplicateMethodFound" xml:space="preserve">
    <value>Correspondance ambiguë. '{0}' a plusieurs méthodes '{1}' publiques appelées '{2}' qui correspondent aux types de paramètres, aux arguments de type génériques et aux contraintes de type génériques fournis à InvokeMethod '{3}'.</value>
  </data>
  <data name="DuplicateOriginActivityActivity" xml:space="preserve">
    <value>Le même objet d'origine '{0}' est utilisé par l'activité '{1}' et l'activité '{2}'.</value>
  </data>
  <data name="DuplicateOriginActivityVariable" xml:space="preserve">
    <value>Le même objet d'origine '{0}' est utilisé par l'activité '{1}' et la variable '{2}'.</value>
  </data>
  <data name="DuplicateOriginVariableVariable" xml:space="preserve">
    <value>Le même objet d'origine '{0}' est utilisé par la variable '{1}' et la variable '{2}'.</value>
  </data>
  <data name="DurationIsNegative" xml:space="preserve">
    <value>La valeur de l'argument Duration dans l'activité Delay '{0}' est négative.</value>
  </data>
  <data name="DUTriggerOrConditionChangedDuringTransitioning" xml:space="preserve">
    <value>StateMachine ne prend pas en charge la mise à jour dynamique si l'état est en cours de transition et que la transition actuelle a été modifiée.</value>
  </data>
  <data name="DynamicActivityDuplicatePropertyDetected" xml:space="preserve">
    <value>Une propriété nommée '{0}' existe déjà dans la collection DynamicActivity.Properties.</value>
  </data>
  <data name="DynamicActivityMultipleExpressionLanguages" xml:space="preserve">
    <value>La définition d'activité spécifiée contient plusieurs langages d'activités d'expression qui nécessitent une compilation (langages découverts : '{0}'). Seul un langage nécessitant une compilation est permis par définition. Convertissez toutes les activités d'expression qui nécessitent une compilation en un même langage.</value>
  </data>
  <data name="EmptyCorrelationQueryResults" xml:space="preserve">
    <value>Une requête de corrélation a donné un jeu de résultats vide. Vérifiez que les requêtes de corrélation pour le point de terminaison sont correctement configurées.</value>
  </data>
  <data name="EmptyGuidOnDeserializedInstance" xml:space="preserve">
    <value>L'ID d'instance d'une instance désérialisée ne contient que des zéros (Guid.Empty). Les instances sérialisées doivent avoir un ID d'instance différent de zéro.</value>
  </data>
  <data name="EmptyIdReturnedFromHost" xml:space="preserve">
    <value>L'implémentation de la propriété 'Id' sur le type d'hôte de workflow '{0}' a retourné un ID d'instance ne contenant que des zéros. Les implémentations de WorkflowInstance doivent retourner un ID d'instance différent de Guid.Empty.</value>
  </data>
  <data name="EndpointAddressNotSetInEndpoint" xml:space="preserve">
    <value>Échec de la récupération du EndpointAddress à partir du point de terminaison, du fichier de configuration ou du contexte de rappel. Il se peut que ni le point de terminaison, ni la configuration du point de terminaison n'ont été définis pour l'activité avec OperationName='{0}'.</value>
  </data>
  <data name="EndpointIncorrectlySet" xml:space="preserve">
    <value>Les propriétés Endpoint et EndpointConfigurationName sont définies dans l'activité '{0}' avec OperationName='{1}'. Cependant, une seule peut être définie à la fois.</value>
  </data>
  <data name="EndpointNotSet" xml:space="preserve">
    <value>L'activité '{0}' avec OperationName='{1}' doit spécifier la propriété Endpoint ou la propriété EndpointConfigurationName.</value>
  </data>
  <data name="EndSqlCommandExecute" xml:space="preserve">
    <value>Fin de l'exécution de la commande SQL : {0}</value>
  </data>
  <data name="EnlistedTransactionPropertiesRequireIsolationBlocks" xml:space="preserve">
    <value>Un TransactionProperty avec enlistWorkflowState défini à True doit être ajouté au sein du bloc d'isolation.</value>
  </data>
  <data name="EnterNoPersistBlock" xml:space="preserve">
    <value>Entrée dans un bloc sans persistance.</value>
  </data>
  <data name="EnumeratorNotStarted" xml:space="preserve">
    <value>L'énumération n'a pas commencé. Appelez MoveNext.</value>
  </data>
  <data name="EnvironmentDisposed" xml:space="preserve">
    <value>LocationEnvironment est accessible uniquement au sein de la portée de condition dans laquelle il a été passé.</value>
  </data>
  <data name="ErrorExtractingValuesForLambdaRewrite" xml:space="preserve">
    <value>Une erreur s'est produite lors de la tentative d'extraction de l'objet cible de type '{0}' de l'expression d'appel de méthode '{1}'. Notez que l'expression déterminant l'objet de type '{0}' ne doit pas requérir le contexte d'exécution. Erreur : {2}</value>
  </data>
  <data name="ErrorsEncounteredWhileProcessingTree" xml:space="preserve">
    <value>Les erreurs suivantes ont été rencontrées lors du traitement de l'arborescence du workflow :</value>
  </data>
  <data name="ErrorTimeToPersistLessThanZero" xml:space="preserve">
    <value>La valeur TimeToPersist doit être supérieure ou égale à TimeSpan.Zero. Pour désactiver, spécifiez une valeur égale à TimeSpan.MaxValue.</value>
  </data>
  <data name="ErrorTimeToUnloadLessThanZero" xml:space="preserve">
    <value>La valeur TimeToUnload doit être supérieure ou égale à TimeSpan.Zero. Pour désactiver, spécifiez une valeur égale à TimeSpan.MaxValue.</value>
  </data>
  <data name="EtwAPIMaxStringCountExceeded" xml:space="preserve">
    <value>Le nombre d'arguments string passés à Etw WriteEvent a dépassé la limite maximale autorisée de {0}.</value>
  </data>
  <data name="EtwMaxNumberArgumentsExceeded" xml:space="preserve">
    <value>Le nombre d'arguments passés à Etw WriteEvent a dépassé la limite maximale autorisée de {0}.</value>
  </data>
  <data name="EtwRegistrationFailed" xml:space="preserve">
    <value>Échec de l'inscription Etw avec le code d'erreur {0}.</value>
  </data>
  <data name="EtwUnhandledException" xml:space="preserve">
    <value>Exception non gérée. Détails de l'exception : {0}</value>
  </data>
  <data name="ExclusiveHandleRegisterBookmarkScopeFailed" xml:space="preserve">
    <value>RegisterBookmarkScope ne peut être appelé que lorsqu'aucun signet n'existe dans la portée du ExclusiveHandle correspondant.</value>
  </data>
  <data name="ExclusiveHandleReinitializeFailed" xml:space="preserve">
    <value>Reinitialize ne peut être appelé que lorsqu'aucun signet n'est inscrit auprès de ce ExclusiveHandle.</value>
  </data>
  <data name="ExecuteMustBeNested" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore n'est pas valide. Elle a essayé d'exécuter plusieurs commandes imbriquées en même temps. Un seul appel à InstancePersistenceContext.Execute (ou BeginExecute) peut être émis en même temps pour chaque appel à InstanceStore.TryCommand (ou BeginTryCommand). Cette erreur indique une implémentation de fournisseur de persistance non valide.</value>
  </data>
  <data name="ExecuteWorkItemStart" xml:space="preserve">
    <value>Début de l'exécution de l'élément de travail</value>
  </data>
  <data name="ExecuteWorkItemStop" xml:space="preserve">
    <value>Arrêt de l'exécution de l'élément de travail</value>
  </data>
  <data name="ExecutionPropertyAlreadyDefined" xml:space="preserve">
    <value>Une propriété portant le nom '{0}' a déjà été définie dans cette portée. Pour remplacer la propriété actuelle, supprimez-la, puis ajoutez la nouvelle propriété.</value>
  </data>
  <data name="ExitNoPersistBlock" xml:space="preserve">
    <value>Sortie d'un bloc sans persistance.</value>
  </data>
  <data name="ExpressionRequiredForConversion" xml:space="preserve">
    <value>L'expression est requise pour la conversion.</value>
  </data>
  <data name="ExtensionsCannotBeModified" xml:space="preserve">
    <value>Impossible de modifier WorkflowInstanceExtensionsManager une fois qu'il a été associé à un WorkflowInstance.</value>
  </data>
  <data name="ExtensionsCannotBeSetByIndex" xml:space="preserve">
    <value>La collection d'extensions ne prend pas en charge la définition d'extensions par index. Utilisez les méthodes Ajouter ou Supprimer.</value>
  </data>
  <data name="ExtensionTypeNotSupported" xml:space="preserve">
    <value>L'ajout d'une extension de type « {0} » n'est pas pris en charge par WorkflowServiceHost.</value>
  </data>
  <data name="ExternalLocationsGetOnly" xml:space="preserve">
    <value>L'emplacement que vous essayez de définir provient d'un SymbolResolver. Les emplacements SymbolResolver sont en lecture seule.</value>
  </data>
  <data name="ExtraOverloadGroupPropertiesConfigured" xml:space="preserve">
    <value>Le group surchargé '{0}' est déjà configuré. La propriété '{1}' ne doit pas également être configurée dans un groupe surchargé '{2}'.</value>
  </data>
  <data name="ExtraParameter" xml:space="preserve">
    <value>Le paramètre '{0}' n'est pas déclaré dans l'opération '{1}' du contrat '{2}'.</value>
  </data>
  <data name="ExtraReturnValue" xml:space="preserve">
    <value>L'activité contient un message de retour, alors que le contrat ne contient aucune valeur de retour.</value>
  </data>
  <data name="FailedToCreateSecurityToken" xml:space="preserve">
    <value>Échec de la création du jeton de sécurité '{0}'.</value>
  </data>
  <data name="FailedToGetInstanceIdForControlOperation" xml:space="preserve">
    <value>Échec de l'obtention de l'ID d'instance à partir du message pour cette opération de contrôle. Ceci peut être causé par des contrats qui ne correspondent pas. Vérifiez que le contrat du client correspond au contrat du point de terminaison du service.</value>
  </data>
  <data name="FailedToGetWorkflowIdentityForControlOperation" xml:space="preserve">
    <value>Échec de la récupération de WorkflowIdentity à partir du message pour cette opération de contrôle. Cet échec peut être dû au fait que les contrats ne correspondent pas. Assurez-vous que le contrat client correspond au client de point de terminaison de service.</value>
  </data>
  <data name="FailedToInitializeRequestReplyCorrelationHandle" xml:space="preserve">
    <value>L'activité Receive configurée avec l'option de requête/réponse '{0}' n'a pas pu initialiser un handle RequestReplyCorrelation. Le CorrelationMessageProperty du message reçu doit comporter un InstanceKey avec RequestReplyCorrelation.</value>
  </data>
  <data name="FailedToLoadBindingInControlEndpoint" xml:space="preserve">
    <value>Échec du chargement de la liaison '{0}' avec la configuration de liaison '{1}' pour le point de terminaison de contrôle standard '{2}'.</value>
  </data>
  <data name="FailFastMessage" xml:space="preserve">
    <value>Une erreur irrécupérable s'est produite. À des fins de diagnostics, ce message en anglais est associé à la défaillance : '{0}'.</value>
  </data>
  <data name="FaultContextNotFound" xml:space="preserve">
    <value>L'activité Rethrow '{0}' ne peut pas trouver le FaultContext définit par l'activité TryCatch. Pour résoudre ce problème, ne modifiez pas ou ne supprimez pas le FaultContext de la collection de propriétés d'exécution.</value>
  </data>
  <data name="FaultTypeMismatch" xml:space="preserve">
    <value>Le type d'erreur spécifié '{0}' n'existe pas pour l'opération '{1}' du contrat '{2}'.</value>
  </data>
  <data name="FinalStateCannotHaveProperty" xml:space="preserve">
    <value>L'état final « {0} » ne doit pas avoir d'action {1}.</value>
  </data>
  <data name="FinalStateCannotHaveTransition" xml:space="preserve">
    <value>L'état final « {0} » ne doit pas avoir de transitions sortantes.</value>
  </data>
  <data name="FirstParameterDoesnotMatchTheReturnValue" xml:space="preserve">
    <value>Le premier paramètre de type '{0}' spécifié dans le contenu ne correspond pas au type '{1}' spécifié en tant que valeur de retour pour l'opération '{2}' du contrat '{3}'.</value>
  </data>
  <data name="FlowchartContainsReferences" xml:space="preserve">
    <value>L'organigramme ne prend pas en charge la mise à jour dynamique lorsqu'il possède des références à des enfants importés.</value>
  </data>
  <data name="FlowchartContainsUnconnectedNodes" xml:space="preserve">
    <value>Si ValidateUnconnectedNodes a la valeur True, tous les nœuds doivent être connectés avant de pouvoir utiliser l'organigramme '{0}'.</value>
  </data>
  <data name="FlowchartEmpty" xml:space="preserve">
    <value>Le diagramme '{0}' - a été exécuté sans nœuds.</value>
  </data>
  <data name="FlowchartMissingStartNode" xml:space="preserve">
    <value>Flowchart '{0}' n'a pas de StartNode.</value>
  </data>
  <data name="FlowchartNextNull" xml:space="preserve">
    <value>Flowchart '{0}'/FlowStep - Le nœud suivant est Null. L'exécution de Flowchart va se terminer.</value>
  </data>
  <data name="FlowchartStart" xml:space="preserve">
    <value>Diagramme '{0}' - Le début a été planifié</value>
  </data>
  <data name="FlowchartSwitchCase" xml:space="preserve">
    <value>Flowchart '{0}'/FlowSwitch - Le cas '{1}' a été sélectionné.</value>
  </data>
  <data name="FlowchartSwitchCaseNotFound" xml:space="preserve">
    <value>Flowchart '{0}'/FlowSwitch - impossible de trouver l'activité Case ou un cas par défaut correspondant au résultat de l'expression. L'exécution de Flowchart va se terminer.</value>
  </data>
  <data name="FlowchartSwitchDefault" xml:space="preserve">
    <value>Flowchart '{0}'/FlowSwitch - cas par défaut a été sélectionné.</value>
  </data>
  <data name="FlowDecisionRequiresCondition" xml:space="preserve">
    <value>La condition doit être définie avant que FlowDecision dans Flowchart '{0}' puisse être utilisé.</value>
  </data>
  <data name="FlowedTransactionDifferentFromAmbient" xml:space="preserve">
    <value>La transaction passée était différente de la transaction ambiante.</value>
  </data>
  <data name="FlowNodeCannotBeShared" xml:space="preserve">
    <value>FlowNode ne peut pas être partagé entre plusieurs Flowcharts. Il se trouve déjà dans Flowchart '{0}' et ne peut pas être utilisé dans Flowchart '{1}'.</value>
  </data>
  <data name="FlowNodeLockedForRuntime" xml:space="preserve">
    <value>FlowNode dans Flowchart '{0}' a déjà été ouvert et ne peut pas être modifié. Un FlowNode ne peut être modifié qu'au moment du design.</value>
  </data>
  <data name="FlowSwitchRequiresExpression" xml:space="preserve">
    <value>Expression doit être défini avant que le FlowSwitch dans Flowchart '{0}' puisse être utilisé.</value>
  </data>
  <data name="ForEachRequiresNonNullValues" xml:space="preserve">
    <value>Les valeurs doivent être liées à une expression non Null avant que l'activité ForEach '{0}' puisse être utilisée.</value>
  </data>
  <data name="FoundProcessingError" xml:space="preserve">
    <value>Échec de la commande : {0}</value>
  </data>
  <data name="GeneratedAndProvidedMapConflict" xml:space="preserve">
    <value>Des modifications conflictuelles ont été apportées à cette activité par la table d'implémentation fournie et la mise à jour actuelle. L'activité a tenté d'enregistrer des valeurs d'origine dans les deux tables.</value>
  </data>
  <data name="GeneratedAndProvidedMapConflictRuntime" xml:space="preserve">
    <value>Des modifications conflictuelles ont été apportées à cette activité par une mise à jour d'implémentation et une mise à jour de workflow de taille plus importante. L'activité a tenté d'enregistrer les valeurs d'origine dans les deux mises à jour.</value>
  </data>
  <data name="GenericInstanceCommand" xml:space="preserve">
    <value>L'exécution du InstancePersistenceCommand nommé {0} a été interrompue par une erreur.</value>
  </data>
  <data name="GenericInstanceCommandNull" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue par une erreur.</value>
  </data>
  <data name="GetLocationOnPublicAccessReference" xml:space="preserve">
    <value>L'activité '{0}' ne peut pas appeler GetLocation dans cette référence à un emplacement public car il a été créé à l'aide de CodeActivityPublicEnvironmentAccessor.TryGetAccessToPublicLocation. Pour lire ou écrire la valeur, utilisez ActivityContext.GetValue ou SetValue. Pour obtenir un accès direct à un emplacement, déclarez-le à l'aide de CodeActivityPublicEnvironmentAccessor.TryGetReferenceToPublicLocation.</value>
  </data>
  <data name="GetParameterTypeMismatch" xml:space="preserve">
    <value>Le paramètre à l'index {0} demandé à partir du InstancePersistenceAction nommé {1} a été demandé à l'aide d'un argument de type générique incorrect. Lors de l'appel de GetParameter&lt;T&gt;, le type spécifié pour T doit correspondre au type documenté du paramètre.</value>
  </data>
  <data name="GetRunnableRequiresOwner" xml:space="preserve">
    <value>Avant d'appeler cette méthode, spécifiez les identités de définition prises en charge de ce serveur d'hébergement de workflow en appelant WorkflowApplication.CreateDefaultInstanceOwner.</value>
  </data>
  <data name="GuidCannotBeEmpty" xml:space="preserve">
    <value>L'argument doit être un Guid différent de zéro.</value>
  </data>
  <data name="HandledException" xml:space="preserve">
    <value>Gestion d'une exception.  Détails de l'exception : {0}</value>
  </data>
  <data name="HandledExceptionError" xml:space="preserve">
    <value>Gestion d'une exception. Détails de l'exception : {0}</value>
  </data>
  <data name="HandledExceptionVerbose" xml:space="preserve">
    <value>Gestion d'une exception.  Détails de l'exception : {0}</value>
  </data>
  <data name="HandledExceptionWarning" xml:space="preserve">
    <value>Gestion d'une exception. Détails de l'exception : {0}</value>
  </data>
  <data name="HandleFreed" xml:space="preserve">
    <value>L'exécution de InstancePersistenceCommands a été annulée car InstanceHandle a été libéré.</value>
  </data>
  <data name="HandleFreedBeforeInitialized" xml:space="preserve">
    <value>La méthode Free sur InstanceHandle ne peut pas être appelée lorsque OnNewInstanceHandle est en cours d'exécution pour ce handle.</value>
  </data>
  <data name="HandleFreedInDirectory" xml:space="preserve">
    <value>L'exécution de InstancePersistenceCommands a été annulée car InstanceHandle a été libéré.</value>
  </data>
  <data name="HandleInitializationContextDisposed" xml:space="preserve">
    <value>Un HandleInitializationContext n'est accessible qu'au sein de la portée de la fonction dans laquelle il a été passé.</value>
  </data>
  <data name="HandleNotInitialized" xml:space="preserve">
    <value>Le handle n'est pas initialisé. Les handles doivent être créés et initialisés par le runtime et ne sont valides qu'au sein de la portée dans laquelle ils sont déclarés.</value>
  </data>
  <data name="HasExecutingChildrenNoPersist" xml:space="preserve">
    <value>Les blocs sans persistance ne peuvent être configurés que lorsqu'il n'existe pas d'enfant en cours d'exécution.</value>
  </data>
  <data name="HostIdDoesNotMatchInstance" xml:space="preserve">
    <value>L'ID d'instance fourni par l'hôte de workflow {0} ne correspond pas à l'ID stocké dans l'instance sérialisée {1}. Un hôte ne peut pas désérialiser une instance à l'aide d'un ID différent de celui utilisé quand l'instance était sérialisée.</value>
  </data>
  <data name="HostLockExpired" xml:space="preserve">
    <value>Le verrou SqlWorkflowInstanceStore a expiré. Cela peut être dû au fait que le serveur SQL Server est occupé ou que la connexion est provisoirement perdue.</value>
  </data>
  <data name="HostLockNotFound" xml:space="preserve">
    <value>Le verrou SqlWorkflowInstanceStore n'existe pas dans la base de données. Cela peut être dû au fait que le serveur SQL Server est occupé ou que la connexion est provisoirement perdue.</value>
  </data>
  <data name="IdentityControlCharacter" xml:space="preserve">
    <value>WorkflowIdentity.Name et Package ne peuvent pas contenir des caractères de contrôle (caractères Unicode de type Cc).</value>
  </data>
  <data name="IdentityNameSemicolon" xml:space="preserve">
    <value>WorkflowIdentity.Name ne peut pas contenir de point-virgule ';' .</value>
  </data>
  <data name="IdentityNotSupportedWithActivation" xml:space="preserve">
    <value>SqlWorkflowInstanceStore ne prend pas en charge l'activation des InstanceOwner qui spécifient des DefinitionIdentity.</value>
  </data>
  <data name="IdentityWhitespace" xml:space="preserve">
    <value>WorkflowIdentity.Name et Package ne peuvent pas être précédés ou suivis d'un espace blanc (caractères Unicode de type Zl, Zp et Zs).</value>
  </data>
  <data name="IdNotFoundInWorkflow" xml:space="preserve">
    <value>Impossible de trouver l'ID '{0}' fourni dans le workflow. Vérifiez le workflow à la recherche d'erreurs de validation qui pourraient générer des sous-arbres qui ne peuvent pas être traversés.</value>
  </data>
  <data name="ImplementationVersionMismatch" xml:space="preserve">
    <value>L'ImplementationVersion ('{0}') de l'instance d'activité chargée ne correspond pas à l'ImplementationVersion ('{1}') de l'activité fournie ('{2}'). L'instance peut être mise à jour par l'application d'une table d'implémentation.</value>
  </data>
  <data name="InArgumentBound" xml:space="preserve">
    <value>Dans l'argument '{0}' de l'activité '{1}', DisplayName : '{2}', InstanceID : '{3}' a été lié avec la valeur : {4}.</value>
  </data>
  <data name="IncompatibleArgumentType" xml:space="preserve">
    <value>Un argument de type incorrect a été passé à cette méthode. Cette méthode attendait un argument de type {0}, mais un argument de type {1} a été passé.</value>
  </data>
  <data name="IncompatibleTypeForMultidimensionalArrayItemReference" xml:space="preserve">
    <value>Le type générique '{0}' n'est pas compatible avec le véritable type d'élément '{1}' de l'opérande Array dans MultidimensionalArrayItemReference.</value>
  </data>
  <data name="IncorrectIndexForArgument" xml:space="preserve">
    <value>L'index pour l'argument de retour est incorrect dans la collection '{0}'. La position spécifiée est '{1}' et la position attendue est '{2}'.</value>
  </data>
  <data name="IncorrectValueType" xml:space="preserve">
    <value>Une valeur de type incorrect a été récupérée du magasin d'instances. Une valeur de type {0} était attendue, mais une valeur de type {1} a été trouvée à la place.</value>
  </data>
  <data name="IndexOutOfBounds" xml:space="preserve">
    <value>La valeur de l'index {0} est égale ou supérieure à {1}, la longueur du tableau.</value>
  </data>
  <data name="IndicesAreNeeded" xml:space="preserve">
    <value>Au moins une valeur d'index doit être fournie pour l'activité {0} '{1}'.</value>
  </data>
  <data name="InferredContractDescription" xml:space="preserve">
    <value>ContractDescription avec Name='{0}' et Namespace='{1}' a été déduit de WorkflowService.</value>
  </data>
  <data name="InferredOperationDescription" xml:space="preserve">
    <value>OperationDescription avec Name='{0}' dans le contrat '{1}' a été déduit de WorkflowService. IsOneWay={2}.</value>
  </data>
  <data name="InitializationIncomplete" xml:space="preserve">
    <value>L'initialisation de l'instance d'activité était incomplète. Cette erreur se produit en cas d'erreur de la valeur par défaut ou de l'expression d'un argument et que le gestionnaire d'exceptions autorise la poursuite de l'exécution.</value>
  </data>
  <data name="InitializeCorrelationRequiresWorkflowServiceHost" xml:space="preserve">
    <value>L'activité '{0}' doit être utilisée dans un WorkflowServiceHost.</value>
  </data>
  <data name="InitialMetadataCannotBeDeleted" xml:space="preserve">
    <value>La valeur de persistance nommée {0} est fournie comme une valeur de métadonnées initiale, elle doit donc avoir un InstanceValue valide autre que InstanceValue.DeletedValue.</value>
  </data>
  <data name="InitialStateCannotBeFinalState" xml:space="preserve">
    <value>L'état initial « {0} » ne doit pas être également un état final.</value>
  </data>
  <data name="InitialStateNotInStatesCollection" xml:space="preserve">
    <value>L'état initial « {0} » doit être ajouté à la collection d'états d'une machine à états.</value>
  </data>
  <data name="InlinedLocationReferenceOnlyAccessibleByOwner" xml:space="preserve">
    <value>L'activité '{0}' ne peut pas accéder à cette référence d'emplacement public, car celle-ci n'est valide que pour l'activité '{1}'. Seule l'activité qui a obtenu la référence d'emplacement public est autorisée à l'utiliser.</value>
  </data>
  <data name="InputParametersCountMismatch" xml:space="preserve">
    <value>Le nombre de paramètres d'entrée fourni {0} ne correspond pas au nombre attendu {1}.</value>
  </data>
  <data name="InputParametersMissing" xml:space="preserve">
    <value>Le paramètre d'entrée attendu '{0}' est introuvable.</value>
  </data>
  <data name="InputParametersTypeMismatch" xml:space="preserve">
    <value>Valeur de paramètre d'entrée attendu de type '{0}' pour le paramètre nommé '{1}'.</value>
  </data>
  <data name="InstanceCollisionDefault" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue car l'instance est déjà persistante dans le magasin d'instances.</value>
  </data>
  <data name="InstanceCollisionSpecific" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue car l'instance '{0}' est déjà persistante dans le magasin d'instances.</value>
  </data>
  <data name="InstanceCompleteDefault" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue car l'instance est déjà terminée.</value>
  </data>
  <data name="InstanceCompleteSpecific" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue car l'instance '{0}' est déjà terminée.</value>
  </data>
  <data name="InstanceHandleConflictDefault" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue, car un autre InstanceHandle valide contient un verrou sur l'instance, ce qui indique qu'une copie non périmée de l'instance est déjà chargée. La copie chargée de l'instance et son InstanceHandle associé doivent être utilisés ou déchargés.</value>
  </data>
  <data name="InstanceHandleConflictSpecific" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue, car un autre InstanceHandle valide contient un verrou sur l'instance '{0}', ce qui indique qu'une copie non périmée de l'instance est déjà chargée. La copie chargée de l'instance et son InstanceHandle associé doivent être utilisés ou déchargés.</value>
  </data>
  <data name="InstanceKeyMetadataChangesNotSupported" xml:space="preserve">
    <value>SqlWorkflowInstanceStore ne prend pas en charge la modification de métadonnées de clés qui existent déjà.</value>
  </data>
  <data name="InstanceKeyRequiresValidGuid" xml:space="preserve">
    <value>Impossible de créer un InstanceKey avec une valeur ne contenant que des zéros, par exemple Guid.Empty. Utilisez InstanceKey.InvalidKey pour obtenir un InstanceKey avec une valeur ne contenant que des zéros.</value>
  </data>
  <data name="InstanceLockedUnderTransaction" xml:space="preserve">
    <value>Échec de la tentative d'exécution de l'opération de contrôle '{0}' sur l'instance de service avec l'identificateur '{1}'. Une opération de contrôle active traitée avec transaction est en cours.</value>
  </data>
  <data name="InstanceLockLostDefault" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue car l'instance est déverrouillée. Cette erreur indique que la copie en mémoire de l'instance est périmée et doit être ignorée, ainsi que le InstanceHandle.</value>
  </data>
  <data name="InstanceLockLostSpecific" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue, car l'instance '{0}' est déverrouillée. Cette erreur indique que la copie en mémoire de l'instance est périmée et doit être ignorée, ainsi que le InstanceHandle.</value>
  </data>
  <data name="InstanceLocksRecoveryError" xml:space="preserve">
    <value>Échec de la récupération des verrous d'instance en raison de l'exception suivante</value>
  </data>
  <data name="InstanceMethodCallRequiresTargetObject" xml:space="preserve">
    <value>L'appel de méthode d'instance requiert un objet cible.</value>
  </data>
  <data name="InstanceMustBePaused" xml:space="preserve">
    <value>L'instance doit être interrompue pour effectuer cette opération.</value>
  </data>
  <data name="InstanceMustNotBePaused" xml:space="preserve">
    <value>L'instance ne doit pas être interrompue pour effectuer cette opération.</value>
  </data>
  <data name="InstanceMustNotBeSuspended" xml:space="preserve">
    <value>Impossible d'effectuer cette opération car l'instance est suspendue.</value>
  </data>
  <data name="InstanceNotReadyDefault" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue car l'instance n'est pas encore persistante dans le magasin d'instances.</value>
  </data>
  <data name="InstanceNotReadySpecific" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue car l'instance '{0}' n'est pas encore persistante dans le magasin d'instances.</value>
  </data>
  <data name="InstanceOperationRequiresInstance" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé l'exécution d'une opération qui requiert une instance, mais aucune instance n'est liée à cette opération.</value>
  </data>
  <data name="InstanceOperationRequiresLock" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé l'exécution d'une opération qui requiert un verrou sur une instance, mais aucun verrou n'est présent.</value>
  </data>
  <data name="InstanceOperationRequiresNotCompleted" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé l'exécution d'une opération qui exige que l'instance soit dans un état autre que InstanceState.Completed, mais l'instance est dans cet état.</value>
  </data>
  <data name="InstanceOperationRequiresNotUninitialized" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé l'exécution d'une opération qui exige que l'instance soit dans un état autre que InstanceState.Uninitialized, mais l'instance est dans cet état.</value>
  </data>
  <data name="InstanceOperationRequiresOwner" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé l'exécution d'une opération qui requiert un propriétaire d'instance, mais aucun propriétaire n'est lié à cette opération.</value>
  </data>
  <data name="InstanceOwnerDefault" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue, car l'inscription du propriétaire de l'instance n'est plus valide. Cette erreur indique que la copie en mémoire de toutes les instances verrouillées par ce propriétaire est désormais périmée et doit être ignorée, ainsi que le InstanceHandles. Pour corriger cette erreur, redémarrez l'hôte.</value>
  </data>
  <data name="InstanceOwnerSpecific" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue, car l'inscription du propriétaire de l'instance pour l'ID de propriétaire '{0}' n'est plus valide. Cette erreur indique que la copie en mémoire de toutes les instances verrouillées par ce propriétaire est désormais périmée et doit être ignorée, ainsi que le InstanceHandles. Pour corriger cette erreur, redémarrez l'hôte.</value>
  </data>
  <data name="InstanceRequired" xml:space="preserve">
    <value>Le système de persistance d'instance n'a pas réussi à traiter un InstancePersistenceCommand non valide. La commande requiert une instance, mais aucune instance n'était liée à InstanceHandle.</value>
  </data>
  <data name="InstanceStoreBoundSameVersionTwice" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé l'acquisition et la validation de la même version d'un verrou sur la même instance à deux reprises. Lors de chaque acquisition d'un verrou sur une instance, la version du verrou doit être incrémentée ; ou bien zéro doit toujours être signalé en tant que version du verrou. Lorsqu'un fournisseur détecte une tentative par un propriétaire d'instance de verrouiller une instance déjà verrouillée par elle-même, le fournisseur doit appeler BindReclaimedLock, BeginBindReclaimedLock ou CreateBeginBindReclaimedLockException au lieu de BindAcquiredLock.</value>
  </data>
  <data name="InstanceStoreDoesntMatchWorkflowApplication" xml:space="preserve">
    <value>L'instance est configurée avec un InstanceStore autre que celui de ce WorkflowApplication.</value>
  </data>
  <data name="InstanceStoreFailed" xml:space="preserve">
    <value>L'implémentation de InstanceStore a levé une exception InstancePersistenceException. InstancePersistenceException est l'exception interne.</value>
  </data>
  <data name="InstanceStoreHasDefaultOwner" xml:space="preserve">
    <value>Cet InstanceStore a déjà un DefaultInstanceOwner.</value>
  </data>
  <data name="InstanceStoreReadOnly" xml:space="preserve">
    <value>SqlWorkflowInstanceStore est en lecture seule et ne peut plus être configuré. Toutes les opérations de configuration de SqlWorkflowInstanceStore doivent s'effectuer avant la création du premier InstanceHandle.</value>
  </data>
  <data name="InstanceStoreRequiredToPersist" xml:space="preserve">
    <value>Seuls les WorkflowApplications configurés avec un InstanceStore peuvent être persistants ou déchargés.</value>
  </data>
  <data name="InstanceSuspended" xml:space="preserve">
    <value>L'instance de service avec l'identificateur '{1}' est actuellement à l'état 'Suspended'. Échec de la tentative d'exécution de l'opération de contrôle '{0}'.</value>
  </data>
  <data name="InsufficientArraySize" xml:space="preserve">
    <value>La taille du tableau est {0} et n'est pas suffisante pour contenir les résultats de l'opération.</value>
  </data>
  <data name="InternalCacheMetadataStart" xml:space="preserve">
    <value>InternalCacheMetadata a démarré sur l'activité '{0}'.</value>
  </data>
  <data name="InternalCacheMetadataStop" xml:space="preserve">
    <value>InternalCacheMetadata s'est arrêté sur l'activité '{0}'.</value>
  </data>
  <data name="InternalConstraintException" xml:space="preserve">
    <value>Exception de contrainte interne lors de l'exécution de la contrainte nommée '{0}' par rapport à l'activité de type {1} portant le nom '{2}'. L'exception était : {3}</value>
  </data>
  <data name="InternalServerError" xml:space="preserve">
    <value>Le serveur n'a pas pu traiter la demande en raison d'une erreur interne. Pour plus d'informations sur l'erreur, activez IncludeExceptionDetailInFaults (depuis ServiceBehaviorAttribute ou depuis le comportement de configuration &lt;serviceDebug&gt;) sur le client pour renvoyer les informations de l'exception au client, ou activez le suivi conformément à la documentation du SDK de Microsoft .NET Framework 4.0 et examinez les journaux de suivi du serveur.</value>
  </data>
  <data name="InvalidActivityIdFormat" xml:space="preserve">
    <value>Le format de l'ID d'activité fourni n'est pas valide. Il doit s'agir d'une liste de valeurs entières séparées par des points, telle que '1.12.3' sans espaces au début ou à la fin.</value>
  </data>
  <data name="InvalidActivityToBlockUpdate" xml:space="preserve">
    <value>L'activité '{0}' dans DynamicUpdateMapBuilder.DisallowUpdateInside n'est pas un membre public de DynamicUpdateMapBuilder.UpdatedWorkflowDefinition. Assurez-vous que cette activité fait partie de la définition de workflow mise à jour. Si cette activité a été supprimée dans le cadre de la mise à jour, il n'est pas nécessaire de bloquer explicitement cette mise à jour. Elle sera automatiquement bloquée si une activité supprimée est en cours d'exécution.</value>
  </data>
  <data name="InvalidActivityToBlockUpdateServices" xml:space="preserve">
    <value>L'activité '{0}' n'est pas un membre public de updatedWorkflowDefinition. Assurez-vous que cette activité fait partie de la définition de workflow mise à jour. Si cette activité a été supprimée dans le cadre de la mise à jour, il n'est pas nécessaire de bloquer explicitement cette mise à jour. Elle sera automatiquement bloquée si une activité supprimée est en cours d'exécution.</value>
  </data>
  <data name="InvalidArgumentExpression" xml:space="preserve">
    <value>L'expression d'argument numéro {0} de type '{1}' n'est pas valide.</value>
  </data>
  <data name="InvalidAsyncBeginMethodSignature" xml:space="preserve">
    <value>La signature de méthode Begin asynchrone n'est pas valide pour la méthode {0} dans le type {1}. La méthode Begin doit prendre un élément AsyncCallback et un objet pour ses deux derniers arguments et retourner un élément IAsyncResult.</value>
  </data>
  <data name="InvalidAsyncCancelMethodSignature" xml:space="preserve">
    <value>La signature de méthode Cancel asynchrone n'est pas valide pour la méthode {0} dans le type {1}. La méthode Cancel ne doit pas avoir d'argument et retourner une valeur void.</value>
  </data>
  <data name="InvalidAsyncEndMethodSignature" xml:space="preserve">
    <value>La signature de la méthode End asynchrone n'est pas valide pour la méthode {0} dans le type {1}. La méthode End doit prendre un élément IAsyncResult comme dernier argument. </value>
  </data>
  <data name="InvalidAsyncResult" xml:space="preserve">
    <value>Un IAsyncResult incorrect a été fourni à une méthode 'End'. L'objet IAsyncResult passé à 'End' doit être celui renvoyé par la méthode 'Begin' correspondante ou passé au rappel fourni à 'Begin'.</value>
  </data>
  <data name="InvalidAsyncResultImplementation" xml:space="preserve">
    <value>Une implémentation incorrecte de l'interface IAsyncResult retourne peut-être des valeurs incorrectes à partir de la propriété CompletedSynchronously ou appelle peut-être AsyncCallback plusieurs fois. Cette implémentation incorrecte pourrait être le type {0}.</value>
  </data>
  <data name="InvalidAsyncResultImplementationGeneric" xml:space="preserve">
    <value>Une implémentation incorrecte de l'interface IAsyncResult retourne peut-être des valeurs incorrectes à partir de la propriété CompletedSynchronously ou appelle peut-être AsyncCallback plusieurs fois.</value>
  </data>
  <data name="InvalidCallbackState" xml:space="preserve">
    <value>Des données {0} valides doivent être passées pour l'objet d'état de rappel.</value>
  </data>
  <data name="InvalidCompensateActivityUsage" xml:space="preserve">
    <value>L'activité Compensate '{0}' avec un InArgument 'Target' annulé ne peut être utilisé qu'au sein du contexte d'un gestionnaire Compensation/Confirmation/Cancellation.</value>
  </data>
  <data name="InvalidCompensationToken" xml:space="preserve">
    <value>La variable liée au InArgument 'Target' a une valeur Null. Le InArgument 'Target' doit être défini à l'aide d'un CompensationToken valide obtenu à partir d'un CompensableActivity. Dans le cas contraire, si une utilisation Compensation/Confirmation est souhaitée, ne définissez pas InArgument 'Target' et utilisez l'activité '{0}' au sein du contexte d'un gestionnaire Compensation/Confirmation/Cancellation.</value>
  </data>
  <data name="InvalidConfirmActivityUsage" xml:space="preserve">
    <value>L'activité Confirm '{0}' avec un InArgument 'Target' annulé ne peut être utilisée qu'au sein du contexte d'un gestionnaire Compensation/Confirmation/Cancellation.</value>
  </data>
  <data name="InvalidDataFromReceiveBookmarkState" xml:space="preserve">
    <value>Impossible d'obtenir un MessageContext valide lors de la reprise du signet pour l'opération de réception « {0} ».</value>
  </data>
  <data name="InvalidDataFromSendBookmarkState" xml:space="preserve">
    <value>Impossible d'obtenir un CorrelationMessageProperty ou Fault valide lors de la reprise du signet pour l'opération d'envoi « {0} ».</value>
  </data>
  <data name="InvalidDirectionForArgument" xml:space="preserve">
    <value>La direction de l'argument pour l'argument dans la collection '{0}' à la position {1} est incorrecte. La direction spécifiée est '{2}' et la direction attendue '{3}'.</value>
  </data>
  <data name="InvalidDynamicActivityProperty" xml:space="preserve">
    <value>Ce descripteur de propriété n'est pas valide. Le composant fourni ne contient pas une propriété correspondant à ce descripteur ({0}).</value>
  </data>
  <data name="InvalidEvaluationOrderValue" xml:space="preserve">
    <value>Valeur EvaluationOrder non valide. Les valeurs de l'ordre d'évaluation doivent être basées sur zéro, augmenter en ordre et uniques. Utilisez -1 pour indiquer que l'ordre d'évaluation n'est pas défini.</value>
  </data>
  <data name="InvalidExecutionCallback" xml:space="preserve">
    <value>'{0}' n'est pas un rappel d'exécution d'activité valide. Le rappel d'exécution utilisé par '{1}' doit être une méthode d'instance sur '{1}'.</value>
  </data>
  <data name="InvalidExpressionForLocation" xml:space="preserve">
    <value>Un Location ne peut pas être généré à partir d'un Expression de type '{0}'.</value>
  </data>
  <data name="InvalidExpressionProperty" xml:space="preserve">
    <value>La propriété 'Expression' de type '{0}' n'est pas valide.</value>
  </data>
  <data name="InvalidFileName" xml:space="preserve">
    <value>Un nom de fichier non valide a été spécifié pour l'activité {0}</value>
  </data>
  <data name="InvalidGenericTypeInfo" xml:space="preserve">
    <value>Le type '{0}' contient des informations de type génériques non valides.</value>
  </data>
  <data name="InvalidIdleAction" xml:space="preserve">
    <value>PersistableIdleAction retourné hors limite. Il doit s'agir d'une valeur None, Unload ou Persist.</value>
  </data>
  <data name="InvalidImplementationAsWorkflowRoot" xml:space="preserve">
    <value>Pour pouvoir appliquer directement une table d'implémentation à une instance de workflow, la racine de la définition ne doit pas posséder d'enfants ni de délégués publics/importés.</value>
  </data>
  <data name="InvalidImplementationAsWorkflowRootForRuntimeState" xml:space="preserve">
    <value>Pour pouvoir appliquer directement une table d'implémentation à une instance de workflow, la racine de la définition ne doit pas posséder d'enfants publics. L'instance possède actuellement un ou plusieurs enfants publics en cours d'exécution.</value>
  </data>
  <data name="InvalidImplementationAsWorkflowRootForRuntimeStateBecauseArgumentsChanged" xml:space="preserve">
    <value>Pour pouvoir appliquer directement une table d'implémentation à une instance de workflow, la table d'implémentation doit indiquer qu'aucune modification n'a été apportée aux arguments. La table d'implémentation indique que les arguments de la définition d'activité ont été modifiés.</value>
  </data>
  <data name="InvalidImplementationMap" xml:space="preserve">
    <value>La table d'implémentation fournie ne correspond pas à la définition de l'activité. Assurez-vous que la version de l'activité référencée par le workflow mis à jour est la même que la version ciblée par la table fournie.]D;]A;    ]D;]A;Détails de résolution : Nombre de membres dans la table : '{0}'; nombre de membres dans la définition: '{1}'.</value>
  </data>
  <data name="InvalidImplementationMapAssociation" xml:space="preserve">
    <value>La table d'implémentation fournie pour l'activité '{0}' via DynamicUpdateMapBuilder.LookupImplementationMap ne peut pas être utilisée car l'activité ne possède aucun enfant d'implémentation. Vérifiez que SetImplementationMap a été appelé pour la bonne activité.</value>
  </data>
  <data name="InvalidImplementationMapAssociationServices" xml:space="preserve">
    <value>La table d'implémentation fournie pour l'activité '{0}' via DynamicUpdateServices.SetImplementationMap ne peut pas être utilisée car l'activité ne possède aucun enfant d'implémentation. Vérifiez que SetImplementationMap a été appelé pour la bonne activité.</value>
  </data>
  <data name="InvalidImplementationMapRuntime" xml:space="preserve">
    <value>La mauvaise table d'implémentation a été fournie pour cette activité lors de la création de la table de mise à jour.</value>
  </data>
  <data name="InvalidInstanceId" xml:space="preserve">
    <value>Un ID d'instance non valide ne contenant que des zéros (Guid.Empty) a été utilisé pour charger une instance.</value>
  </data>
  <data name="InvalidInstanceState" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé le chargement d'une instance avec une valeur InstanceState non valide.</value>
  </data>
  <data name="InvalidKey" xml:space="preserve">
    <value>Une clé non valide a été utilisée pour charger ou créer une instance.</value>
  </data>
  <data name="InvalidKeyArgument" xml:space="preserve">
    <value>Une clé non valide ne contenant que des zéros, telle que Guid.Empty, a été passée comme argument.</value>
  </data>
  <data name="InvalidLocationExpression" xml:space="preserve">
    <value>Expression d'emplacement non valide : "[...]5D;" attendu.</value>
  </data>
  <data name="InvalidLockRenewalPeriod" xml:space="preserve">
    <value>La période de renouvellement du verrou fournie {0} est inférieure à la période de renouvellement du verrou minimale {1}.</value>
  </data>
  <data name="InvalidLockToken" xml:space="preserve">
    <value>Le instanceVersion passé à InstancePersistenceContext.BindAcquiredLock doit être égal à zéro si le fournisseur de persistance n'implémente pas une version de verrou, ou supérieur à zéro dans le cas contraire.</value>
  </data>
  <data name="InvalidLValueExpression" xml:space="preserve">
    <value>Expression L-value non valide.</value>
  </data>
  <data name="InvalidMergeMap" xml:space="preserve">
    <value>La table à la position '{0}' (de base zéro) pour l'ID d'activité '{1}' ne correspond pas à la ou les tables qui la précèdent. Assurez-vous que toutes les tables représentent des mises à jour successives d'une même définition de workflow.]D;]A;    ]D;]A;Détails de résolution : {2}</value>
  </data>
  <data name="InvalidMergeMapArgumentCount" xml:space="preserve">
    <value>Nombre d'arguments d'origine attendu = '{0}' Nombre réel = '{1}'.</value>
  </data>
  <data name="InvalidMergeMapArgumentsChanged" xml:space="preserve">
    <value>Modification inattendue des arguments (nom, direction, type ou ordre).</value>
  </data>
  <data name="InvalidMergeMapEnvironmentCount" xml:space="preserve">
    <value>Nombre d'arguments d'origine attendu = '{0}', Nombre de variables publiques = '{1}', Nombre de variables privées = '{2}'. Nombre réel d'arguments d'origine = '{3}', Nombre de variables publiques = '{4}', Nombre de variables privées = '{5}'.</value>
  </data>
  <data name="InvalidMergeMapForImplementation" xml:space="preserve">
    <value>ForImplementation attendu = '{0}', Réel = '{1}'.</value>
  </data>
  <data name="InvalidMergeMapMemberCount" xml:space="preserve">
    <value>Nombre de membres d'origine prévu = '{0}', Réel = '{1}'.</value>
  </data>
  <data name="InvalidMetadataValue" xml:space="preserve">
    <value>La valeur spécifiée pour la propriété de métadonnées '{0}' doit être de type {1}.</value>
  </data>
  <data name="InvalidNullAsyncResult" xml:space="preserve">
    <value>Une valeur Null a été retournée à partir d'une méthode 'Begin' asynchrone ou passée à AsyncCallback. Les implémentations 'Begin' asynchrones doivent retourner un IAsyncResult non Null et passer le même objet IAsyncResult que le paramètre à AsyncCallback.</value>
  </data>
  <data name="InvalidOriginalWorkflowDefinitionForImplementationMapCreation" xml:space="preserve">
    <value>L'OriginalWorkflowDefinition fourni au générateur de table n'est pas valide pour la création de table d'implémentation car il ne possède aucun enfant d'implémentation.</value>
  </data>
  <data name="InvalidParameterInfo" xml:space="preserve">
    <value>Les informations de paramètre numéro {0} ne sont pas valides dans le type de '{1}'.</value>
  </data>
  <data name="InvalidPrepareForRuntimeValidationSettings" xml:space="preserve">
    <value>Un workflow ne peut pas être préparé en vue de l'exécution si l'un des éléments SingleLevel, SkipValidatingRootConfiguration ou OnlyUseAdditionalConstraints est défini avec la valeur ValidationSettings.</value>
  </data>
  <data name="InvalidProperty" xml:space="preserve">
    <value>La propriété ({0}) n'est pas valide ou n'est pas définie.</value>
  </data>
  <data name="InvalidPropertyType" xml:space="preserve">
    <value>Impossible de résoudre le type '{0}' de la propriété '{1}'.</value>
  </data>
  <data name="InvalidReceiveStateForDU" xml:space="preserve">
    <value>L'état de la réception n'est pas pris en charge par la mise à jour de l'instance. La mise à jour est possible uniquement lorsque la réception est en attente d'un message de requête côté serveur.</value>
  </data>
  <data name="InvalidRootMergeMap" xml:space="preserve">
    <value>La table racine à la position '{0}' (de base zéro) ne correspond pas à la ou les tables qui la précèdent. Assurez-vous que toutes les tables représentent des mises à jour successives d'une même définition de workflow.]D;]A;    ]D;]A;Détails de résolution : {1}</value>
  </data>
  <data name="InvalidRunnableInstancesDetectionPeriod" xml:space="preserve">
    <value>La période de détection des instances exécutables fournie {0} est inférieure à la période minimale autorisée {1}.</value>
  </data>
  <data name="InvalidRuntimeState" xml:space="preserve">
    <value>La valeur fournie n'est pas un été runtime valide.</value>
  </data>
  <data name="InvalidSemaphoreExit" xml:space="preserve">
    <value>La méthode de synchronisation de l'objet a été appelée à partir d'un bloc de code non synchronisé.</value>
  </data>
  <data name="InvalidServiceImplementation" xml:space="preserve">
    <value>WorkflowServiceHost requiert que le serviceImplementation fourni soit un Activity ou un WorkflowService.</value>
  </data>
  <data name="InvalidSourceLocationColumn" xml:space="preserve">
    <value>Le numéro de la colonne doit être supérieur à 0 (base 1). {0} = {1} n'est pas valide.</value>
  </data>
  <data name="InvalidSourceLocationLineNumber" xml:space="preserve">
    <value>Le numéro de ligne doit être supérieur à 0 (base 1). {0} = {1} n'est pas valide.</value>
  </data>
  <data name="InvalidStateForAsyncCallback" xml:space="preserve">
    <value>Le IAsyncResult passé dans le rappel asynchrone n'a pas un AsyncState valide.</value>
  </data>
  <data name="InvalidStateInAsyncResult" xml:space="preserve">
    <value>Le contexte d'état de résultat asynchrone fourni n'est pas valide.</value>
  </data>
  <data name="InvalidTypeConverterUsage" xml:space="preserve">
    <value>Utilisation TypeConverter non valide.</value>
  </data>
  <data name="InvalidTypeForArgument" xml:space="preserve">
    <value>Le type spécifié pour l'argument dans la collection '{0}' à la position {1} ne correspond pas au type attendu. Le type spécifié est '{2}' et le type attendu '{3}'.</value>
  </data>
  <data name="InvalidUnhandledExceptionAction" xml:space="preserve">
    <value>Le UnhandledExceptionAction retourné est hors limites. Il doit s'agir d'une valeur Abort, Cancel ou Terminate.</value>
  </data>
  <data name="InvalidUpdatedWorkflowDefinitionForImplementationMapCreation" xml:space="preserve">
    <value>L'UpdatedWorkflowDefinition fourni au générateur de table n'est pas valide pour la création de table d'implémentation car il ne possède aucun enfant d'implémentation.</value>
  </data>
  <data name="InvalidUpdateMap" xml:space="preserve">
    <value>La table de mise à jour ne correspond pas à la définition de workflow. Assurez-vous qu'il s'agit de la bonne table et que la table sérialisée n'a pas été modifiée manuellement.]D;]A;    ]D;]A;Détails de résolution : {0}</value>
  </data>
  <data name="InvalidVisualBasicSettingsValue" xml:space="preserve">
    <value>La valeur de la propriété Settings n'est pas valide. Affectez à la propriété Settings une chaîne vide ou la chaîne « Références d'assembly et espaces de noms importés sérialisés en tant qu'espaces de noms XML ».</value>
  </data>
  <data name="InvalidXamlMember" xml:space="preserve">
    <value>'{0}' n'est pas un identificateur valide dans XAML.</value>
  </data>
  <data name="InvokedMethodThrewException" xml:space="preserve">
    <value>Une exception a été levée dans la méthode appelée par l'activité '{0}'. {1}</value>
  </data>
  <data name="InvokeMethodDoesNotUseAsyncPattern" xml:space="preserve">
    <value>InvokeMethod '{0}' - la méthode n'utilise pas un modèle asynchrone.</value>
  </data>
  <data name="InvokeMethodIsNotStatic" xml:space="preserve">
    <value>InvokeMethod '{0}' - la méthode n'est pas statique.</value>
  </data>
  <data name="InvokeMethodIsStatic" xml:space="preserve">
    <value>InvokeMethod '{0}' - la méthode est statique.</value>
  </data>
  <data name="InvokeMethodUseAsyncPattern" xml:space="preserve">
    <value>InvokeMethod '{0}' - la méthode utilise un modèle asynchrone de '{1}' et '{2}'.</value>
  </data>
  <data name="IsolationLevelValidation" xml:space="preserve">
    <value>Le IsolationLevel d'une activité TransactionScope imbriquée doit être égal à celui de son parent.</value>
  </data>
  <data name="ITextExpressionParameterMustBeActivity" xml:space="preserve">
    <value>Le paramètre 'expression' doit être de type Activity.</value>
  </data>
  <data name="KeyAlreadyAssociated" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé l'association d'une clé à une instance à laquelle la clé était déjà associée.</value>
  </data>
  <data name="KeyAlreadyCompleted" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé la fin d'une clé qui était déjà terminée.</value>
  </data>
  <data name="KeyAlreadyUnassociated" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé la dissociation d'une clé qui n'était ni associée à l'instance actuelle, ni terminée.</value>
  </data>
  <data name="KeyCollectionUpdatesNotAllowed" xml:space="preserve">
    <value>La mutation d'une collection de clés dérivée d'un dictionnaire n'est pas autorisée.</value>
  </data>
  <data name="KeyCollisionDefault" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue par une collision de clés.</value>
  </data>
  <data name="KeyCollisionSpecific" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue par une collision de clés. La clé d'instance avec la valeur '{1}' n'a pas pu être associée à l'instance '{0}' car elle est déjà associée à une autre instance, '{2}'.</value>
  </data>
  <data name="KeyCollisionSpecificKeyOnly" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue par une collision de clés. La clé d'instance avec la valeur '{0}' n'a pas pu être associée à l'instance, car elle est déjà associée une autre instance.</value>
  </data>
  <data name="KeyCompleteDefault" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue car la clé d'instance est déjà terminée.</value>
  </data>
  <data name="KeyCompleteSpecific" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue car la clé d'instance '{0}' est déjà terminée.</value>
  </data>
  <data name="KeyNotAssociated" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé la fin ou la modification d'une clé qui n'est pas associée à l'instance actuelle.</value>
  </data>
  <data name="KeyNotCompleted" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé la dissociation d'une clé qui n'était pas encore terminée.</value>
  </data>
  <data name="KeyNotFoundInDictionary" xml:space="preserve">
    <value>La clé donnée était absente du dictionnaire.</value>
  </data>
  <data name="KeyNotReadyDefault" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue car la clé d'instance n'était pas associée à une instance. Cela peut se produire à la suite du nettoyage de l'instance ou de la clé, ou si la clé n'est pas valide. La clé peut ne pas être valide si le message à partir duquel elle a été générée a été envoyé à un moment qui ne convenait pas ou s'il contenait des données de corrélation incorrectes.</value>
  </data>
  <data name="KeyNotReadySpecific" xml:space="preserve">
    <value>L'exécution d'un InstancePersistenceCommand a été interrompue car la clé d'instance '{0}' n'était pas associée à une instance. Cela peut se produire à la suite du nettoyage de l'instance ou de la clé, ou si la clé n'est pas valide. La clé peut ne pas être valide si le message à partir duquel elle a été générée a été envoyé à un moment qui ne convenait pas ou s'il contenait des données de corrélation incorrectes.</value>
  </data>
  <data name="LambdaExpressionReturnTypeInvalid" xml:space="preserve">
    <value>Le type de retour de l'expression lambda fournie ne doit être ni Null, ni Void.</value>
  </data>
  <data name="LambdaExpressionTypeRequired" xml:space="preserve">
    <value>L'expression fournie doit être une LambdaExpression. </value>
  </data>
  <data name="LambdaNotXamlSerializable" xml:space="preserve">
    <value>Ce workflow contient des expressions lambda spécifiées dans le code. Ces expressions ne peuvent pas être sérialisées en XAML. Pour cela, utilisez VisualBasicValue/VisualBasicReference ou ExpressionServices.Convert(lambda). Cela convertira les expressions lambda en activités d'expressions.</value>
  </data>
  <data name="LineNumberTooLarge" xml:space="preserve">
    <value>Le nombre de lignes spécifié pour l'activité {0} est trop important pour être pris en charge en mode de confiance partielle</value>
  </data>
  <data name="LiteralsMustBeValueTypesOrImmutableTypes" xml:space="preserve">
    <value>Un littéral ne prend en charge que les types valeur et le type immuable {0}. Impossible d'utiliser le type {1} en tant que littéral.</value>
  </data>
  <data name="LoadedWriteOnlyValue" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé le chargement de InstanceValue avec InstanceValueOptions.WriteOnly défini. Les valeurs en écriture seule ne doivent pas être chargées.</value>
  </data>
  <data name="LoadingAborted" xml:space="preserve">
    <value>Abandon d'une tentative de chargement d'une instance.</value>
  </data>
  <data name="LoadingWorkflowApplicationRequiresInstanceStore" xml:space="preserve">
    <value>WorkflowApplication requiert de définir un InstanceStore valide avant que Load ou LoadRunnableInstance puissent être appelés.</value>
  </data>
  <data name="LoadOpAssociateKeysCannotContainLookupKey" xml:space="preserve">
    <value>Si LoadWorkflowByInstanceKeyCommand.AssociateLookupKeyToInstanceId n'est pas spécifié, LookupInstanceKey doit être déjà associé à une instance afin d'éviter l'échec de LoadWorkflowByInstanceKeyCommand. Par conséquent, LookupInstanceKey ne doit pas être spécifié dans la collection InstanceKeysToAssociate si AssociateLookupKeyToInstanceId n'est pas défini.</value>
  </data>
  <data name="LoadOpFreeKeyRequiresAcceptUninitialized" xml:space="preserve">
    <value>Si LoadByKeyOperation.InstanceIdForFreeKey est spécifié, AcceptUninitializedInstance doit avoir la valeur True. Si la clé est libre, elle est associée à une instance non initialisée avec l'ID d'instance fourni.</value>
  </data>
  <data name="LoadOpKeyMustBeValid" xml:space="preserve">
    <value>La clé utilisée pour rechercher une instance, LoadByKeyOperation.LookupKey, ne doit pas contenir que des zéros, par exemple Guid.Empty.</value>
  </data>
  <data name="LocationExpressionCouldNotBeResolved" xml:space="preserve">
    <value>L'expression Location '{0}' n'a pas pu être résolue en variable ou propriété. Vérifiez que l'expression location est résolue en Variable ou Property défini dans la hiérarchie de l'étendu.</value>
  </data>
  <data name="LocationTypeMismatch" xml:space="preserve">
    <value>Impossible de récupérer l'emplacement nommé '{0}' en tant que Location de type '{1}', car il s'agit d'un Location de type '{2}'. Les types doivent correspondre exactement, car un emplacement fournit un accès en lecture et en écriture.</value>
  </data>
  <data name="LockRetryTimeout" xml:space="preserve">
    <value>Expiration du délai d'attente lors de la tentative d'acquisition du verrou d'instance. L'opération ne s'est pas terminée dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'attente plus long.</value>
  </data>
  <data name="LockTimeoutExceptionMessage" xml:space="preserve">
    <value>Impossible de revendiquer un verrou dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'attente plus long.</value>
  </data>
  <data name="MapEntryNotFound" xml:space="preserve">
    <value>Entrée de table de mise à jour introuvable pour l'activité '{0}'.</value>
  </data>
  <data name="MarkCanceledOnlyCallableIfCancelRequested" xml:space="preserve">
    <value>Seules les activités qui doivent être annulées peuvent appeler MarkCanceled. Vérifiez ActivityInstance.HasCancelBeenRequested avant d'appeler cette méthode.</value>
  </data>
  <data name="MaximumRetriesExceededForSqlCommand" xml:space="preserve">
    <value>Abandon des tentatives d'exécution d'une commande SQL, le nombre maximal de tentatives ayant été atteint.</value>
  </data>
  <data name="MaxInstancesExceeded" xml:space="preserve">
    <value>Le système a atteint la limite définie pour la limitation des 'MaxConcurrentInstances'. La limite a été définie sur {0}. La valeur de limitation peut être modifiée en modifiant l'attribut 'maxConcurrentInstances' de l'élément serviceThrottle ou en modifiant la propriété 'MaxConcurrentInstances' à l'aide du comportement ServiceThrottlingBehavior.</value>
  </data>
  <data name="MaxPendingMessagesPerChannelExceeded" xml:space="preserve">
    <value>La limitation 'MaxPendingMessagesPerChannel' de '{0}' a été atteinte. Pour accroître cette limite, modifiez la propriété MaxPendingMessagesPerChannel sur BufferedReceiveServiceBehavior.</value>
  </data>
  <data name="MaxPendingMessagesPerChannelMustBeGreaterThanZero" xml:space="preserve">
    <value>La valeur de la limitation doit être supérieure à zéro. Pour la désactiver, définissez-la sur Int32.MaxValue.</value>
  </data>
  <data name="MayBindLockCommandShouldValidateOwner" xml:space="preserve">
    <value>InstancePersistenceCommand qui retourne la valeur True à partir de AutomaticallyAcquiringLock doit également remplacer Validate pour lever un InvalidOperationException si la commande est exécutée à l'aide d'un InstanceHandle non lié à un InstanceOwner.</value>
  </data>
  <data name="MemberCannotBeNull" xml:space="preserve">
    <value>'{0}' dans l'activité {1} '{2}' ne peut pas être Null.</value>
  </data>
  <data name="MemberIsReadOnly" xml:space="preserve">
    <value>Le membre '{0}' de type '{1}' est en lecture seule. Il ne peut pas s'agir d'une LValue.</value>
  </data>
  <data name="MemberNotFound" xml:space="preserve">
    <value>Le membre nommé '{0}' est introuvable dans le type '{1}'.</value>
  </data>
  <data name="MemberNotSupportedByActivityXamlServices" xml:space="preserve">
    <value>ActivityXamlServices a rencontré un membre ({0}) qui n'est pas pris en charge par DynamicActivity.</value>
  </data>
  <data name="MessageCannotBeEmpty" xml:space="preserve">
    <value>Le contenu du message est Null, ce qui ne correspond pas à l'opération '{0}' du contrat '{1}'</value>
  </data>
  <data name="MessageContentCannotHaveMoreThanOneParameter" xml:space="preserve">
    <value>L'opération '{0}' du contrat implémenté '{1}' ne peut pas contenir plusieurs paramètres pour le contrat de message.</value>
  </data>
  <data name="MessageHeaderNotSupported" xml:space="preserve">
    <value>Les en-têtes de message personnalisés de MessageDescription ne sont pas pris en charge. Utilisez un type décoré par MessageContract dans l'opération '{0}' du contrat '{1}'.</value>
  </data>
  <data name="MessagePropertyIsNotSupported" xml:space="preserve">
    <value>Les propriétés de message personnalisées de MessageDescription ne sont pas prises en charge. Utilisez un type décoré par MessageContract dans l'opération '{0}' du contrat '{1}'.</value>
  </data>
  <data name="MessageTypeMismatch" xml:space="preserve">
    <value>La réception a spécifié un type System.ServiceModel.Channels.Message dans ReceiveMessageContent qui est différent du type de message '{0}' spécifié dans l'opération '{1}' du contrat implémenté '{2}'.</value>
  </data>
  <data name="MessageVersionInformationNotFound" xml:space="preserve">
    <value>Informations de version du message de réponse introuvables.</value>
  </data>
  <data name="MetadataCannotContainNullKey" xml:space="preserve">
    <value>Un nom Null a été fourni dans une collection nommée (dictionnaire) de InstanceValues. Null n'est pas un nom valide pour InstanceValue.</value>
  </data>
  <data name="MetadataCannotContainNullValue" xml:space="preserve">
    <value>Une valeur Null a été fournie dans une collection nommée (dictionnaire) de InstanceValues. Le nom fourni pour la valeur Null était {0}. Null n'est pas un InstanceValue valide. Pour spécifier une valeur Null, utilisez une instance de InstanceValue avec des données Null en passant Null au constructeur de InstanceValue. Pour indiquer qu'une valeur nommée doit être supprimée, utilisez InstanceValue.DeletedValue.</value>
  </data>
  <data name="MethodInfoRequired" xml:space="preserve">
    <value>La propriété Method de type '{0}' est requise.</value>
  </data>
  <data name="MethodNameRequired" xml:space="preserve">
    <value>La propriété Name de type '{0}' est requise.</value>
  </data>
  <data name="MissingArgument" xml:space="preserve">
    <value>L'Argument associée au nom '{0}' est Null dans la collection '{1}'.</value>
  </data>
  <data name="MissingBindingInEndpoint" xml:space="preserve">
    <value>Le point de terminaison avec Name='{0}' et ServiceContract '{1}' n'a pas de liaison. Indiquez une liaison pour ce point de terminaison.</value>
  </data>
  <data name="MissingBodyInWorkflowService" xml:space="preserve">
    <value>La propriété Body du WorkflowService actuel est Null. Fournissez un Body à ce WorkflowService.</value>
  </data>
  <data name="MissingDisplayNameInRootActivity" xml:space="preserve">
    <value>Le DisplayName de l'activité racine est vide. N'affectez pas au DisplayName de l'activité racine une valeur Null ou une chaîne vide, ou fournissez un Name pour le WorkflowService.</value>
  </data>
  <data name="MissingKnownTypes" xml:space="preserve">
    <value>Type connu '{0}' manquant pour l'opération '{1}' du contrat '{2}'.</value>
  </data>
  <data name="MissingNameProperty" xml:space="preserve">
    <value>L'argument de type '{0}' n'a pas de nom. La propriété Name doit être spécifiée pour les éléments de cette collection.</value>
  </data>
  <data name="MissingOperationName" xml:space="preserve">
    <value>Le nom de la propriété OperationName doit être défini dans l'activité '{0}'.</value>
  </data>
  <data name="MissingParameter" xml:space="preserve">
    <value>La collection de paramètres ne contient pas le paramètre '{0}' qui est spécifié dans l'opération '{1}' du contrat '{2}'.</value>
  </data>
  <data name="MissingServiceContractName" xml:space="preserve">
    <value>La propriété ServiceContractName doit être définie dans l'activité '{0}' avec OperationName='{1}'.</value>
  </data>
  <data name="MissingSetAccessorForIndexer" xml:space="preserve">
    <value>La propriété Indexer {0} pour le type {1} n'expose pas un accesseur setter.</value>
  </data>
  <data name="MissingUriInEndpoint" xml:space="preserve">
    <value>Le point de terminaison avec Name='{0}' et ServiceContract '{1}' a une propriété Uri Null ou vide. Indiquez un Uri pour ce point de terminaison.</value>
  </data>
  <data name="MisuseOfMessageContent" xml:space="preserve">
    <value>Un contrat de données est spécifié pour l'opération '{0}' du contrat '{1}'. Utilisez ReceiveParameterContent pour l'activité Receive et SendParameterContent pour l'activité SendReply pour correspondre à la définition du contrat.</value>
  </data>
  <data name="MisuseOfParameterContent" xml:space="preserve">
    <value>Un type de contrat de message est spécifié pour l'opération '{0}' du contrat '{1}'. Utilisez ReceiveMessageContent pour l'activité Receive et SendMessageContent pour l'activité SendReply pour correspondre à la définition du contrat. </value>
  </data>
  <data name="MovingActivitiesInStateBlockDU" xml:space="preserve">
    <value>StateMachine ne prend pas en charge la mise à jour dynamique si la propriété de l'activité dans la définition d'origine est réassignée à une autre propriété au sein de l'état ou sa transition.</value>
  </data>
  <data name="MultiDimensionalArraysNotSupported" xml:space="preserve">
    <value>Les tableaux multidimensionnels ne sont pas pris en charge.</value>
  </data>
  <data name="MultipleFlowNodesSharingSameChildBlockDU" xml:space="preserve">
    <value>L'organigramme ne prend pas en charge la mise à jour dynamique lorsque plusieurs FlowNode partagent une même activité enfant.</value>
  </data>
  <data name="MultipleLockOwnersNotSupported" xml:space="preserve">
    <value>SqlWorkflowInstanceStore ne prend pas en charge la création simultanée de plusieurs propriétaires de verrous. Définissez InstanceStore.DefaultInstanceOwner pour qu'il partage le magasin entre plusieurs applications.</value>
  </data>
  <data name="MultipleOverloadGroupsConfigured" xml:space="preserve">
    <value>Les groupes surchargés suivants sont configurés : {0}. Seul un groupe surchargé doit avoir ses arguments configurés.</value>
  </data>
  <data name="MustCallPrepareBeforeFinalize" xml:space="preserve">
    <value>La définition du workflow ne dispose pas d'une copie de sa définition d'origine. Avant de mettre à jour le workflow, appelez DynamicUpdateServices.PrepareForUpdate pour enregistrer une copie de la définition d'origine.</value>
  </data>
  <data name="MustCancelOldTimer" xml:space="preserve">
    <value>Vous devez annuler le minuteur antérieur avant d'en définir un nouveau.</value>
  </data>
  <data name="MustMatchReferenceExpressionReturnType" xml:space="preserve">
    <value>Les expressions de référence ne peuvent pas se terminer par une conversion. Le type de l'expression fournie doit correspondre exactement au type T de VisualBasicReference&lt;T&gt; ou de LambdaReference&lt;T&gt;.</value>
  </data>
  <data name="MustSetTransactionOnFirstCall" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Une transaction ambiante (System.Transactions.Transaction.Current) est définie sur le thread qui appelle InstancePersistenceContext.Execute ou InstancePersistenceContext.BeginExecute ; toutefois, des commandes ont déjà été exécutées au cours de cet épisode d'exécution sans qu'aucune transaction ne soit définie. Une transaction ambiante ne peut être définie que lors du premier appel de Execute ou BeginExecute (et uniquement si aucune autre transaction n'est déjà définie pour l'épisode).</value>
  </data>
  <data name="MustSpecifyConnectionStringOrName" xml:space="preserve">
    <value>La propriété connectionString ou la propriété connectionStringName doit être spécifiée.</value>
  </data>
  <data name="NameCollisionOnCollect" xml:space="preserve">
    <value>Une collision de nom a été détectée pour le nom '{0}' fourni par un participant de persistance de type '{1}'. Une valeur fournie par l'implémentation CollectValues du participant utilise le même nom qu'une autre valeur fournie par ce participant ou un participant de persistance différent. Corrigez le participant afin d'utiliser un nom différent pour éviter la collision ou supprimez le participant de la collection d'extensions du workflow.</value>
  </data>
  <data name="NameCollisionOnMap" xml:space="preserve">
    <value>Une collision de nom a été détectée pour le nom '{0}' fourni par un participant de persistance de type '{1}'. Une valeur fournie par l'implémentation MapValues du participant utilise le même nom qu'une autre valeur fournie par ce participant ou un participant de persistance différent. Corrigez le participant afin d'utiliser un nom différent pour éviter la collision ou supprimez le participant de la collection d'extensions du workflow.</value>
  </data>
  <data name="NativeActivityUpdateInstanceThrewException" xml:space="preserve">
    <value>L'activité a levé une exception depuis sa méthode UpdateInstance : {0}</value>
  </data>
  <data name="NAUCDisposed" xml:space="preserve">
    <value>NativeActivityUpdateContext n'est accessible qu'au sein de la portée de la fonction dans laquelle il a été passé.</value>
  </data>
  <data name="NewArrayBoundsRequiresIntegralArguments" xml:space="preserve">
    <value>'NewArrayBounds requiert des arguments intégraux.</value>
  </data>
  <data name="NewArrayRequiresArrayTypeAsResultType" xml:space="preserve">
    <value>Le type de résultat de l'activité 'NewArray' doit être un type tableau concret.</value>
  </data>
  <data name="NoAdditionalKeysOnInstanceIdLoad" xml:space="preserve">
    <value>Lors de l'utilisation de InstanceStore en tant que fournisseur de persistance, aucune clé supplémentaire ne peut être spécifiée au cours du chargement d'une instance par son ID d'instance.</value>
  </data>
  <data name="NoCAInSecondaryRoot" xml:space="preserve">
    <value>CompensableActivity ne peut pas être imbriqué dans le gestionnaire Compensation, Confirmation ou Cancellation d'un CompensableActivity parent.</value>
  </data>
  <data name="NoChangesMapQueryNotSupported" xml:space="preserve">
    <value>Les requêtes ne sont pas prises en charge dans les tables NoChanges.</value>
  </data>
  <data name="NoDynamicArgumentsInActivityDefinitionChange" xml:space="preserve">
    <value>Des modifications conflictuelles ont été apportées à cette activité par la table d'implémentation et la mise à jour actuelle. Les arguments de cette activité ont été modifiés lors des deux mises à jour.</value>
  </data>
  <data name="NoDynamicArgumentsInActivityDefinitionChangeRuntime" xml:space="preserve">
    <value>Des modifications conflictuelles ont été apportées à cette activité par une mise à jour d'implémentation et une mise à jour de workflow de taille plus importante. Les arguments de cette activité ont été modifiés lors des deux mises à jour.</value>
  </data>
  <data name="NoNamespace" xml:space="preserve">
    <value>Impossible de résoudre l'espace de noms '{0}:'.</value>
  </data>
  <data name="NonWASActivationNotSupported" xml:space="preserve">
    <value>SqlWorkflowInstanceStore prend uniquement en charge les services d'activation de Windows (WAS, Windows Activation Services).</value>
  </data>
  <data name="NoOutputLocationWasFound" xml:space="preserve">
    <value>Impossible de faire correspondre l'argument {0} à un emplacement de sortie valide.</value>
  </data>
  <data name="NoOverloadGroupsAreConfigured" xml:space="preserve">
    <value>Aucun des groupes surchargés n'a ses arguments d'activité requis/facultatifs configurés.</value>
  </data>
  <data name="NoPersistScopeCannotContainPersist" xml:space="preserve">
    <value>L'activité NoPersistScope « {0} » ne peut pas contenir d'activité de persistance « {1} ». </value>
  </data>
  <data name="NoPromotionsDefined" xml:space="preserve">
    <value>La promotion nommée {0} ne définit aucune promotion.</value>
  </data>
  <data name="NoRunnableInstances" xml:space="preserve">
    <value>Aucune instance de workflow exécutable n'a été trouvée dans le InstanceStore à charger.</value>
  </data>
  <data name="NoRuntimeTransactionExists" xml:space="preserve">
    <value>CompleteTransaction ne peut pas être appelé lorsque le runtime n'a pas de transaction active.</value>
  </data>
  <data name="NotSpecified" xml:space="preserve">
    <value>&lt;non spécifié&gt;</value>
  </data>
  <data name="NotSupportMoreThanOneParametersInMessageContract" xml:space="preserve">
    <value>Les opérations ne peuvent pas contenir plusieurs paramètres lors de l'utilisation de MessageContracts pour l'opération '{0}' du contrat '{1}'. Fournissez une définition de contrat valide. </value>
  </data>
  <data name="NullAssignedToValueType" xml:space="preserve">
    <value>Une valeur de type incorrect a été récupérée du magasin d'instances. Une valeur de type {0} était attendue, mais la valeur Null a été trouvée à la place.</value>
  </data>
  <data name="NullCorrelationHandleInInitializeCorrelation" xml:space="preserve">
    <value>CorrelationHandle ne peut pas être Null dans '{0}'.</value>
  </data>
  <data name="NullCorrelationHandleInMultipleQueryCorrelation" xml:space="preserve">
    <value>Au moins un queryCorrelationInitializer n'a pas de gestionnaire de corrélation défini. CorrelationHandle doit être spécifié lorsqu'il existe plusieurs queryCorrelationInitializer dans la collection CorrelationInitializers.</value>
  </data>
  <data name="NullKeyAlreadyPresent" xml:space="preserve">
    <value>Un élément avec une clé Null a déjà été ajouté.</value>
  </data>
  <data name="NullReferencedMemberAccess" xml:space="preserve">
    <value>Impossible de supprimer la référence de l'objet Null de type {0} par membre {1}.</value>
  </data>
  <data name="NullReplyMessageContractMismatch" xml:space="preserve">
    <value>Message de réponse Null reçu du serveur. Cela peut être dû à une incompatibilité de contrat entre le client et le serveur. Vérifiez que le workflow côté serveur est configuré pour l'opération à deux sens.</value>
  </data>
  <data name="OnCancelRequestedThrew" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Son gestionnaire d'annulation a levé une exception. Le gestionnaire a été spécifié via la méthode InstancePersistenceContext.SetCancellationHandler.</value>
  </data>
  <data name="OneOfTwoPropertiesMustBeSet" xml:space="preserve">
    <value>La propriété '{0}' ou '{1}' est requise pour '{2}' dans l'activité '{3}'.</value>
  </data>
  <data name="OnewayContractIsImplementedAsTwoWay" xml:space="preserve">
    <value>L'opération monodirectionnelle '{0}' du contrat '{1}' ne doit pas contenir d'activité SendReply. </value>
  </data>
  <data name="OnFreeInstanceHandleThrew" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Son implémentation de OnFreeInstanceHandle a levé une exception.</value>
  </data>
  <data name="OnlyBookmarkOwnerCanRemove" xml:space="preserve">
    <value>Les signets ne peuvent pas être supprimés par l'instance d'activité qui les a créés.</value>
  </data>
  <data name="OnlyOneOperationPerActivity" xml:space="preserve">
    <value>Une seule opération peut être active pour une activité à un moment donné. Une opération est déjà en cours.</value>
  </data>
  <data name="OnlyOneRequireTransactionContextAllowed" xml:space="preserve">
    <value>Le runtime essaie déjà de gérer un appel à RequireTransactionContext.</value>
  </data>
  <data name="OnlySingleCastDelegatesAllowed" xml:space="preserve">
    <value>Seuls les délégués non-multicast sont autorisés pour les événements WorkflowApplication. Le délégué fourni a une liste d'invocation d'une longueur supérieure à un.</value>
  </data>
  <data name="OperationAlreadyCompleted" xml:space="preserve">
    <value>L'opération est déjà terminée.</value>
  </data>
  <data name="OperationDoesNotExistInContract" xml:space="preserve">
    <value>L'opération '{0}' est absente du contrat dont le nom est '{1}' et l'espace de noms '{2}'.</value>
  </data>
  <data name="OperationFormatterAndFaultFormatterIncorrectlySet" xml:space="preserve">
    <value>OperationFormatter et FaultFormatter ne peuvent pas être définis tous les deux.</value>
  </data>
  <data name="OperationFormatterAndFaultFormatterNotSet" xml:space="preserve">
    <value>OperationFormatter et FaultFormatter ne peuvent pas être tous les deux Null.</value>
  </data>
  <data name="OperationHasSerializerBehavior" xml:space="preserve">
    <value>L'opération '{0}' dans le contrat '{1}' a déjà un comportement '{2}', c'est pourquoi un nouveau comportement ne peut pas être ajouté. Cela indique souvent que la méthode IOperationSerializer.ApplyToOperation a déjà été appelée pour cette opération.</value>
  </data>
  <data name="OperationIsNotImplemented" xml:space="preserve">
    <value>L'opération '{0}' du contrat '{1}' n'est pas implémentée dans le workflow.</value>
  </data>
  <data name="OperationNotAvailable" xml:space="preserve">
    <value>Impossible d'effectuer actuellement l'opération '{0}' sur l'instance de service avec l'identificateur '{1}'. Vérifiez que les opérations sont effectuées dans l'ordre correct et que la liaison utilisée fournit une garantie de livraison ordonnée.</value>
  </data>
  <data name="OperationNotFound" xml:space="preserve">
    <value>La réception correspondant au contrat {0} et à l'opération {1} est introuvable dans le WorkflowService par défaut. Assurez-vous que toutes les opérations des autres versions de WorkflowService sont d'abord ajoutées au WorkflowService par défaut.</value>
  </data>
  <data name="OptionalExtensionTypeMatchedMultiple" xml:space="preserve">
    <value>Plusieurs extensions de type '{0}' ont été trouvées. Seule une extension de ce type est autorisée lors de l'exécution de ce workflow.</value>
  </data>
  <data name="OriginalActivityReusedInModifiedDefinition" xml:space="preserve">
    <value>L'activité '{0}' de la définition d'origine ne peut pas être réutilisée par la définition mise à jour.</value>
  </data>
  <data name="OriginalVariableReusedInModifiedDefinition" xml:space="preserve">
    <value>La variable '{0}' de la définition d'origine ne peut pas être réutilisée dans la définition mise à jour.</value>
  </data>
  <data name="OriginCannotBeRuntimeIntrinsic" xml:space="preserve">
    <value>L'objet '{0}' ne peut pas être utilisé comme origine car il s'agit déjà d'un élément de définition de workflow (Activity, ActivityDelegate, Argument ou LocationReference).</value>
  </data>
  <data name="OutArgumentCannotHaveInputValue" xml:space="preserve">
    <value>OutArgument '{0}' ne peut pas être configuré avec une valeur d'entrée. La clé '{0}' doit être supprimée du dictionnaire d'entrée.</value>
  </data>
  <data name="OutOfIdSpaceIds" xml:space="preserve">
    <value>Le nombre d'activité dans cet espace d'ID a dépassé Int32.MaxValue. Refactorisez certaines parties du workflow dans une nouvelle sous-classe Activity.</value>
  </data>
  <data name="OutOfInstanceIds" xml:space="preserve">
    <value>Seules les instances d'activité long.MaxValue peuvent être exécutées dans un workflow.</value>
  </data>
  <data name="OutOfInternalBookmarks" xml:space="preserve">
    <value>Seuls les signets internes long.MaxValue peuvent être générés pour un workflow.</value>
  </data>
  <data name="OutOfRangeSourceLocationEndColumn" xml:space="preserve">
    <value>Pour une ligne SourceLocation, endColumn doit être &gt;= startColumn (= {0}).</value>
  </data>
  <data name="OutOfRangeSourceLocationEndLine" xml:space="preserve">
    <value>endLine de SourceLocation doit être &gt;= startLine (= {0}).</value>
  </data>
  <data name="OutsideInstanceExecutionScope" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. La méthode {0} ne peut être appelée que durant le traitement d'une commande. N'essayez pas de conserver une instance de InstancePersistenceContext pour une utilisation ultérieure. Le InstancePersistenceContext fourni à TryCommand et BeginTryCommand ne peut être utilisé que durant le traitement de cette commande.</value>
  </data>
  <data name="OutsideTransactionalCommand" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a appelé la méthode {0} sur InstancePersistenceContext, qui nécessite une cohérence des transactions, dans le cadre de l'exécution d'une commande qui ne doit pas nécessiter de cohérence des transactions. Cela peut entraîner une altération des données. Cette erreur indique une implémentation de fournisseur de persistance non valide.</value>
  </data>
  <data name="OverloadGroupHasSubsets" xml:space="preserve">
    <value>Les groupes surchargés suivants sont un sous-ensemble d'un groupe '{0}': {1}. Un groupe surchargé ne peut pas être un sous-ensemble d'un autre.</value>
  </data>
  <data name="OverloadGroupsAreEquivalent" xml:space="preserve">
    <value>Les groupes surchargés suivants sont équivalents : {0}. Un seul groupe surchargé est nécessaire ici.</value>
  </data>
  <data name="OverloadingMethodMustBeStatic" xml:space="preserve">
    <value>La méthode pour surcharger un opérateur doit être statique.</value>
  </data>
  <data name="OverloadOnlyCallableFromWorkflowThread" xml:space="preserve">
    <value>Cette surcharge de méthode ne peut être appelée qu'un partir d'un thread de workflow.</value>
  </data>
  <data name="OwnerBelongsToWrongStore" xml:space="preserve">
    <value>Un InstanceOwner incorrect a été fourni. Le InstanceOwner fourni à une méthode InstanceStore doit appartenir au InstanceStore. Un objet InstanceOwner doit uniquement être utilisé avec le InstanceStore qui l'a créé.</value>
  </data>
  <data name="OwnerRequired" xml:space="preserve">
    <value>Le système de persistance d'instance n'a pas réussi à traiter un InstancePersistenceCommand non valide. La commande requiert un propriétaire d'instance, mais aucun propriétaire n'était lié à InstanceHandle.</value>
  </data>
  <data name="ParallelForEachRequiresNonNullValues" xml:space="preserve">
    <value>Les valeurs doivent être liées à une expression non Null avant que l'activité ParallelForEach '{0}' puisse être utilisée.</value>
  </data>
  <data name="ParameterNumberMismatch" xml:space="preserve">
    <value>Le paramètre '{0}' n'existe pas dans l'opération '{1}' du contrat '{2}'.</value>
  </data>
  <data name="ParameterPositionMismatch" xml:space="preserve">
    <value>Le paramètre '{0}' ne se trouve pas au bon endroit pour l'opération '{1}' du contrat '{2}'. Déplacez-le à la position '{3}' dans la collection des paramètres. </value>
  </data>
  <data name="ParameterTypeMismatch" xml:space="preserve">
    <value>Le type de paramètre '{0}' ne correspond pas au type '{1}' spécifié dans l'opération '{2}' du contrat implémenté '{3}'.</value>
  </data>
  <data name="PartialTrustPerformanceCounterNotEnabled" xml:space="preserve">
    <value>L'accès aux compteurs de performance est refusé. Il se peut que l'application s'exécute en confiance partielle. Vous devez soit désactiver les compteurs de performance, soit configurer l'application pour fonctionner en confiance totale.</value>
  </data>
  <data name="PauseWhenPersistableInvalidIfPersistable" xml:space="preserve">
    <value>PauseWhenPersistable ne peut être appelé que lorsque IsPersistable a la valeur false.</value>
  </data>
  <data name="PendingMessagesPerChannelRatio" xml:space="preserve">
    <value>Ratio des messages en attente par canal : {0}/{1}</value>
  </data>
  <data name="PermissionArgumentWrongType" xml:space="preserve">
    <value>Type de l'argument incorrect. Le type attendu est '{0}'.</value>
  </data>
  <data name="PersistenceInitializerThrew" xml:space="preserve">
    <value>Une implémentation de IPersistenceContextInitializer a levé une exception. Impossible de charger ou de créer une instance de service durable, par exemple WorkflowServiceInstance. La propriété InnerException contient l'exception d'origine.</value>
  </data>
  <data name="PersistencePipelineAbortThrew" xml:space="preserve">
    <value>L'implémentation Abort d'un participant de persistance de type '{0}' a levé une exception. Les exceptions ne doivent pas être levées à partir d'implémentations Abort.</value>
  </data>
  <data name="PersistenceProviderRequiredToPersist" xml:space="preserve">
    <value>Seules des instances de workflow configurées avec une extension PersistenceProvider peuvent être persistantes ou déchargées.</value>
  </data>
  <data name="PersistenceTooLateToEnlist" xml:space="preserve">
    <value>Il est trop tard pour une inscription dans la transaction. La validation ou l'abandon de cette dernière a déjà commencé.</value>
  </data>
  <data name="PersistenceViolationNoCreate" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Une nouvelle instance a été créée alors qu'un InstanceNotReadyException aurait dû être levé.</value>
  </data>
  <data name="PickBranchRequiresTrigger" xml:space="preserve">
    <value>Le déclencheur doit être défini avec que PickBranch '{0}' puisse être utilisé.</value>
  </data>
  <data name="PickBranchTriggerActionSwapped" xml:space="preserve">
    <value>Pick ne prend pas en charge la mise à jour dynamique lorsque les Trigger et Action d'un PickBranch sont échangés.</value>
  </data>
  <data name="PrepareForSerializationRequiresPersistability" xml:space="preserve">
    <value>PrepareForSerialization ne peut être appelé que lorsque IsPersistable a la valeur True.</value>
  </data>
  <data name="PrivateMembersHaveChanged" xml:space="preserve">
    <value>L'implémentation de cette activité a été modifiée (par l'ajout, la suppression ou la réorganisation d'enfants, de délégués, de variables ou d'arguments). La mise à jour dynamique ne prend en charge que les modifications d'implémentation spécifiées dans une table d'implémentation, indépendamment de la configuration publique de l'activité.</value>
  </data>
  <data name="PromotionAlreadyDefined" xml:space="preserve">
    <value>Le jeu de promotions {0} est déjà défini.</value>
  </data>
  <data name="PromotionTooManyDefined" xml:space="preserve">
    <value>Le jeu de promotions {0} a défini {1} {2} promotions, ce qui dépasse le nombre maximal de promotions autorisées qui est de {3}.</value>
  </data>
  <data name="PropertyCannotBeModified" xml:space="preserve">
    <value>La propriété {0} ne peut pas être modifiée une fois que SqlTrackingParticipant a commencé le traitement des enregistrements.</value>
  </data>
  <data name="PropertyMemberNotSupportedByActivityXamlServices" xml:space="preserve">
    <value>ActivityXamlServices a rencontré un membre x:Property ({0}) qui n'est pas pris en charge par DynamicActivityProperty.</value>
  </data>
  <data name="PropertyMismatch" xml:space="preserve">
    <value>'{0}' ne correspond pas à la propriété '{1}' de valeur '{2}' dans l'opération '{3}' du contrat '{4}'.</value>
  </data>
  <data name="PropertyReadOnlyInWorkflowDataContext" xml:space="preserve">
    <value>La propriété '{0}' est en lecture seule dans WorkflowDataContext.</value>
  </data>
  <data name="PropertyReferenceNotFound" xml:space="preserve">
    <value>PropertyReference ne peut pas résoudre la propriété '{0}'.</value>
  </data>
  <data name="ProtectionLevelIsNotSupported" xml:space="preserve">
    <value>Les paramètres ProtectionLevel personnalisés sont uniquement pris en charge via MessageContract. Spécifiez un type de MessageContract pour l'opération '{0}' du contrat implémenté '{1}'.</value>
  </data>
  <data name="ProtectionLevelNotSupported" xml:space="preserve">
    <value>Le workflow ne prend pas en charge les paramètres ProtectionLevel personnalisés en cas d'erreurs. Ne spécifiez pas de ProtectionLevel pour FaultContract pour l'opération '{0}' du contrat implémenté '{1}'.</value>
  </data>
  <data name="ProvidedStateInitializedForExecution" xml:space="preserve">
    <value>L'état du runtime a déjà été initialisé pour l'exécution et ne peut pas être mis à jour. Rechargez l'état à partir de la persistance.</value>
  </data>
  <data name="ProviderDoesNotSupportCommand" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore ne prend pas en charge la commande nommée {0}. Choisissez un autre fournisseur ou vérifiez que cette commande de persistance n'est pas en cours d'exécution.</value>
  </data>
  <data name="PublicChildrenChangeBlockDU" xml:space="preserve">
    <value>Cette activité ne prend pas en charge les modifications de ses enfants publics (ajout, suppression ou réorganisation d'Activities ou d'ActivityDelegates).</value>
  </data>
  <data name="PublicEnvironmentAccessToNonGenericActivity" xml:space="preserve">
    <value>L'accès à l'environnement public n'est possible que pour les activités dérivant de CodeActivity&lt;TResult&gt;, et non de CodeActivity.</value>
  </data>
  <data name="PublicMethodWithMatchingParameterDoesNotExist" xml:space="preserve">
    <value>'{0}' n'a pas de méthode '{1}' publique nommée '{2}' qui correspond aux types de paramètres, aux arguments de type génériques et aux contraintes de type génériques fournis à InvokeMethod '{3}'.</value>
  </data>
  <data name="PublicReferencesOnActivityRequiringArgumentResolution" xml:space="preserve">
    <value>L'activité '{0}' ne peut pas définir les arguments autres que l'argument intégré Result et déclarer en même temps un accès à des emplacements publics via CodeActivityPublicEnvironmentAccessor. Passez toutes les données à l'activité via les arguments ou via CodeActivityPublicEnvironmentAccessor.TryGetAccessToPublicLocation et TryGetReferenceToPublicLocation.</value>
  </data>
  <data name="QueryActivityIsInImplementation" xml:space="preserve">
    <value>Cette activité se trouve dans l'implémentation de l'activité composite '{0}'. Pour savoir si elle peut être mise à jour, utilisez la table d'implémentation de l'activité composite.</value>
  </data>
  <data name="QueryActivityIsNotInDefinition" xml:space="preserve">
    <value>Cette activité n'appartient ni à la définition de workflow d'origine, ni à celle mise à jour.</value>
  </data>
  <data name="QueryActivityIsPublic" xml:space="preserve">
    <value>Cette activité fait partie d'une définition de workflow racine. Pour savoir si elle peut être mise à jour, utilisez une table de mise à jour pour le workflow, au lieu de la table d'implémentation de l'activité composite '{0}'.</value>
  </data>
  <data name="QueryCorrelationInitializerCannotBeInitialized" xml:space="preserve">
    <value>Il n'y a pas de gestionnaire de corrélation disponible pour initialiser le QueryCorrelationInitializer. Cela est dû au fait qu'aucun gestionnaire de corrélation explicite n'est défini sur l'initialiseur de requête et qu'aucun gestionnaire n'est disponible dans la portée de corrélation."</value>
  </data>
  <data name="QueryCorrelationInitializerWithEmptyMessageQuerySet" xml:space="preserve">
    <value>L'activité avec DisplayName='{0}' et OperationName='{1}' a QueryCorrelationInitializer avec un MessageQuerySet vide.</value>
  </data>
  <data name="QueryVariableIsInImplementation" xml:space="preserve">
    <value>Cette variable se trouve dans l'implémentation de l'activité composite '{0}'. Pour savoir si elle peut être mise à jour, utilisez la table d'implémentation de l'activité composite.</value>
  </data>
  <data name="QueryVariableIsNotInDefinition" xml:space="preserve">
    <value>Cette variable n'appartient ni à la définition de workflow d'origine, ni à la celle mise à jour.</value>
  </data>
  <data name="QueryVariableIsNotPublic" xml:space="preserve">
    <value>Cette variable n'est pas publique. Seules les variables publiques peuvent être modifiées via une mise à jour dynamique.</value>
  </data>
  <data name="QueryVariableIsPublic" xml:space="preserve">
    <value>Cette variable fait partie de la définition de workflow racine. Pour savoir si elle peut être mise à jour, utilisez une table de mise à jour pour le workflow, au lieu d'une table d'implémentation pour l'activité composite '{0}'.</value>
  </data>
  <data name="QueuingSqlRetry" xml:space="preserve">
    <value>Mise en file d'attente d'une tentative SQL avec un retard de {0} millisecondes.</value>
  </data>
  <data name="ReadAccessToWriteOnlyPublicReference" xml:space="preserve">
    <value>L'activité '{0}' ne peut pas lire cette référence d'emplacement public car elle a été déclarée à l'aide d'ArgumentDirection.Out. Pour permettre la lecture et l'écriture, déclarez une référence à l'aide d'ArgumentDirection.InOut.</value>
  </data>
  <data name="ReadNotSupported" xml:space="preserve">
    <value>Lecture non prise en charge sur ce flux.</value>
  </data>
  <data name="ReadonlyNameScopeCannotBeUpdated" xml:space="preserve">
    <value>Impossible d'utiliser l'opération car l'implémentation de la portée de nom est en lecture seule.</value>
  </data>
  <data name="ReadonlyPropertyCannotBeSet" xml:space="preserve">
    <value>La propriété ou l'indexeur '{0}.{1}' ne peut pas être utilisé dans ce contexte, car l'accesseur set est inaccessible.</value>
  </data>
  <data name="ReceiveAndReceiveParametersHaveSameName" xml:space="preserve">
    <value>Deux Receives avec des types ReceiveContent différents ont les mêmes ServiceContractName et OperationName '{0}'.</value>
  </data>
  <data name="ReceiveContentChanged" xml:space="preserve">
    <value>Le contenu de cette activité de réception a été modifié entre un contenu sans type et un contenu avec type.</value>
  </data>
  <data name="ReceiveCorrelationInitializiersChanged" xml:space="preserve">
    <value>Les CorrelationInitializers de cette activité Receive ont été modifiés.</value>
  </data>
  <data name="ReceiveIsInTRSWhenTransactionFlowNotAllowed" xml:space="preserve">
    <value>Receive se trouve dans TransactedReceiveScope alors que TransactionFlowOption de l'opération '{0}' du contrat implémenté '{1}' a la valeur NotAllowed.</value>
  </data>
  <data name="ReceiveIsNotInTRS" xml:space="preserve">
    <value>L'opération '{0}' du contrat implémenté '{1}' nécessite la transmission de la transaction, mais l'activité Receive ne se trouve PAS dans TransactedReceiveScope.</value>
  </data>
  <data name="ReceiveMessageNeedsToPairWithSendMessageForTwoWayContract" xml:space="preserve">
    <value>L'activité Receive est configurée avec une opération demande/réponse '{0}', cependant, aucun SendReply n'est présent. Appariez Receive avec SendReply et effectuez une corrélation en utilisant CorrelationHandle.</value>
  </data>
  <data name="ReceiveNotWithinATransactedReceiveScope" xml:space="preserve">
    <value>L'activité Receive passée à une transaction n'était pas contenue dans un TransactedReceiveScope.</value>
  </data>
  <data name="ReceivePairedWithSendReplyAndSendReplyParameters" xml:space="preserve">
    <value>Un SendReply avec SendMessageContent et un SendReply avec SendParametersContent sont tous les deux associés au même Receive avec OperationName='{0}'. Cela n'est pas autorisé.</value>
  </data>
  <data name="ReceiveParametersContentDoesNotSupportMessage" xml:space="preserve">
    <value>L'activité avec DisplayName='{0}' a un argument nommé '{1}' qui est un Message ou un MessageContract. ReceiveParametersContent ne prend pas en charge Message ou MessageContract. La propriété de contenu doit être spécifiée en tant que ReceiveMessageContract pour Message ou un contenu MessageContract.</value>
  </data>
  <data name="ReceiveReplyRequestCannotBeNull" xml:space="preserve">
    <value>La propriété Request dans l'activité '{0}' ne peut pas être Null. Elle doit être définie à l'activité Send qui appartient à cette paire demande/réponse.</value>
  </data>
  <data name="ReferencedChildInIsNewlyAdded" xml:space="preserve">
    <value>Cette méthode ne peut pas être appelée pour les activités qui sont des références à des enfants importés. Vérifiez NativeActivityUpdateContext.IsReferenceToImportedChild avant d'appeler cette méthode.</value>
  </data>
  <data name="RegisteredBookmarkScopeRequired" xml:space="preserve">
    <value>Seules les portées de signet inscrites peuvent être utilisées pour créer des signets de portée.</value>
  </data>
  <data name="RelativeUriRequiresBinding" xml:space="preserve">
    <value>Le point de terminaison avec Name='{0}' et ServiceContract '{1}' utilise un URI relatif '{2}' qui ne peut pas être converti en URI absolu, car la propriété Binding du point de terminaison a la valeur Null. Définissez la propriété Binding ou changez l'URI relatif en URI absolu.</value>
  </data>
  <data name="RelativeUriRequiresHost" xml:space="preserve">
    <value>Le point de terminaison avec Name='{0}' et ServiceContract '{1}' utilise un URI relatif '{2}' qui ne peut pas être converti en URI absolu car l'argument hôte de la méthode GetAddress a la valeur Null. Fournissez l'instance hôte du service qui hébergera le point de terminaison ou changez l'URI relatif en URI absolu.</value>
  </data>
  <data name="RemovingTransitionsBlockDU" xml:space="preserve">
    <value>StateMachine ne prend pas en charge la mise à jour dynamique si une transaction est supprimée d'un état en cours d'exécution.</value>
  </data>
  <data name="RenewLockSystemError" xml:space="preserve">
    <value>Échec de l'extension de l'expiration du verrou ; l'expiration du verrou a déjà été passée ou le propriétaire de verrou a été supprimé. Abandon de SqlWorkflowInstanceStore.</value>
  </data>
  <data name="ReplyShouldNotIncludeRequestReplyHandle" xml:space="preserve">
    <value>L'activité '{0}' avec OperationName='{1}' ne doit pas inclure le handle demande/réponse dans les corrélations supplémentaires.</value>
  </data>
  <data name="RequestMustBeSpecified" xml:space="preserve">
    <value>L'argument Request doit être spécifié dans l'activité '{0}'.</value>
  </data>
  <data name="RequestReplyHandleShouldNotBePresentForOneWay" xml:space="preserve">
    <value>RequestReplyCorrelationInitializer ne doit pas être spécifié sur une activité Send ou Receive unidirectionnelle. Lors de l'initialisation de la corrélation RequestReply, Send doit être associé à une activité ReceiveReply et Receive doit être associé à une activité SendReply.</value>
  </data>
  <data name="RequiredArgumentValueNotSupplied" xml:space="preserve">
    <value>La valeur pour un argument d'activité '{0}' requis n'a pas été fournie.</value>
  </data>
  <data name="RequiredExtensionTypeNotFound" xml:space="preserve">
    <value>Une extension de type '{0}' doit être configurée pour exécuter ce workflow.</value>
  </data>
  <data name="RequiredVariableCoundNotBeExtracted" xml:space="preserve">
    <value>La variable {0} requise n'est pas disponible pour l'extraction dans l'activité : {1}.</value>
  </data>
  <data name="RequireExtensionOnlyAcceptsReferenceTypes" xml:space="preserve">
    <value>'{0}' est un type valeur. RequireExtension accepte uniquement les types référence.</value>
  </data>
  <data name="ResponseContextIsNotNull" xml:space="preserve">
    <value>ResponseContext n'est pas Null.</value>
  </data>
  <data name="ResultArgumentHasRequiredTypeAndDirection" xml:space="preserve">
    <value>Le RuntimeArgument nommé 'Result' fourni par l'auteur de l'activité doit avoir ArgumentDirection Out et un type {0}. Au lieu de cela, ArgumentDirection est égal à {1} et le type à {2}.</value>
  </data>
  <data name="ResultArgumentMustBeBoundToResultProperty" xml:space="preserve">
    <value>Le RuntimeArgument nommé 'Result' fourni par l'auteur de l'activité doit être lié à l'argument retourné par la propriété Result de l'activité.</value>
  </data>
  <data name="ResultArgumentMustBeSpecificType" xml:space="preserve">
    <value>Le Result OutArgument pour cette activité doit être un OutArgument de {0}.</value>
  </data>
  <data name="ResultCannotBeSetOnArgumentExpressions" xml:space="preserve">
    <value>Le Result OutArgument d'un Activity&lt;T&gt; ne peut pas être défini lorsque Activity&lt;T&gt; est utilisé comme expression de l'argument.</value>
  </data>
  <data name="ResultMustBeSpecified" xml:space="preserve">
    <value>L'argument Result doit être spécifié dans l'activité '{0}'.</value>
  </data>
  <data name="RethrowMustBeAPublicChild" xml:space="preserve">
    <value>Impossible d'utiliser l'activité Rethrow '{0}' dans un enfant privé d'une activité TryCatch. Rethrow n'est autorisé que sous les enfants publics d'une activité TryCatch.</value>
  </data>
  <data name="RethrowNotInATryCatch" xml:space="preserve">
    <value>L'activité Rethrow '{0}' doit être l'enfant d'un gestionnaire Catch d'une activité TryCatch.</value>
  </data>
  <data name="RetryingSqlCommandDueToSqlError" xml:space="preserve">
    <value>Nouvelle tentative d'exécution d'une commande SQL en raison du numéro d'erreur SQL {0}.</value>
  </data>
  <data name="ReturnTypeIncompatible" xml:space="preserve">
    <value>Incompatibilité de type. Le type de retour '{0}' de la méthode '{1}' la plus appropriée du type '{2}' n'est pas compatible avec l'argument 'Result' fourni à InvokeMethod '{3}' qui attend des valeurs de retour de type '{4}'.</value>
  </data>
  <data name="ReturnValueMissing" xml:space="preserve">
    <value>Le paramètre de valeur de retour de type '{0}' est manquant pour l'opération '{1}' du contrat '{2}'. </value>
  </data>
  <data name="RootActivityAlreadyAssociatedWithInstance" xml:space="preserve">
    <value>L'activité avec le nom d'affichage '{0}' a déjà été associée à une instance. Une fois associées à une instance, les métadonnées d'une activité ne peuvent pas être manipulées. Cette erreur peut également indiquer que vous tentez d'exécuter un workflow dont l'activité racine fait partie d'un autre workflow.</value>
  </data>
  <data name="RootActivityCannotBeReferenced" xml:space="preserve">
    <value>L'activité '{0}' n'est pas une activité racine et ne peut pas être référencée par l'activité '{1}'.</value>
  </data>
  <data name="RootArgumentViolationsFound" xml:space="preserve">
    <value>Les valeurs fournies pour les arguments de l'activité racine ne répondent pas aux spécifications de l'activité racine :</value>
  </data>
  <data name="RootArgumentViolationsFoundNoInputs" xml:space="preserve">
    <value>Les paramètres d'argument de l'activité racine sont incorrects. Corrigez la définition de workflow ou indiquez des valeurs d'entrée pour corriger ces erreurs :</value>
  </data>
  <data name="RunnableInstancesDetectionError" xml:space="preserve">
    <value>Échec de la détection des instances exécutables en raison de l'exception suivante</value>
  </data>
  <data name="RuntimeArgumentBindingInvalid" xml:space="preserve">
    <value>RuntimeArgument '{0}' fait référence à un argument qui à son tour est lié à RuntimeArgument nommé '{1}'. Vérifiez que l'objet Argument n'est pas lié à plusieurs objets RuntimeArgument ou partagé par plusieurs propriétés Argument publiques.</value>
  </data>
  <data name="RuntimeArgumentChangeBlockDU" xml:space="preserve">
    <value>La mise à jour dynamique ne sera pas autorisée dans l'activité '{0}' car ses RuntimeArguments ont été modifiés. Pour permettre la mise à jour dynamique au sein de cette activité, aucun RuntimeArgument ne peut être ajouté, supprimé ou réorganisé. De même, leurs nom, type et direction ne peuvent pas être modifiés.</value>
  </data>
  <data name="RuntimeArgumentNotCreated" xml:space="preserve">
    <value>L'instance RuntimeArgument n'a pas encore été créée.</value>
  </data>
  <data name="RuntimeArgumentNotOpen" xml:space="preserve">
    <value>L'argument '{0}' est inutilisable. Vérifiez qu'il est déclaré pour une activité.</value>
  </data>
  <data name="RuntimeDelegateArgumentDirectionIncorrect" xml:space="preserve">
    <value>La direction d'un RuntimeDelegateArgument doit correspondre à la direction du DelegateArgument auquel il est lié.</value>
  </data>
  <data name="RuntimeDelegateArgumentTypeIncorrect" xml:space="preserve">
    <value>Le type d'un RuntimeDelegateArgument doit correspondre au type du DelegateArgument auquel il est lié.</value>
  </data>
  <data name="RuntimeOperationInProgress" xml:space="preserve">
    <value>Une opération du runtime est déjà en cours. L'accès à WorkflowInstance doit être synchronisé par l'appelant.</value>
  </data>
  <data name="RuntimeRunning" xml:space="preserve">
    <value>Le runtime de workflow exécute actuellement un workflow et les opérations ne peuvent être exécutées que lorsqu'il est interrompu. L'accès à WorkflowInstance doit être synchronisé par l'appelant.</value>
  </data>
  <data name="RuntimeTransactionAlreadyExists" xml:space="preserve">
    <value>Le runtime a déjà été configuré avec une transaction. Une seule transaction est autorisée à la fois.</value>
  </data>
  <data name="RuntimeTransactionComplete" xml:space="preserve">
    <value>La transaction runtime s'est terminée en état '{0}'.</value>
  </data>
  <data name="RuntimeTransactionCompletionRequested" xml:space="preserve">
    <value>L'activité '{0}', DisplayName : '{1}', InstanceID : '{2}' a planifié la fin de la transaction runtime.</value>
  </data>
  <data name="RuntimeTransactionHandleNotRegisteredAsExecutionProperty" xml:space="preserve">
    <value>La méthode '{0}' ne peut être appelée que si l'objet RuntimeTransactionHandle correspondant est inscrit en tant que propriété d'exécution.</value>
  </data>
  <data name="RuntimeTransactionIsSuppressed" xml:space="preserve">
    <value>Cette opération n'est pas valide lorsque la transaction runtime est supprimée. La transaction runtime est supprimée car la propriété SuppressTransaction a été définie sur le RuntimeTransactionHandle dans l'environnement actuel.</value>
  </data>
  <data name="RuntimeTransactionSet" xml:space="preserve">
    <value>La transaction runtime a été définie par l'activité '{0}', DisplayName : '{1}', InstanceID : '{2}'. Exécution isolée à l'activité '{3}', DisplayName : '{4}', InstanceID : '{5}'.</value>
  </data>
  <data name="SameUserStateUsedForMultipleInvokes" xml:space="preserve">
    <value>Impossible d'utiliser la même instance d'état utilisateur pour des appels d'activité concurrents.</value>
  </data>
  <data name="SavingActivityToXamlNotSupported" xml:space="preserve">
    <value>L'enregistrement de DynamicActivity ou de Activity.Implementation en XAML n'est pas pris en charge. Si vous tentez de construire un workflow paramétré et de l'enregistrer en XAML, utilisez la classe ActivityBuilder.</value>
  </data>
  <data name="SavingFuncToXamlNotSupported" xml:space="preserve">
    <value>L'enregistrement d'une Func&lt;T&gt; générale au format XAML n'est pas pris en charge. Pour convertir un objet en une Func sérialisable, sérialisez l'objet au format XAML, puis appelez ActivityXamlServices.CreateFactory.</value>
  </data>
  <data name="ScheduleBookmarkWorkItem" xml:space="preserve">
    <value>BookmarkWorkItem a été planifié pour l'activité '{0}', DisplayName : '{1}', InstanceID : '{2}'. BookmarkName : {3}, BookmarkScope : {4}.</value>
  </data>
  <data name="ScheduleCancelActivityWorkItem" xml:space="preserve">
    <value>CancelActivityWorkItem a été planifié pour l'activité '{0}', DisplayName : '{1}', InstanceID : '{2}'.</value>
  </data>
  <data name="ScheduleCompletionWorkItem" xml:space="preserve">
    <value>CompletionWorkItem a été planifié pour l'activité '{0}' parent, DisplayName : '{1}', InstanceID : '{2}'. Activité '{3}' terminée, DisplayName : '{4}', InstanceID : '{5}'.</value>
  </data>
  <data name="ScheduleExecuteActivityWorkItem" xml:space="preserve">
    <value>ExecuteActivityWorkItem a été planifié pour l'activité '{0}', DisplayName : '{1}', InstanceID : '{2}'.</value>
  </data>
  <data name="ScheduleFaultWorkItem" xml:space="preserve">
    <value>FaultWorkItem a été planifié pour l'activité '{0}', DisplayName : '{1}', InstanceId : '{2}'. L'exception a été propagée à partir de l'activité '{3}', DisplayName : '{4}', InstanceId : '{5}'.</value>
  </data>
  <data name="ScheduleRuntimeWorkItem" xml:space="preserve">
    <value>Un élément de travail runtime a été planifié pour l'activité '{0}', DisplayName : '{1}', InstanceId : '{2}'.</value>
  </data>
  <data name="ScheduleTransactionContextWorkItem" xml:space="preserve">
    <value>TransactionContextWorkItem a été planifié pour l'activité '{0}', DisplayName : '{1}', InstanceId : '{2}'.</value>
  </data>
  <data name="SchemaContextFromBeforeInitializeComponentXBTExtensionCannotBeGeneric" xml:space="preserve">
    <value>Le nom de la classe de l'application auxiliaire XAML généré par l'extension de tâche de génération XAML BeforeInitializeComponent ({0}) ne peut pas être générique. La ressource ne peut pas avoir été générée par l'extension de tâche de génération XAML BeforeInitializeComponent. Régénérez le projet.</value>
  </data>
  <data name="SchemaContextFromBeforeInitializeComponentXBTExtensionNotFound" xml:space="preserve">
    <value>Le nom de la classe de l'application auxiliaire XAML généré par l'extension de tâche de génération XAML BeforeInitializeComponent ({0}) est introuvable. Régénérez le projet.</value>
  </data>
  <data name="SeekNotSupported" xml:space="preserve">
    <value>Recherche non prise en charge sur ce flux.</value>
  </data>
  <data name="SendActivityCorrelationHandleNotFound" xml:space="preserve">
    <value>Impossible de trouver un gestionnaire de corrélation valide associé à l'activité Send nommée « {0} ».</value>
  </data>
  <data name="SendMessageChannelCacheMiss" xml:space="preserve">
    <value>Échec de SendMessageChannelCache</value>
  </data>
  <data name="SendMessageNeedsToPairWithReceiveMessageForTwoWayContract" xml:space="preserve">
    <value>L'activité Send est configurée avec une opération demande/réponse '{0}', cependant, aucune activité ReceiveReply n'est présente. Appariez Send avec ReceiveReply et effectuez une corrélation en utilisant un CorrelationHandle.</value>
  </data>
  <data name="SendNotSupported" xml:space="preserve">
    <value>Envoi non pris en charge.</value>
  </data>
  <data name="SendParametersContentDoesNotSupportMessage" xml:space="preserve">
    <value>L'activité avec DisplayName='{0}' a un argument nommé '{1}' qui est un Message ou un MessageContract. SendParametersContent ne prend pas en charge Message ou MessageContract. La propriété de contenu doit être spécifiée en tant que SendMessageContract pour Message ou un contenu MessageContract.</value>
  </data>
  <data name="SendReceiveExtensionNotFound" xml:space="preserve">
    <value>Impossible de trouver SendReceiveExtension. Assurez-vous que l'application hébergeant le flux de travail fournit une implémentation de l'extension.</value>
  </data>
  <data name="SendRepliesHaveSameFaultTypeDifferentAction" xml:space="preserve">
    <value>Deux activités SendReply ont le même type d'erreur mais une action différente.</value>
  </data>
  <data name="SendReplyRequestCannotBeNull" xml:space="preserve">
    <value>La propriété Request dans l'activité '{0}' ne peut pas être Null. Elle doit être définie à l'activité Receive qui appartient à cette paire demande/réponse.</value>
  </data>
  <data name="SendWithUninitializedCorrelatesWith" xml:space="preserve">
    <value>L'activité ayant pour nom d'opération '{0}' a un gestionnaire CorrelatesWith qui n'est pas initialisé.</value>
  </data>
  <data name="SequenceDuplicateReferences" xml:space="preserve">
    <value>Sequence ne prend pas en charge la mise à jour dynamique lorsqu'il contient plusieurs références à un même enfant importé.</value>
  </data>
  <data name="ServiceEndpointAdded" xml:space="preserve">
    <value>Un point de terminaison du service a été ajouté pour l'adresse '{0}', la liaison '{1}' et le contrat '{2}'.</value>
  </data>
  <data name="ServiceHostExtensionAborted" xml:space="preserve">
    <value>L'opération ne peut pas être achevée, car l'hôte du service ou l'une de ses extensions a été annulé.</value>
  </data>
  <data name="ServiceHostExtensionImmutable" xml:space="preserve">
    <value>Une opération a été tentée à l'aide d'une extension d'hôte de service qui n'est autorisée qu'après l'ouverture de l'hôte du service.</value>
  </data>
  <data name="ServiceInstanceTerminated" xml:space="preserve">
    <value>L'instance de service avec l'identificateur '{0}' a été arrêtée.</value>
  </data>
  <data name="ServiceInstanceUnloaded" xml:space="preserve">
    <value>L'instance de service avec l'identificateur '{0}' a été déchargée.</value>
  </data>
  <data name="ServiceMetadataBehaviorNotFoundForServiceMetadataEndpoint" xml:space="preserve">
    <value>Nom de contrat 'IMetadataExchange' introuvable dans la liste des contrats implémentés par le service {0}. Ajoutez un ServiceMetadataBehavior au fichier de configuration ou directement à WorkflowServiceHost pour activer la prise en charge de ce contrat.</value>
  </data>
  <data name="SetupOrCleanupWorkflowThreadThrew" xml:space="preserve">
    <value>Un IExecutionProperty a levé une exception lors de la configuration ou du nettoyage du thread de workflow. Pour plus d'informations, consultez l'exception interne.</value>
  </data>
  <data name="SFxTaskNotStarted" xml:space="preserve">
    <value>L'instance de tâche donnée n'a pas encore démarré. Les instances de tâche doivent être démarrées avant de pouvoir être retournées à partir d'opération.</value>
  </data>
  <data name="ShipAssertExceptionMessage" xml:space="preserve">
    <value>Une défaillance inattendue s'est produite. Les applications ne doivent pas essayer de gérer cette erreur. À des fins de diagnostics, ce message en anglais est associé à la défaillance : {0}.</value>
  </data>
  <data name="SimpleStateMustHaveOneTransition" xml:space="preserve">
    <value>L'état « {0} » doit avoir au moins 1 transition.</value>
  </data>
  <data name="SpecialMethodNotFound" xml:space="preserve">
    <value>Méthode '{0}' spéciale de type '{1}' introuvable.</value>
  </data>
  <data name="SqlExceptionCaught" xml:space="preserve">
    <value>Message {1} avec numéro d'exception SQL {0} intercepté.</value>
  </data>
  <data name="StartBookmarkWorkItem" xml:space="preserve">
    <value>Début de l'exécution d'un BookmarkWorkItem pour l'activité '{0}', DisplayName : '{1}', InstanceId : '{2}'. BookmarkName : {3}, BookmarkScope : {4}.</value>
  </data>
  <data name="StartCancelActivityWorkItem" xml:space="preserve">
    <value>Début de l'exécution d'un CancelActivityWorkItem pour l'activité '{0}', DisplayName : '{1}', InstanceId : '{2}'.</value>
  </data>
  <data name="StartCompletionWorkItem" xml:space="preserve">
    <value>Début de l'exécution d'un CompletionWorkItem pour l'activité '{0}' parent, DisplayName : '{1}', InstanceId : '{2}'. Activité '{3}' terminée, DisplayName : '{4}', InstanceId : '{5}'.</value>
  </data>
  <data name="StartExecuteActivityWorkItem" xml:space="preserve">
    <value>Début de l'exécution d'un ExecuteActivityWorkItem pour l'activité '{0}', DisplayName : '{1}', InstanceId : '{2}'.</value>
  </data>
  <data name="StartFaultWorkItem" xml:space="preserve">
    <value>Début de l'exécution d'un FaultWorkItem pour l'activité '{0}', DisplayName : '{1}', InstanceId : '{2}'. L'exception a été propagée à partir de l'activité '{3}', DisplayName : '{4}', InstanceId : '{5}'.</value>
  </data>
  <data name="StartRuntimeWorkItem" xml:space="preserve">
    <value>Début de l'exécution d'un élément de travail runtime pour l'activité '{0}', DisplayName : '{1}', InstanceId : '{2}'.</value>
  </data>
  <data name="StartSignpostEvent" xml:space="preserve">
    <value>Limite d'activité.</value>
  </data>
  <data name="StartSqlCommandExecute" xml:space="preserve">
    <value>Démarrage de l'exécution de la commande SQL : {0}</value>
  </data>
  <data name="StartTransactionContextWorkItem" xml:space="preserve">
    <value>Début de l'exécution d'un TransactionContextWorkItem pour l'activité '{0}', DisplayName : '{1}', InstanceId : '{2}'.</value>
  </data>
  <data name="StateCannotBeAddedTwice" xml:space="preserve">
    <value>L'état « {0} » ne peut pas être ajouté deux fois à une machine à états. Tous les états d'une machine à états doivent être uniques.</value>
  </data>
  <data name="StateCannotBeSerialized" xml:space="preserve">
    <value>L'instance '{0}' ne peut pas être exécutée ou rendue persistante car elle a rencontré une erreur lors d'une mise à jour dynamique. Pour exécuter l'instance, rechargez une nouvelle copie depuis le magasin de persistance.</value>
  </data>
  <data name="StateMachineMustHaveInitialState" xml:space="preserve">
    <value>StateMachine « {0} » doit avoir un état initial.</value>
  </data>
  <data name="StateNotBelongToAnyParent" xml:space="preserve">
    <value>L'état cible « {1} » de la transition « {0} » doit appartenir à une machine à états.</value>
  </data>
  <data name="StopSignpostEvent" xml:space="preserve">
    <value>Limite d'activité.</value>
  </data>
  <data name="StoreReportedConflictingLockTokens" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a appelé BindInstanceOwner deux fois avec la même valeur instanceOwnerId mais différentes valeurs lockToken. Utilisez un fournisseur de persistance qui utilise toujours le même lockToken pour un même propriétaire d'instance.</value>
  </data>
  <data name="StoreViolationNoInstanceBound" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle n'a pas pu lier InstanceHandle à une instance, ni définir InstanceState lors du traitement de LoadWorkflowByInstanceKeyCommand, de LoadWorkflowCommand ou de TryLoadRunnableWorkflowCommand.</value>
  </data>
  <data name="SubexpressionResultWasNotVisible" xml:space="preserve">
    <value>La sous-expression de l'objet de type '{0}' a créé une référence d'emplacement non visible dans cette portée.</value>
  </data>
  <data name="SubexpressionResultWasNull" xml:space="preserve">
    <value>La sous-expression de l'objet de type '{0}' a entraîné une valeur Null.</value>
  </data>
  <data name="SwitchCaseKeyTypesMustMatchExpressionType" xml:space="preserve">
    <value>Les cas Switch '{0}' contiennent {1} clés qui ne sont pas compatibles avec le type d'expression de '{2}'.</value>
  </data>
  <data name="SwitchCaseNotFound" xml:space="preserve">
    <value>L'activité Switch '{0}' n'a pas trouvé une activité Case qui correspond au résultat Expression.</value>
  </data>
  <data name="SwitchCaseNullWithValueType" xml:space="preserve">
    <value>Une clé de cas Null existe, mais l'expression Switch est de type valeur '{0}'. Les types valeur ne peuvent pas être Null.</value>
  </data>
  <data name="SwitchCaseTypeMismatch" xml:space="preserve">
    <value>La clé de cas '{0}' n'est pas de type '{1}' et pourrait ne jamais correspondre à une valeur générée par l'expression Switch de type 'InArgument&lt;{1}&gt;'.</value>
  </data>
  <data name="SymbolNamesMustBeUnique" xml:space="preserve">
    <value>Une variable, RuntimeArgument ou un DelegateArgument, portant le nom '{0}' existe déjà. Les noms doivent être uniques au sein de la portée de l'environnement.</value>
  </data>
  <data name="SymbolResolverAlreadyExists" xml:space="preserve">
    <value>Une instance de workflow ne peut être configurée qu'avec un unique SymbolResolver. WorkflowInstanceExtensionManager contient déjà un SymbolResolver.</value>
  </data>
  <data name="SymbolResolverDoesNotHaveSymbol" xml:space="preserve">
    <value>Impossible de trouver le symbole '{0}' de type '{1}' dans l'extension SymbolResolver pour cette instance.</value>
  </data>
  <data name="SymbolResolverMustBeSingleton" xml:space="preserve">
    <value>Impossible d'utiliser SymbolResolver en tant qu'extension par instance. Utilisez la surcharge de singletonObject pour ajouter un SymbolResolver au WorkflowInstanceExtensionManager.</value>
  </data>
  <data name="TargetContractCannotBeOneWayWithTransactionFlow" xml:space="preserve">
    <value>Définition de contrat non valide : TransactionFlowOption a la valeur Mandatory dans l'opération monodirectionnelle de l'opération '{0}' du contrat '{1}'.</value>
  </data>
  <data name="TargetTypeAndTargetObjectAreMutuallyExclusive" xml:space="preserve">
    <value>TargetType et TargetObject s'excluent mutuellement pour {0} '{1}'.</value>
  </data>
  <data name="TargetTypeCannotBeEnum" xml:space="preserve">
    <value>Le type d'opérande dans {0} '{1}' ne peut pas être de type enum.</value>
  </data>
  <data name="TargetTypeIsValueType" xml:space="preserve">
    <value>Le type d'opérande est un type valeur. La modification du champ dans '{0}' '{1}' sera sans effet.</value>
  </data>
  <data name="TaskTimedOutError" xml:space="preserve">
    <value>La tâche a expiré après {0}. Le temps alloué à cette opération peut avoir été une partie d'un délai d'expiration plus long.</value>
  </data>
  <data name="TextExpressionCompilerActivityNameRequired" xml:space="preserve">
    <value>Un TextExpressionCompilerSettings.ActivityName doit être fourni.</value>
  </data>
  <data name="TextExpressionCompilerActivityNamespaceRequired" xml:space="preserve">
    <value>Un TextExpressionCompilerSettings.ActivityNamespace doit être fourni.</value>
  </data>
  <data name="TextExpressionCompilerActivityRequired" xml:space="preserve">
    <value>Un TextExpressionCompilerSettings.Activity doit être fourni.</value>
  </data>
  <data name="TextExpressionCompilerAddGeneratedFileRequired" xml:space="preserve">
    <value>Un TextExpressionCompilerSettings.AddGeneratedFile doit être fourni.</value>
  </data>
  <data name="TextExpressionCompilerLanguageRequired" xml:space="preserve">
    <value>Un TextExpressionCompilerSettings.Language doit être fourni.</value>
  </data>
  <data name="TextExpressionCompilerNoCodebase" xml:space="preserve">
    <value>L'assembly chargé pour le nom '{0}' ne contient pas de valeur CodeBase. CodeBase est nécessaire à la compilation.</value>
  </data>
  <data name="TextExpressionCompilerOutputPathRequired" xml:space="preserve">
    <value>Un TextExpressionCompilerSettings.OutputPath doit être fourni.</value>
  </data>
  <data name="TextExpressionCompilerUnableToLoadAssembly" xml:space="preserve">
    <value>Impossible de charger l'assembly '{0}'.</value>
  </data>
  <data name="TextExpressionMetadataRequiresCompilation" xml:space="preserve">
    <value>Le type '{0}' d'activité de l'expression nécessite une compilation pour pouvoir être exécuté. Assurez-vous que le workflow a été compilé.</value>
  </data>
  <data name="ThreadNeutralSemaphoreAborted" xml:space="preserve">
    <value>ThreadNeutralSemaphore a été abandonné.</value>
  </data>
  <data name="ThrowingEtwException" xml:space="preserve">
    <value>Levée d'une exception. Source: {0}. Détails de l'exception : {1}</value>
  </data>
  <data name="ThrowingEtwExceptionVerbose" xml:space="preserve">
    <value>Levée d'une exception. Source: {0}. Détails de l'exception : {1}</value>
  </data>
  <data name="ThrowingException" xml:space="preserve">
    <value>Levée d'une exception. Source: {0}. Détails de l'exception : {1}</value>
  </data>
  <data name="ThrowingExceptionVerbose" xml:space="preserve">
    <value>Levée d'une exception. Source: {0}. Détails de l'exception : {1}</value>
  </data>
  <data name="TimedOutWaitingForLockResolution" xml:space="preserve">
    <value>Le fournisseur de persistance n'a pas pu récupérer le verrou dans le délai imparti. Cela peut indiquer un interblocage dans le schéma des commandes exécutées simultanément sur différents InstanceHandles appartenant au même InstanceOwner. Ce problème peut être corrigé en utilisant plusieurs InstanceOwners ou en s'assurant que InstancePersistenceCommand.AutomaticallyAcquiringLock retourne la valeur false pour les commandes qui ne sont pas susceptibles d'acquérir un verrou sur l'instance.</value>
  </data>
  <data name="TimeoutInputQueueDequeue" xml:space="preserve">
    <value>Une opération d'enlèvement de la file d'attente a dépassé le délai imparti après {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'attente plus long.</value>
  </data>
  <data name="TimeoutMustBeNonNegative" xml:space="preserve">
    <value>L'argument {0} doit être une valeur de délai d'expiration non négative. La valeur fournie était {1}.</value>
  </data>
  <data name="TimeoutMustBePositive" xml:space="preserve">
    <value>L'argument {0} doit être une valeur de délai d'expiration positive. La valeur fournie était {1}.</value>
  </data>
  <data name="TimeoutOnOperation" xml:space="preserve">
    <value>L'opération ne s'est pas terminée dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'attente plus long.</value>
  </data>
  <data name="TimeoutOnSqlOperation" xml:space="preserve">
    <value>L'opération ne s'est pas terminée dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'attente plus long.</value>
  </data>
  <data name="TimeoutOpeningSqlConnection" xml:space="preserve">
    <value>Expiration du délai d'attente lors de la tentative d'ouverture d'une connexion SQL. L'opération ne s'est pas terminée dans le délai imparti de {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'attente plus long.</value>
  </data>
  <data name="TimerExtensionAlreadyAttached" xml:space="preserve">
    <value>Ce TimerExtension a déjà été attaché à une instance de workflow.</value>
  </data>
  <data name="TimerExtensionRequiresWorkflowInstance" xml:space="preserve">
    <value>TimerExtension ne peut être utilisé que s'il est attaché à une instance de workflow.</value>
  </data>
  <data name="TooManyViolationsForExceptionMessage" xml:space="preserve">
    <value>&lt;tronqué&gt; Le message d'exception a été tronqué en raison de sa taille. Utilisez ActivityValidationServices pour afficher toutes les violations.</value>
  </data>
  <data name="TraceCodeEventLogCritical" xml:space="preserve">
    <value>Écriture dans le journal d'événements.</value>
  </data>
  <data name="TraceCodeEventLogError" xml:space="preserve">
    <value>Écriture dans le journal d'événements.</value>
  </data>
  <data name="TraceCodeEventLogInfo" xml:space="preserve">
    <value>Écriture dans le journal d'événements.</value>
  </data>
  <data name="TraceCodeEventLogVerbose" xml:space="preserve">
    <value>Écriture dans le journal d'événements.</value>
  </data>
  <data name="TraceCodeEventLogWarning" xml:space="preserve">
    <value>Écriture dans le journal d'événements.</value>
  </data>
  <data name="TraceCorrelationKeys" xml:space="preserve">
    <value>Clé de corrélation '{0}' calculée à l'aide des valeurs '{1}' dans l'étendue parente '{2}'.</value>
  </data>
  <data name="TrackingDataExtracted" xml:space="preserve">
    <value>Données de suivi {0} extraites dans l'activité {1}.</value>
  </data>
  <data name="TrackingProfileNotFound" xml:space="preserve">
    <value>TrackingProfile '{0}' pour le ActivityDefinitionId '{1}' introuvable. TrackingProfile est introuvable dans le fichier de configuration ou ActivityDefinitionId ne correspond pas.</value>
  </data>
  <data name="TrackingRecordDropped" xml:space="preserve">
    <value>La taille de l'enregistrement de suivi {0} dépasse la valeur maximale autorisée par la session ETW pour le fournisseur {1}</value>
  </data>
  <data name="TrackingRecordRaised" xml:space="preserve">
    <value>Enregistrement suivi {0} élevé à {1}.</value>
  </data>
  <data name="TrackingRecordTruncated" xml:space="preserve">
    <value>Enregistrement de suivi {0} tronqué écrit dans la session ETW avec le fournisseur {1}. Les données de variables/annotations/utilisateur ont été supprimées</value>
  </data>
  <data name="TrackingRelatedWorkflowAbort" xml:space="preserve">
    <value>Une erreur s'est produite lors de l'appel des participants de suivi ce qui a entraîné l'abandon de l'instance. Pour plus d'informations, consultez l'exception interne.</value>
  </data>
  <data name="TrackingValueNotSerializable" xml:space="preserve">
    <value>La variable ou l'argument '{0}' extrait ne peut pas être sérialisé.</value>
  </data>
  <data name="TransactedReceiveScopeEndCommitFailed" xml:space="preserve">
    <value>L'appel à EndCommit sur le CommittableTransaction avec l'ID '{0}' a levé un TransactionException avec le message suivant : '{1}'.</value>
  </data>
  <data name="TransactedReceiveScopeMustHaveValidReceive" xml:space="preserve">
    <value>La propriété Request du TransactedReceiveScope '{0}' doit être définie à une activité Receive valide.</value>
  </data>
  <data name="TransactedReceiveScopeRequiresReceive" xml:space="preserve">
    <value>La propriété ReceiveActivity doit être définie avant que TransactedReceiveScope '{0}' puisse être utilisé.</value>
  </data>
  <data name="TransactionHandleAlreadyHasTransaction" xml:space="preserve">
    <value>TransactionHandle a déjà une transaction. Une nouvelle transaction ne peut pas être configurée.</value>
  </data>
  <data name="TransactionInDoubtNonHost" xml:space="preserve">
    <value>Bien qu'aucune transaction ambiante ne fût présente lors de l'appel de InstanceStore.Execute ou de BeginExecute, une transaction interne a été utilisée lors du traitement de la commande. La transaction interne est passée à l'état InDoubt.</value>
  </data>
  <data name="TransactionPersistenceTimeout" xml:space="preserve">
    <value>La requête a dépassé le délai imparti, car l'instance était verrouillée par d'autres transactions.</value>
  </data>
  <data name="TransactionRolledBackNonHost" xml:space="preserve">
    <value>Bien qu'aucune transaction ambiante ne fût présente lors de l'appel de InstanceStore.Execute ou de BeginExecute, une transaction interne a été utilisée lors du traitement de la commande. La transaction interne a été annulée.</value>
  </data>
  <data name="TransitionCannotBeAddedTwice" xml:space="preserve">
    <value>La transition « {0} » ne peut pas être ajoutée à l'état « {1} » car elle a été ajoutée à l'état « {2} ».</value>
  </data>
  <data name="TransitionTargetCannotBeNull" xml:space="preserve">
    <value>La propriété « To » de transition « {0} » de l'état « {1} » ne doit pas être Null.</value>
  </data>
  <data name="TriggerOrConditionChangedDuringTransitioning" xml:space="preserve">
    <value>StateMachine ne prend pas en charge la mise à jour dynamique si l'activité de déclencheur ou de condition de la transition en cours d'exécution a été modifiée.</value>
  </data>
  <data name="TriggerOrConditionIsReferenced" xml:space="preserve">
    <value>StateMachine ne prend pas en charge la mise à jour dynamique lorsque l'une de ses activités de déclencheur ou de condition est une référence à un enfant importé.</value>
  </data>
  <data name="TryCatchExceptionDuringCancelation" xml:space="preserve">
    <value>Une activité enfant de l'activité TryCatch '{0}' a levé une exception durant l'annulation.</value>
  </data>
  <data name="TryCatchExceptionFromCatchOrFinally" xml:space="preserve">
    <value>Une activité Catch ou Finally associée à l'activité TryCatch '{0}' a levé une exception.</value>
  </data>
  <data name="TryCatchExceptionFromTry" xml:space="preserve">
    <value>L'activité TryCatch '{0}' a intercepté une exception de type '{1}'.</value>
  </data>
  <data name="TryCatchInvalidStateForUpdate" xml:space="preserve">
    <value>Mise à jour impossible dans TryCatch car une exception de type '{0}' a été interceptée mais le bloc catch correspondant a été supprimé.</value>
  </data>
  <data name="TryCommandCannotExecuteSubCommandsAndReduce" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a retourné false à partir de TryCommand (ou EndTryCommand) après l'exécution d'une commande imbriquée à l'aide de InstancePersistenceContext.Execute (ou BeginExecute). Si un fournisseur de persistance comprend une commande et agit sur cette dernière, il doit retourner True.</value>
  </data>
  <data name="TryLoadRequiresOwner" xml:space="preserve">
    <value>L'opération WorkflowApplication.LoadRunnableInstance requiert un InstanceOwner créé de manière explicite. Pour utiliser cette méthode, créez un propriétaire d'instance avec un type d'hôte de workflow et définissez-le en tant que DefaultInstanceOwner du InstanceStore.</value>
  </data>
  <data name="TryLoadRequiresWorkflowType" xml:space="preserve">
    <value>Pour charger une instance exécutable à laquelle correspondre dans le magasin, le InstanceOwner demandeur doit avoir spécifié un type d'hôte de workflow lors de sa création. Pour cela, ajoutez une paire clé-valeur dans le conteneur de propriétés CreateWorkflowOwnerCommand.InstanceOwnerMetadata lors de l'émission de la commande. Il s'agit de la clé WorkflowHostType fournie dans la documentation. La valeur doit être un XName et correspondre à celle des instances chargées.</value>
  </data>
  <data name="TryRegisterRequestContextFailed" xml:space="preserve">
    <value>Du contexte du gestionnaire de corrélation n'a pas été consommé correctement. Vérifiez que le gestionnaire a été correctement initialisé par le runtime et que le workflow a un Send suivi par une activité Receive ou ReceiveReply.</value>
  </data>
  <data name="TwoReceiveParametersWithSameNameButDifferentParameterCount" xml:space="preserve">
    <value>Deux objets ReceiveParametersContent avec les mêmes ServiceContractName et OperationName '{0}' ont un nombre de paramètres différents.</value>
  </data>
  <data name="TwoReceiveParametersWithSameNameButDifferentParameterName" xml:space="preserve">
    <value>Deux objets ReceiveParametersContent avec les mêmes ServiceContractName et OperationName '{0}' ont des noms de paramètres différents.</value>
  </data>
  <data name="TwoReceiveParametersWithSameNameButDifferentParameterType" xml:space="preserve">
    <value>Deux objets ReceiveParametersContent avec les mêmes ServiceContractName et OperationName '{0}' ont des types de paramètres différents.</value>
  </data>
  <data name="TwoReceivesWithSameNameButDifferentAction" xml:space="preserve">
    <value>Deux objets Receive avec les mêmes ServiceContractName et OperationName '{0}' ont une action différente.</value>
  </data>
  <data name="TwoReceivesWithSameNameButDifferentIsOneWay" xml:space="preserve">
    <value>Deux objets Receive avec les mêmes ServiceContractName et OperationName '{0}' ont des valeurs IsOneWay différentes.</value>
  </data>
  <data name="TwoReceivesWithSameNameButDifferentTxProperties" xml:space="preserve">
    <value>Deux objets Receive avec les mêmes ServiceContractName et OperationName '{0}' ont des propriétés de transaction différentes.</value>
  </data>
  <data name="TwoReceivesWithSameNameButDifferentValueType" xml:space="preserve">
    <value>Deux objets Receive avec les mêmes ServiceContractName et OperationName '{0}' ont un ValueType différent.</value>
  </data>
  <data name="TwoSendRepliesWithSameNameButDifferentAction" xml:space="preserve">
    <value>Deux objets SendReply avec les mêmes ServiceContractName et OperationName '{0}' ont une action différente.</value>
  </data>
  <data name="TwoSendRepliesWithSameNameButDifferentValueType" xml:space="preserve">
    <value>Deux objets SendReply avec les mêmes ServiceContractName et OperationName '{0}' ont un ValueType différent.</value>
  </data>
  <data name="TwoSendReplyParametersWithSameNameButDifferentParameterCount" xml:space="preserve">
    <value>Deux objets SendParametersContent avec les mêmes ServiceContractName et OperationName '{0}' ont un nombre de paramètres différent.</value>
  </data>
  <data name="TwoSendReplyParametersWithSameNameButDifferentParameterName" xml:space="preserve">
    <value>Deux objets SendParameters avec les mêmes ServiceContractName et OperationName '{0}' ont des noms de paramètres différents.</value>
  </data>
  <data name="TwoSendReplyParametersWithSameNameButDifferentParameterType" xml:space="preserve">
    <value>Deux objets SendParameters avec les mêmes ServiceContractName et OperationName '{0}' ont des types de paramètres différents.</value>
  </data>
  <data name="TwoWayIsImplementedAsOneWay" xml:space="preserve">
    <value>L'opération '{0}' du contrat '{1}' est spécifiée comme étant bidirectionnelle, mais SendReply est manquant. Ajoutez une activité SendReply pour l'opération.</value>
  </data>
  <data name="TypeConverterHelperCacheAddFailed" xml:space="preserve">
    <value>Échec de l'ajout d'un TypeConverterHelper pour le type '{0}' au cache interne des applications d'assistance.</value>
  </data>
  <data name="TypeMismatchForAssign" xml:space="preserve">
    <value>Impossible d'assigner du type '{0}' au type '{1}' dans une activité Assign '{2}'.</value>
  </data>
  <data name="TypeMustbeValueType" xml:space="preserve">
    <value>Le type '{0}' doit être un type valeur.</value>
  </data>
  <data name="TypeNotAssignableTo" xml:space="preserve">
    <value>{0} ne peut pas être attribué à {1}.</value>
  </data>
  <data name="UnableToDeserializeHttpResponseContent" xml:space="preserve">
    <value>Impossible de désérialiser le ResponseContent de type '{0}'.</value>
  </data>
  <data name="UnableToLocateCompiledLocationContext" xml:space="preserve">
    <value>Impossible de localiser ICompiledExpressionRoot pour l'emplacement compilé '{0}'. Assurez-vous que la définition de l'activité contenant cette expression a été compilée.</value>
  </data>
  <data name="UnableToOpenAndRegisterStore" xml:space="preserve">
    <value>Impossible d'initialiser InstanceStore.</value>
  </data>
  <data name="UnconditionalTransitionShouldNotShareNullTriggersWithOthers" xml:space="preserve">
    <value>La transition sans déclencheur « {0} » de l'état « {1} » doit contenir une condition. Un état ne peut avoir qu'une transition inconditionnelle sans déclencheur.</value>
  </data>
  <data name="UnconditionalTransitionShouldNotShareTriggersWithOthers" xml:space="preserve">
    <value>La transition « {0} » de l'état « {1} » est une transition inconditionnelle. Elle ne peut pas partager le même déclencheur « {2} » avec d'autres transitions.</value>
  </data>
  <data name="UnexpectedArgumentCount" xml:space="preserve">
    <value>Le nombre d'arguments spécifiés dans la collection '{0}' est '{1}' alors que le nombre attendu est '{2}'. </value>
  </data>
  <data name="UnexpectedExpressionNodeType" xml:space="preserve">
    <value>Le nœud d'expression de type '{0}' est attendu, mais c'est le nœud d'expression de type '{1}' qui a été fourni.</value>
  </data>
  <data name="UnhandledException" xml:space="preserve">
    <value>Exception non gérée.  Détails de l'exception : {0}</value>
  </data>
  <data name="UninitializedCannotHaveData" xml:space="preserve">
    <value>L'implémentation du fournisseur de persistance de InstanceStore utilisée n'est pas valide. Elle a signalé le chargement d'une instance avec InstanceState.Uninitialized, qui contenait des données d'instance. Les instances non initialisées ne peuvent pas contenir de données d'instance.</value>
  </data>
  <data name="UnInitializedRuntimeTransactionHandle" xml:space="preserve">
    <value>Le RuntimeTransactionHandle spécifié n'a pas été correctement initialisé.</value>
  </data>
  <data name="UnknownCompressionOption" xml:space="preserve">
    <value>L'option de compression demandée {0} n'est pas une option valide.</value>
  </data>
  <data name="UnknownDatabaseVersion" xml:space="preserve">
    <value>Impossible de déterminer la version de la base de données car aucune ligne n'a été trouvée dans System.Activities.DurableInstancing.SqlWorkflowInstanceStoreVersionTable. Cette table doit contenir une ligne correspondant à la version de .NET Framework avec laquelle elle a été créée ou vers laquelle elle a été mise à niveau.</value>
  </data>
  <data name="UnknownExpressionCompilationError" xml:space="preserve">
    <value>Une erreur inconnue s'est produite lors du traitement de l'expression "{0}". Le traitement du texte de l'expression n'a pas provoqué une exception, mais n'a pas créé non plus une expression exécutable.</value>
  </data>
  <data name="UnknownLanguage" xml:space="preserve">
    <value>Impossible d'utiliser '{0}' comme langage pour les expressions.</value>
  </data>
  <data name="UnknownSprocResult" xml:space="preserve">
    <value>La procédure stockée a renvoyé un résultat d'exécution inconnu {0}.</value>
  </data>
  <data name="UnlockInstanceException" xml:space="preserve">
    <value>Exception {0} rencontrée lors de la tentative de déverrouillage de l'instance.</value>
  </data>
  <data name="UnmatchedNoPersistExit" xml:space="preserve">
    <value>Sortie non appariée dans NoPersistHandle. Une sortie ne peut être appelée qu'une fois par entrée.</value>
  </data>
  <data name="UnopenedActivitiesCannotBeExecuted" xml:space="preserve">
    <value>Seules les activités ouvertes peuvent être exécutées. L'activité '{0}' n'a pas été ouverte.</value>
  </data>
  <data name="UnsupportedExpressionType" xml:space="preserve">
    <value>L'expression de type '{0}' n'est pas prise en charge.</value>
  </data>
  <data name="UnsupportedLocationReferenceValue" xml:space="preserve">
    <value>La valeur de LocationReference doit être Variable, RuntimeArgument ou DelegateArgument.</value>
  </data>
  <data name="UnsupportedMemberExpressionWithType" xml:space="preserve">
    <value>La récupération par MemberExpression d'un membre de type '{0}' n'est pas prise en charge.</value>
  </data>
  <data name="UnsupportedReferenceExpressionType" xml:space="preserve">
    <value>L'expression de type '{0}' n'est pas prise en charge pour LValue.</value>
  </data>
  <data name="UnusedInputArguments" xml:space="preserve">
    <value>Les clés suivantes du dictionnaire d'entrées ne correspondent pas aux arguments et doivent être supprimées : {0}. Notez que les noms d'arguments respectent la casse.</value>
  </data>
  <data name="UnwrappedMessageNotSupported" xml:space="preserve">
    <value>Les messages non encapsulés ne sont pris en charge qu'à l'aide de MessageContract. Utilisez le type MessageContract pour l'opération '{0}' du contrat implémenté '{1}'.</value>
  </data>
  <data name="UpdateDefinitionNotFound" xml:space="preserve">
    <value>Le WorkflowIdentity '{0}' ne correspond pas aux WorkflowServices hébergés.</value>
  </data>
  <data name="UpdateMapBuilderRequiredProperty" xml:space="preserve">
    <value>La propriété '{0}' dans DynamicUpdateMapBuilder doit être définie.</value>
  </data>
  <data name="UpdateMapNotFound" xml:space="preserve">
    <value>Aucun DynamicUpdateMap n'est disponible pour la mise à jour du WorkflowIdentity '{0}' vers '{1}'.</value>
  </data>
  <data name="UpdateSymbolsMustMatch" xml:space="preserve">
    <value>Le workflow d'origine et le workflow mis à jour doivent avoir le même nombre, nom, type et ordre de symboles externes.</value>
  </data>
  <data name="UriBaseMustBeSpecified" xml:space="preserve">
    <value>L'argument UriBase doit être spécifié dans l'activité '{0}'.</value>
  </data>
  <data name="UseInstanceStoreInsteadOfPersistenceProvider" xml:space="preserve">
    <value>System.ServiceModel.Activities.WorkflowServiceHost est incompatible avec System.ServiceModel.Persistence.PersistenceProviderBehavior. PersistenceProviderBehavior ou la classe dérivée, par exemple SqlPersistenceProviderBehavior, doit être supprimé. Pour permettre la persistance avec WorkflowServiceHost, un comportement qui installe un System.Runtime.DurableInstancing.InstanceStore doit être utilisé à la place, par exemple SqlInstanceStoreBehavior.</value>
  </data>
  <data name="ValidateUnlockInstance" xml:space="preserve">
    <value>Le système de persistance d'instance n'a pas réussi à traiter un InstancePersistenceCommand non valide. La commande requiert que la propriété UnlockInstance ait la valeur True si la propriété CompleteInstance a la valeur True.</value>
  </data>
  <data name="ValidationContextCannotBeNull" xml:space="preserve">
    <value>L'argument ToValidateContext du {0} nommé '{1}' a été résolu en une valeur Null. Un objet de contexte de validation non Null doit être fourni.</value>
  </data>
  <data name="ValidationErrorPrefixForHiddenActivity" xml:space="preserve">
    <value>L'implémentation privée de l'activité '{0}' présente l'erreur de validation suivante :   </value>
  </data>
  <data name="ValidationErrorPrefixForPublicActivityWithHiddenParent" xml:space="preserve">
    <value>L'implémentation privée de l'activité '{0}' présente l'erreur de validation suivante dans l'activité '{1}':   </value>
  </data>
  <data name="ValueArgumentTypeNotDerivedFromValueType" xml:space="preserve">
    <value>Le ArgumentType du Message n'est pas un type dérivé de DeclaredMessageType dans l'activité '{0}' avec OperationName='{1}'.</value>
  </data>
  <data name="ValueCannotBeNegative" xml:space="preserve">
    <value>'{0}' doit être supérieur ou égal à zéro.</value>
  </data>
  <data name="ValueCannotBeNull" xml:space="preserve">
    <value>La propriété Content doit être définie dans l'activité '{0}' avec OperationName='{1}'.</value>
  </data>
  <data name="ValueCollectionUpdatesNotAllowed" xml:space="preserve">
    <value>La mutation d'une collection de valeurs dérivée d'un dictionnaire n'est pas autorisée.</value>
  </data>
  <data name="ValueMustBeAssignableToType" xml:space="preserve">
    <value>La valeur fournie doit pouvoir être assignée au type fourni.</value>
  </data>
  <data name="ValueMustBeNonNegative" xml:space="preserve">
    <value>La valeur ne doit pas être négative.</value>
  </data>
  <data name="ValueTooLarge" xml:space="preserve">
    <value>Un '{0}' supérieur à Int32.MaxValue ne peut pas être appliqué. Pour désactiver le délai d'attente, spécifiez TimeSpan.MaxValue.</value>
  </data>
  <data name="VariableAlreadyInUseOnActivity" xml:space="preserve">
    <value>La variable '{0}' ne peut pas être utilisée sur l'activité '{1}', car elle est déjà utilisée par l'activité '{2}'.</value>
  </data>
  <data name="VariableCannotBePopulatedInLocationEnvironment" xml:space="preserve">
    <value>Impossible de peupler la variable {0} dans LocationEnvironment.</value>
  </data>
  <data name="VariableDoesNotExist" xml:space="preserve">
    <value>La variable '{0}' n'existe pas dans cet environnement.</value>
  </data>
  <data name="VariableExpressionTypeMismatch" xml:space="preserve">
    <value>La valeur par défaut de la variable '{0}' requiert le type '{1}', mais une activité avec un type de résultat '{2}' est fournie.</value>
  </data>
  <data name="VariableIsReadOnly" xml:space="preserve">
    <value>La variable '{0}' est en lecture seule et ne peut pas être modifiée.</value>
  </data>
  <data name="VariableMustBeSet" xml:space="preserve">
    <value>La variable doit être définie avant que CacheMetadata puisse être appelé.</value>
  </data>
  <data name="VariableNameNotAnIdentifier" xml:space="preserve">
    <value>Impossible de sérialiser le nom de la variable '{0}' car il ne représente pas un identificateur valide.</value>
  </data>
  <data name="VariableNotOpen" xml:space="preserve">
    <value>Impossible d'utiliser la variable '{0}' de type '{1}'. Vérifiez qu'elle est déclarée dans un Activity ou SymbolResolver.</value>
  </data>
  <data name="VariableNotVisible" xml:space="preserve">
    <value>L'objet Variable référencé (Nom = '{0}') n'est pas visible dans cette portée. Une autre référence d'emplacement portant le même nom peut exister qui est visible dans cette portée, mais elle ne fait pas référence au même emplacement.</value>
  </data>
  <data name="VariableOnlyAccessibleAtScopeOfDeclaration" xml:space="preserve">
    <value>L'activité '{0}' ne peut pas accéder à cette variable, car elle est déclarée dans la portée de l'activité '{1}'. Une activité ne peut accéder qu'à ses propres variables d'implémentation.</value>
  </data>
  <data name="VariableOrArgumentAdditionToReferencedEnvironmentNoDUSupported" xml:space="preserve">
    <value>L'ajout de variables ou d'arguments à une activité terminée pouvant être référencée par le gestionnaire de compensation ou le gestionnaire de confirmation n'est pas pris en charge.</value>
  </data>
  <data name="VariableOrArgumentDoesNotExist" xml:space="preserve">
    <value>La variable ou l'argument '{0}' n'existe pas dans cet environnement.</value>
  </data>
  <data name="VariableShouldBeOpen" xml:space="preserve">
    <value>La variable '{0}' doit être incluse dans une activité avant d'être utilisée.</value>
  </data>
  <data name="VariableTypeInvalid" xml:space="preserve">
    <value>Impossible d'utiliser la variable '{0}' dans une expression de type '{1}', car elle est de type '{2}' qui n'est pas compatible.</value>
  </data>
  <data name="VariableTypeNotMatchLocationType" xml:space="preserve">
    <value>Le type de variable '{0}' ne correspond pas au type d'emplacement '{1}'.</value>
  </data>
  <data name="ExpressionTamperedSinceLastCompiled" xml:space="preserve">
    <value>GetExpressionTree n'a pas pu obtenir une arborescence d'expression car le texte de l'expression ou le LocationReferenceEnvironment visible a été modifié depuis la dernière mise en cache. Le message d'erreur de compilation est : {0}.</value>
  </data>
  <data name="WaitAlreadyInProgress" xml:space="preserve">
    <value>InstanceHandle ne peut prendre en charge qu'une seule opération WaitForEvents ou BeginWaitForEvents en attente exécutée à la fois. Une seconde opération a été tentée. Vous devez attendre la fin de l'opération précédente avant d'appeler WaitForEvents / BeginWaitForEvents.</value>
  </data>
  <data name="WaitForEventsTimedOut" xml:space="preserve">
    <value>Une opération WaitForEvents ou BeginWaitForEvents a dépassé le délai imparti après {0}. Le temps alloué à cette opération fait peut-être partie d'un délai d'attente plus long.</value>
  </data>
  <data name="WDCDisposed" xml:space="preserve">
    <value>WorkflowDataContext n'est accessible qu'au sein de la portée de l'activité dans laquelle il a été obtenu.</value>
  </data>
  <data name="WfMessageReceived" xml:space="preserve">
    <value>Message reçu par le workflow</value>
  </data>
  <data name="WfMessageSent" xml:space="preserve">
    <value>Message envoyé à partir du workflow</value>
  </data>
  <data name="WhileRequiresCondition" xml:space="preserve">
    <value>Une condition doit être définie avant qu'une activité While '{0}' puisse être utilisée.</value>
  </data>
  <data name="WindowsGroupNotFound" xml:space="preserve">
    <value>Impossible de trouver le groupe Windows '{0}'.</value>
  </data>
  <data name="WorkflowAbortedReason" xml:space="preserve">
    <value>Message InnerException {0} : {1}</value>
  </data>
  <data name="WorkflowActivityResume" xml:space="preserve">
    <value>ID WorkflowInstance : '{0}' Activité E2E</value>
  </data>
  <data name="WorkflowActivityStart" xml:space="preserve">
    <value>ID WorkflowInstance : '{0}' Activité E2E</value>
  </data>
  <data name="WorkflowActivityStop" xml:space="preserve">
    <value>ID WorkflowInstance : '{0}' Activité E2E</value>
  </data>
  <data name="WorkflowActivitySuspend" xml:space="preserve">
    <value>ID WorkflowInstance : '{0}' Activité E2E</value>
  </data>
  <data name="WorkflowApplicationAborted" xml:space="preserve">
    <value>Impossible d'effectuer l'opération car WorkflowApplication {0} a été annulé.</value>
  </data>
  <data name="WorkflowApplicationAlreadyHasId" xml:space="preserve">
    <value>Un ID d'instance a été généré pour WorkflowApplication car la propriété 'Id' a été lue. WorkflowApplication ne peut pas être utilisé pour charger une instance une fois qu'un ID a été généré.</value>
  </data>
  <data name="WorkflowApplicationCompleted" xml:space="preserve">
    <value>WorkflowInstance avec l'Id : '{0}' s'est terminé à l'état Closed.</value>
  </data>
  <data name="WorkflowApplicationIdled" xml:space="preserve">
    <value>WorkflowApplication avec l'Id : '{0}' est devenu inactif.</value>
  </data>
  <data name="WorkflowApplicationInstanceAbandoned" xml:space="preserve">
    <value>Ce WorkflowApplicationInstance a déjà été abandonné ou est en cours d'abandon. Aucune autre opération ne pourra être effectuée.</value>
  </data>
  <data name="WorkflowApplicationInstanceLoaded" xml:space="preserve">
    <value>Cette WorkflowApplicationInstance est déjà associée à une WorkflowApplication. Utilisez cette WorkflowApplication pour contrôler l'instance.</value>
  </data>
  <data name="WorkflowApplicationPersistableIdle" xml:space="preserve">
    <value>WorkflowApplication avec l'Id : '{0}' est inactif et persistant. L'action suivante sera effectuée : {1}.</value>
  </data>
  <data name="WorkflowApplicationPersisted" xml:space="preserve">
    <value>WorkflowApplication avec l'Id : '{0}' était Persisted.</value>
  </data>
  <data name="WorkflowApplicationTerminated" xml:space="preserve">
    <value>WorkflowApplication avec l'Id : '{0}' était terminé en l'état Faulted avec une exception.</value>
  </data>
  <data name="WorkflowApplicationUnhandledException" xml:space="preserve">
    <value>WorkflowInstance avec l'Id : '{0}' a rencontré une exception non prise en charge. L'exception provient de l'activité '{1}', DisplayName : '{2}'. L'action suivante sera effectuée : {3}.</value>
  </data>
  <data name="WorkflowApplicationUnloaded" xml:space="preserve">
    <value>WorkflowInstance avec l'Id : '{0}' était Unloaded.</value>
  </data>
  <data name="WorkflowBehaviorWithNonWorkflowHost" xml:space="preserve">
    <value>Le comportement '{0}' doit être appliqué à un WorkflowServiceHost.</value>
  </data>
  <data name="WorkflowCompletionAsyncResultCannotBeNull" xml:space="preserve">
    <value>Le AsyncResult retourné de OnBeginWorkflowCompleted ne peut pas être Null.</value>
  </data>
  <data name="WorkflowControlEndpointDefaultBaseUriNotSupportedInPartialTrust" xml:space="preserve">
    <value>La valeur par défaut de WorkflowControlEndpoint.DefaultBaseUri n'est pas prise en charge avec la confiance partielle. Utilisez une configuration ou un constructeur autre que par défaut pour spécifier la liaison et l'adresse de WorkflowControlEndpoint.</value>
  </data>
  <data name="WorkflowIdentityNullHostId" xml:space="preserve">
    <value>Une instance persistante avec un WorkflowIdentity ('{0}') ne peut pas être chargée dans un hôte si aucun WorkflowIdentity n'est spécifié.</value>
  </data>
  <data name="WorkflowIdentityNullStateId" xml:space="preserve">
    <value>Une instance persistante sans WorkflowIdentity ne peut pas être chargée dans un hôte dans lequel est spécifié un WorkflowIdentity ('{0}'). L'instance peut être chargée à l'aide d'une autre définition, ou bien être mise à jour à l'aide d'une mise à jour dynamique.</value>
  </data>
  <data name="WorkflowIdentityStateIdHostIdMismatch" xml:space="preserve">
    <value>Le WorkflowIdentity ('{0}') de l'instance chargée ne correspond pas au WorkflowIdentity ('{1}') de la définition de workflow fournie. L'instance peut être chargée à l'aide d'une autre définition, ou bien être mise à jour à l'aide d'une mise à jour dynamique.</value>
  </data>
  <data name="WorkflowInstanceAborted" xml:space="preserve">
    <value>Impossible d'effectuer l'opération, car WorkflowInstance '{0}' a été abandonné.</value>
  </data>
  <data name="WorkflowInstanceAbortedRecordWithId" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceAbortedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4},  Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}</value>
  </data>
  <data name="WorkflowInstanceCanceled" xml:space="preserve">
    <value>WorkflowInstance avec l'Id : '{0}' s'est terminé à l'état Canceled.</value>
  </data>
  <data name="WorkflowInstanceCompleted" xml:space="preserve">
    <value>Impossible d'effectuer l'opération, car WorkflowInstance '{0}' est terminé.</value>
  </data>
  <data name="WorkflowInstanceIsReadOnly" xml:space="preserve">
    <value>Impossible de modifier WorkflowInstance '{0}' une fois son exécution démarrée.</value>
  </data>
  <data name="WorkflowInstanceNotFoundInStore" xml:space="preserve">
    <value>L'instance '{0}' a été trouvée dans le magasin d'instances, mais cette instance ne contient pas un workflow.</value>
  </data>
  <data name="WorkflowInstanceRecordWithId" xml:space="preserve">
    <value>TrackRecord= WorkflowInstanceRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, State = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}</value>
  </data>
  <data name="WorkflowInstanceSuspendedRecord" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceSuspendedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}</value>
  </data>
  <data name="WorkflowInstanceSuspendedRecordWithId" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceSuspendedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}</value>
  </data>
  <data name="WorkflowInstanceTerminated" xml:space="preserve">
    <value>Impossible d'effectuer l'opération, car WorkflowInstance '{0}' a été arrêté.</value>
  </data>
  <data name="WorkflowInstanceTerminatedRecord" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceTerminatedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4}, Annotations = {5}, ProfileName = {6}</value>
  </data>
  <data name="WorkflowInstanceTerminatedRecordWithId" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceTerminatedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, Reason = {4},  Annotations = {5}, ProfileName = {6}, WorkflowDefinitionIdentity = {7}</value>
  </data>
  <data name="WorkflowInstanceUnhandledExceptionRecordWithId" xml:space="preserve">
    <value>TrackRecord = WorkflowInstanceUnhandledExceptionRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, SourceName = {4}, SourceId = {5}, SourceInstanceId = {6}, SourceTypeName={7}, Exception={8},  Annotations= {9}, ProfileName = {10}, WorkflowDefinitionIdentity = {11}</value>
  </data>
  <data name="WorkflowInstanceUnloaded" xml:space="preserve">
    <value>Impossible d'effectuer l'opération, car WorkflowInstance '{0}' a été déchargé.</value>
  </data>
  <data name="WorkflowInstanceUnlocked" xml:space="preserve">
    <value>Impossible d'effectuer l'opération car WorkflowInstance {0} est déverrouillé.</value>
  </data>
  <data name="WorkflowInstanceUpdatedRecord" xml:space="preserve">
    <value>TrackRecord= WorkflowInstanceUpdatedRecord, InstanceID = {0}, RecordNumber = {1}, EventTime = {2}, ActivityDefinitionId = {3}, State = {4}, OriginalDefinitionIdentity = {5}, UpdatedDefinitionIdentity = {6}, Annotations = {7}, ProfileName = {8}</value>
  </data>
  <data name="WorkflowInstanceUpdateFailed" xml:space="preserve">
    <value>Le WorkflowInstance '{0}' n'a pas pu être mis à jour vers l'identité '{1}'. Consultez la liste des activités en cours d'exécution qui n'ont pas pu être mises à jour dans la sortie de suivi.</value>
  </data>
  <data name="WorkflowMustBeHosted" xml:space="preserve">
    <value>Vérifiez qu'une activité Receive est hébergée au sein d'un WorkflowServiceHost.</value>
  </data>
  <data name="WorkflowServiceDefinitionIdentityNotMatched" xml:space="preserve">
    <value>Le WorkflowIdentity ('{0}') de l'instance chargée ne correspond à aucun des WorkflowServices hébergés.</value>
  </data>
  <data name="WorkflowServiceHostCannotAddOrRemoveServiceDefinitionAfterOpen" xml:space="preserve">
    <value>Les définitions WorkflowService ne peuvent pas être ajoutées ni supprimées une fois que l'élément WorkflowServiceHost a été ouvert, est défectueux, annulé ou fermé.</value>
  </data>
  <data name="WorkflowTerminatedExceptionDefaultMessage" xml:space="preserve">
    <value>Le workflow a été arrêté par une activité Terminate.</value>
  </data>
  <data name="WorkItemAbortedInstance" xml:space="preserve">
    <value>Une erreur de traitement de l'élément de travail actuel a entraîné l'abandon du workflow.  Voir l'exception interne pour obtenir plus de détails.</value>
  </data>
  <data name="WrapperNotSupportedInMessageContract" xml:space="preserve">
    <value>Les noms et espaces de noms de wrappers personnalisés sont uniquement pris en charge à l'aide de MessageContract. Utilisez un type MessageContract pour l'opération '{0}' du contrat implémenté '{1}'.</value>
  </data>
  <data name="WriteAccessToReadOnlyPublicReference" xml:space="preserve">
    <value>L'activité '{0}' ne peut pas écrire dans cette référence d'emplacement public car elle a été déclarée à l'aide d'ArgumentDirection.In. Pour permettre la lecture et l'écriture, déclarez la référence à l'aide d'ArgumentDirection.InOut.</value>
  </data>
  <data name="WriteonlyPropertyCannotBeRead" xml:space="preserve">
    <value>La propriété ou l'indexeur '{0}.{1}' ne peut pas être utilisé dans ce contexte, car l'accesseur get est inaccessible.</value>
  </data>
  <data name="WrongArgumentType" xml:space="preserve">
    <value>Type incorrect de l'argument. Il est de type '{0}', mais doit pouvoir être assigné à '{1}'.</value>
  </data>
  <data name="WrongCacheMetadataForCodeActivity" xml:space="preserve">
    <value>La méthode CacheMetadata qui prend un paramètre ActivityMetadata ne doit pas être appelée sur un CodeActivity ou un AsyncCodeActivity. Le CacheMetadata correct pour ces classes prend un paramètre CodeActivityMetadata.</value>
  </data>
  <data name="WrongCacheMetadataForNativeActivity" xml:space="preserve">
    <value>La méthode CacheMetadata qui prend un paramètre ActivityMetadata ne doit pas être appelée sur un NativeActivity. Le CacheMetadata correct pour NativeActivity prend un paramètre NativeActivityMetadata.</value>
  </data>
  <data name="WrongEnvironmentCount" xml:space="preserve">
    <value>Il est attendu que l'activité '{0}' ait '{1}' argument(s), '{2}' variable(s) publique(s), '{3}' variable(s) privée(s) et '{4}' argument(s) délégué(s) d'exécution. En réalité, l'activité a : '{5}' arguments, '{6}' variable(s) publique(s), '{7}' variable(s) privée(s), '{8}' argument(s) délégué(s) d'exécution.</value>
  </data>
  <data name="WrongMemberCount" xml:space="preserve">
    <value>L'IdSpace dont le propriétaire est '{0}' a '{1}' membres ; Nombre de membres attendu : '{2}'.</value>
  </data>
  <data name="WrongNumberOfArgumentsForActivityDelegate" xml:space="preserve">
    <value>Les arguments ActivityDelegate ne correspondent pas. Vérifiez la configuration de votre activité pour vous assurer qu'elle est synchronisée avec le ActivityDelegate déclaré.</value>
  </data>
  <data name="WrongOnCreateDynamicUpdateMapForNativeActivity" xml:space="preserve">
    <value>La méthode OnCreateDynamicUpdateMap qui prend un paramètre UpdateMapMetadata ne doit pas être appelée sur un NativeActivity. L'OnCreateDynamicUpdateMap correct pour NativeActivity doit prendre un paramètre NativeActivityUpdateMapMetadata.</value>
  </data>
  <data name="WrongOriginalEnvironmentCount" xml:space="preserve">
    <value>Il est attendu que l'environnement d'origine de l'activité '{0}' ait '{1}' argument(s), '{2}' variable(s) publique(s), '{3}' variable(s) privée(s) et '{4}' argument(s) délégué(s) d'exécution, pour un total de '{5}'. Le total réel d'emplacements est de '{6}'.</value>
  </data>
  <data name="XamlBuildTaskResourceNotFound" xml:space="preserve">
    <value>La ressource XAML qui aurait dû être générée par la tâche de génération XAML ({0}) est introuvable. Régénérez le projet.</value>
  </data>
  <data name="XamlElementExpected" xml:space="preserve">
    <value>Représentation d'élément attendue.</value>
  </data>
  <data name="XamlElementExpectedAt" xml:space="preserve">
    <value>Une représentation d'élément est attendue à la ligne ({0}, {1}).</value>
  </data>
</root>